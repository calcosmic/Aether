# Aether State Management - Comprehensive Technical Documentation

## Executive Summary

The Aether state management system is a sophisticated, multi-layered architecture designed to track colony progress, worker spawns, constraints, and session continuity across distributed AI agent workflows. This document provides exhaustive technical documentation of every component, from the core COLONY_STATE.json schema to the pheromone signaling system, checkpoint mechanisms, session management, and file locking infrastructure.

**Document Statistics:**
- Original analysis: ~2,100 words
- This expanded documentation: ~15,000+ words
- Coverage: 5 major subsystems, 50+ data structures, 100+ fields

---

## Table of Contents

1. [COLONY_STATE.json Schema](#1-colony_statejson-schema)
2. [Pheromone System](#2-pheromone-system)
3. [Checkpoint System](#3-checkpoint-system)
4. [Session Management](#4-session-management)
5. [File Locking](#5-file-locking)
6. [Appendix: File Locations](#appendix-file-locations)

---

## 1. COLONY_STATE.json Schema

### 1.1 Overview

**File Location:** `.aether/data/COLONY_STATE.json`

The COLONY_STATE.json file serves as the central nervous system of the Aether colony. It maintains the canonical record of colony progress, goals, errors, memory, and operational state. Every colony operation reads from or writes to this file, making it the single source of truth for colony coordination.

### 1.2 Complete Schema Structure

```json
{
  "version": "3.0",
  "goal": null,
  "state": "READY",
  "current_phase": 0,
  "milestone": "First Mound",
  "milestone_updated_at": "2026-02-15T16:00:00Z",
  "session_id": null,
  "initialized_at": null,
  "build_started_at": null,
  "plan": {
    "generated_at": null,
    "confidence": 0,
    "phases": []
  },
  "memory": {
    "phase_learnings": [],
    "decisions": [],
    "instincts": []
  },
  "errors": {
    "records": [],
    "flagged_patterns": []
  },
  "signals": [],
  "graveyards": [],
  "events": [],
  "created_at": "2026-02-15T16:00:00Z",
  "last_updated": "2026-02-15T16:00:00Z",
  "paused": false,
  "model_profile": {
    "active_profile": "default",
    "profile_file": ".aether/model-profiles.yaml",
    "routing_enabled": true,
    "proxy_endpoint": "http://localhost:4000",
    "updated_at": "2026-02-15T16:00:00Z"
  }
}
```

### 1.3 Field-by-Field Documentation

#### 1.3.1 Top-Level Metadata Fields

| Field | Type | Required | Default | Description |
|-------|------|----------|---------|-------------|
| `version` | string | Yes | "3.0" | Schema version identifier. Must be exactly "3.0". Used for migration detection. |
| `goal` | string\|null | Yes | null | Current colony goal as set by `/ant:init`. Free-form text describing the project objective. Null when uninitialized. |
| `state` | string | Yes | "READY" | Colony operational state. Enum: READY, BUILDING, PAUSED, ERROR, COMPLETED. |
| `current_phase` | number | Yes | 0 | Active phase number (0 = initialization). Incremented by `/ant:build` commands. |
| `milestone` | string | Yes | "First Mound" | Current milestone using biological metaphor naming. See milestone progression table. |
| `milestone_updated_at` | string (ISO8601) | Yes | current timestamp | When milestone was last changed. Used for tracking progression velocity. |
| `session_id` | string\|null | Yes | null | Unique session identifier. Generated on init, used for session continuity. |
| `initialized_at` | string\|null | Yes | null | ISO timestamp of colony initialization. Null until `/ant:init` completes. |
| `build_started_at` | string\|null | Yes | null | ISO timestamp when current build phase started. Reset on each `/ant:build`. |
| `created_at` | string (ISO8601) | Yes | current timestamp | Immutable timestamp of COLONY_STATE.json creation. |
| `last_updated` | string (ISO8601) | Yes | current timestamp | Updated on every state modification. Used for freshness detection. |
| `paused` | boolean | Yes | false | Pause state flag. When true, colony operations are suspended. |

#### 1.3.2 Plan Object

The `plan` object contains the build plan structure generated by `/ant:plan`.

```json
{
  "plan": {
    "generated_at": "2026-02-15T16:00:00Z",
    "confidence": 85,
    "phases": [
      {
        "id": 1,
        "name": "Setup and Configuration",
        "status": "completed",
        "tasks": ["task-1", "task-2"],
        "estimated_hours": 4
      }
    ]
  }
}
```

**Plan Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `generated_at` | string (ISO8601)\|null | When plan was created. Null if no plan exists. |
| `confidence` | number (0-100) | Plan confidence score. Higher = more reliable estimates. |
| `phases` | array | Array of phase objects. Empty array when uninitialized. |

**Phase Object Structure:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | number | Phase identifier (1-indexed). |
| `name` | string | Human-readable phase name. |
| `status` | string | Enum: pending, in_progress, completed, failed, blocked. |
| `tasks` | array[string] | Task identifiers for this phase. |
| `estimated_hours` | number | Estimated completion time. |

#### 1.3.3 Memory Object

The `memory` object stores colony learning and institutional knowledge.

```json
{
  "memory": {
    "phase_learnings": [
      {
        "phase": 1,
        "learning": "Use async/await for file I/O",
        "category": "performance",
        "timestamp": "2026-02-15T16:00:00Z"
      }
    ],
    "decisions": [
      {
        "id": "dec_001",
        "decision": "Use TypeScript over JavaScript",
        "rationale": "Type safety reduces runtime errors",
        "made_by": "architect-1",
        "timestamp": "2026-02-15T16:00:00Z"
      }
    ],
    "instincts": [
      {
        "id": "inst_001",
        "pattern": "Always validate JSON before parsing",
        "source": "global",
        "weight": 1.0
      }
    ]
  }
}
```

**Memory Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `phase_learnings` | array | Per-phase lessons learned. Max 100 entries. |
| `decisions` | array | Key architectural decisions. Max 50 entries. |
| `instincts` | array | Injected global learnings. Survives colony reset. |

**Phase Learning Entry:**

| Field | Type | Description |
|-------|------|-------------|
| `phase` | number | Phase number where learning occurred. |
| `learning` | string | The actual lesson text. |
| `category` | string | Enum: performance, security, maintainability, architecture. |
| `timestamp` | string (ISO8601) | When learning was recorded. |

**Decision Entry:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique decision identifier (dec_{timestamp}_{random}). |
| `decision` | string | Decision description. |
| `rationale` | string | Why this decision was made. |
| `made_by` | string | Worker or user who made the decision. |
| `timestamp` | string (ISO8601) | When decision was recorded. |

**Instinct Entry:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique instinct identifier (inst_{timestamp}_{random}). |
| `pattern` | string | The instinct pattern/rule. |
| `source` | string | Where instinct came from (global, project, worker). |
| `weight` | number (0.0-1.0) | Importance weight. Higher = more critical. |

#### 1.3.4 Errors Object

The `errors` object tracks error history and recurring patterns.

```json
{
  "errors": {
    "records": [
      {
        "id": "err_1708000000_a1b2",
        "category": "E_FILE_NOT_FOUND",
        "severity": "critical",
        "description": "COLONY_STATE.json not found",
        "root_cause": "Initialization not run",
        "phase": 1,
        "task_id": "task-1",
        "timestamp": "2026-02-15T16:00:00Z"
      }
    ],
    "flagged_patterns": [
      {
        "pattern": "missing_state_file",
        "count": 3,
        "first_seen": "2026-02-15T16:00:00Z",
        "last_seen": "2026-02-15T17:00:00Z"
      }
    ]
  }
}
```

**Errors Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `records` | array | Error history. Max 50 entries (FIFO eviction). |
| `flagged_patterns` | array | Recurring error patterns. Auto-generated. |

**Error Record Entry:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique error ID (err_{unixtime}_{random}). |
| `category` | string | Error code from E_* constants. |
| `severity` | string | Enum: critical, high, medium, low, info. |
| `description` | string | Human-readable error description. |
| `root_cause` | string\|null | Identified root cause if known. |
| `phase` | number\|null | Phase where error occurred. |
| `task_id` | string\|null | Task identifier if applicable. |
| `timestamp` | string (ISO8601) | When error occurred. |

**Flagged Pattern Entry:**

| Field | Type | Description |
|-------|------|-------------|
| `pattern` | string | Pattern identifier (usually error category). |
| `count` | number | Number of occurrences. |
| `first_seen` | string (ISO8601) | First occurrence timestamp. |
| `last_seen` | string (ISO8601) | Most recent occurrence timestamp. |

#### 1.3.5 Signals Array (Deprecated)

The `signals` array in COLONY_STATE.json is deprecated in favor of the separate pheromones.json file. It remains in the schema for backward compatibility but should always be empty in new colonies.

```json
{
  "signals": []
}
```

#### 1.3.6 Graveyards Array

The `graveyards` array tracks files where builders have failed, marking them as potentially problematic.

```json
{
  "graveyards": [
    {
      "id": "grave_1708000000_a1b2",
      "file": "src/utils/parser.ts",
      "ant_name": "Builder-42",
      "task_id": "task-5",
      "phase": 2,
      "failure_summary": "Infinite loop in regex parsing",
      "function": "parseComplexPattern",
      "line": 127,
      "timestamp": "2026-02-15T16:00:00Z"
    }
  ]
}
```

**Graveyard Entry Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique grave ID (grave_{unixtime}_{random}). |
| `file` | string | File path where failure occurred. |
| `ant_name` | string | Name of the builder that failed. |
| `task_id` | string | Task being executed. |
| `phase` | number\|null | Phase number. |
| `failure_summary` | string | Brief description of failure. |
| `function` | string\|null | Function name if known. |
| `line` | number\|null | Line number if known. |
| `timestamp` | string (ISO8601) | When grave was recorded. |

**Limits:** Maximum 30 grave entries. Oldest evicted when limit reached.

#### 1.3.7 Events Array

The `events` array logs significant colony events.

```json
{
  "events": [
    {
      "id": "evt_1708000000_a1b2",
      "type": "phase_complete",
      "description": "Phase 1 completed successfully",
      "metadata": {"phase": 1, "duration_minutes": 45},
      "timestamp": "2026-02-15T16:00:00Z"
    }
  ]
}
```

**Event Entry Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Unique event ID (evt_{unixtime}_{random}). |
| `type` | string | Event type enum. |
| `description` | string | Human-readable event description. |
| `metadata` | object | Additional event-specific data. |
| `timestamp` | string (ISO8601) | When event occurred. |

**Event Types:**
- `phase_complete` - Phase finished successfully
- `phase_failed` - Phase failed
- `worker_spawned` - New worker created
- `worker_completed` - Worker finished task
- `milestone_reached` - Milestone achieved
- `error_occurred` - Significant error
- `constraint_added` - New constraint added
- `learning_promoted` - Learning elevated to instinct

#### 1.3.8 Model Profile Object

The `model_profile` object configures AI model routing for different castes.

```json
{
  "model_profile": {
    "active_profile": "default",
    "profile_file": ".aether/model-profiles.yaml",
    "routing_enabled": true,
    "proxy_endpoint": "http://localhost:4000",
    "updated_at": "2026-02-15T16:00:00Z"
  }
}
```

**Model Profile Fields:**

| Field | Type | Description |
|-------|------|-------------|
| `active_profile` | string | Name of active profile (default, performance, economy). |
| `profile_file` | string | Path to YAML profile configuration. |
| `routing_enabled` | boolean | Whether model routing is active. |
| `proxy_endpoint` | string | Model proxy server URL. |
| `updated_at` | string (ISO8601) | When profile was last modified. |

### 1.4 Lifecycle States

The `state` field tracks the colony's operational status through a defined lifecycle.

#### 1.4.1 State Enum Values

| State | Description | Transitions To |
|-------|-------------|----------------|
| `READY` | Colony initialized, ready for commands. | BUILDING, PAUSED |
| `BUILDING` | Active build phase in progress. | READY, PAUSED, ERROR |
| `PAUSED` | Colony operations suspended. | READY, BUILDING |
| `ERROR` | Critical error state. | READY (after resolution) |
| `COMPLETED` | All phases completed. | (terminal) |

#### 1.4.2 State Transition Diagram

```
                    +----------+
                    |  READY   |
                    +----------+
                         |
                    /ant:build
                         |
                         v
                   +------------+
         +-------->|  BUILDING  |<--------+
         |         +------------+         |
         |              |                 |
    /ant:pause    phase complete     error
         |              |                 |
         |              v                 |
         |         +----------+           |
         +---------|  READY   |<----------+
                   +----------+
                         |
                    /ant:pause
                         |
                         v
                   +----------+
                   |  PAUSED  |
                   +----------+
```

### 1.5 Milestone Progression

Milestones use biological metaphors to represent colony maturity stages.

| Milestone | Phases Required | Description |
|-----------|-----------------|-------------|
| First Mound | 0 | Initial colony establishment. |
| Open Chambers | 1+ | Feature work underway. |
| Brood Stable | 3+ | Tests consistently green. |
| Ventilated Nest | 5+ | Performance/latency acceptable. |
| Sealed Chambers | All phases complete | Interfaces frozen. |
| Crowned Anthill | All phases + user confirmation | Release ready. |
| Failed Mound | Any critical error | Error state milestone. |

### 1.6 Validation Rules

#### 1.6.1 Type Validation

All fields are validated on state load:

| Field | Valid Types | Validation Logic |
|-------|-------------|------------------|
| `version` | string | Must equal "3.0" |
| `goal` | string, null | Any string or null |
| `state` | string | Must be enum value |
| `current_phase` | number | Integer >= 0 |
| `milestone` | string | Non-empty string |
| `plan` | object | Must have phases array |
| `memory` | object | Must have 3 sub-arrays |
| `errors` | object | Must have records array |
| `model_profile` | object | Must have routing_enabled boolean |

#### 1.6.2 Constraint Validation

Additional constraints enforced:

- `current_phase` cannot exceed `plan.phases.length` by more than 1
- `milestone_updated_at` must be >= `created_at`
- `errors.records` length <= 50 (enforced on add)
- `graveyards` length <= 30 (enforced on add)
- `memory.phase_learnings` length <= 100
- `memory.decisions` length <= 50

### 1.7 State Modification Operations

All state modifications go through `aether-utils.sh` subcommands:

| Command | Purpose | Atomic? | Lock Required? |
|---------|---------|---------|----------------|
| `error-add` | Log error to COLONY_STATE | Yes | No |
| `grave-add` | Mark file as problematic | Yes | No |
| `flag-add` | Add blocker/issue/note | Yes | Yes |
| `flag-resolve` | Resolve a flag | Yes | Yes |
| `learning-promote` | Promote learning to global | Yes | No |
| `milestone-detect` | Auto-detect milestone | No | No |

---

## 2. Pheromone System

### 2.1 Overview

The pheromone system is Aether's mechanism for user-colony communication. Instead of direct commands, users emit "chemical signals" that influence worker behavior. These signals have priority levels, time-to-live (TTL), and scope constraints.

**Key Design Principles:**
1. **Indirect influence** - Users guide rather than command
2. **Temporal decay** - Signals expire naturally
3. **Priority ordering** - High priority signals processed first
4. **Scoped application** - Signals can target specific castes or paths

### 2.2 Signal Types

#### 2.2.1 FOCUS Signals

**Command:** `/ant:focus "<area>"`

**Priority:** normal

**Default Expiration:** End of current phase

**Purpose:** Directs worker attention to specific areas. Workers weight focused areas higher in task execution.

**Use Cases:**
- Steering the next build phase toward specific components
- Time-limited attention on critical areas
- Directing colonization priorities

**Example:**
```bash
/ant:focus "database schema -- handle migrations carefully"
/ant:build 3
```

**JSON Representation:**
```json
{
  "id": "sig_focus_001",
  "type": "FOCUS",
  "priority": "normal",
  "source": "user",
  "created_at": "2026-02-16T10:00:00Z",
  "expires_at": "2026-02-17T10:00:00Z",
  "active": true,
  "content": {
    "text": "XML migration and pheromone system implementation"
  },
  "tags": [
    {"value": "xml", "weight": 1.0, "category": "tech"},
    {"value": "pheromones", "weight": 0.9, "category": "feature"}
  ],
  "scope": {
    "global": false,
    "castes": ["builder", "architect"],
    "paths": [".aether/utils/*.sh", ".aether/schemas/*.xsd"]
  }
}
```

#### 2.2.2 REDIRECT Signals

**Command:** `/ant:redirect "<pattern to avoid>"`

**Priority:** high

**Default Expiration:** End of current phase

**Purpose:** Acts as a hard constraint. Workers actively avoid specified patterns. This is the strongest signal type.

**Use Cases:**
- Preventing known bad approaches
- Enforcing long-lived constraints across phases
- Steering away from previous failures

**Example:**
```bash
/ant:redirect "Don't use jsonwebtoken -- use jose library instead (Edge Runtime compatible)"
/ant:build 2
```

**JSON Representation:**
```json
{
  "id": "sig_redirect_001",
  "type": "REDIRECT",
  "priority": "high",
  "source": "system",
  "created_at": "2026-02-16T08:00:00Z",
  "expires_at": "2026-03-16T08:00:00Z",
  "active": true,
  "content": {
    "text": "Avoid editing runtime/ directly - edit .aether/ instead"
  },
  "tags": [
    {"value": "safety", "weight": 1.0, "category": "constraint"},
    {"value": "runtime", "weight": 0.8, "category": "path"}
  ],
  "scope": {
    "global": true
  }
}
```

#### 2.2.3 FEEDBACK Signals

**Command:** `/ant:feedback "<observation>"`

**Priority:** low

**Default Expiration:** End of current phase

**Purpose:** Provides gentle course correction. Unlike FOCUS (attention) or REDIRECT (avoidance), FEEDBACK adjusts the colony's approach based on observations.

**Use Cases:**
- Mid-project course correction
- Positive reinforcement
- Quality emphasis shifts

**Example:**
```bash
/ant:feedback "Code is too abstract -- prefer simple, direct implementations over clever abstractions"
```

**JSON Representation:**
```json
{
  "id": "sig_feedback_001",
  "type": "FEEDBACK",
  "priority": "low",
  "source": "worker_builder",
  "created_at": "2026-02-16T12:00:00Z",
  "active": true,
  "content": {
    "text": "Test coverage is good, continue maintaining 80%+ coverage",
    "data": {
      "format": "json",
      "coverage_percent": 85
    }
  },
  "tags": [
    {"value": "testing", "weight": 0.7, "category": "quality"},
    {"value": "coverage", "weight": 0.6, "category": "metric"}
  ]
}
```

### 2.3 Signal Storage

#### 2.3.1 Primary Storage: pheromones.json

**File Location:** `.aether/data/pheromones.json`

**Schema:**
```json
{
  "version": "1.0.0",
  "colony_id": "aether-dev",
  "generated_at": "2026-02-16T17:25:00Z",
  "signals": [
    {
      "id": "sig_focus_001",
      "type": "FOCUS",
      "priority": "normal",
      "source": "user",
      "created_at": "2026-02-16T10:00:00Z",
      "expires_at": "2026-02-17T10:00:00Z",
      "active": true,
      "content": {
        "text": "...",
        "data": {...}
      },
      "tags": [...],
      "scope": {...}
    }
  ]
}
```

#### 2.3.2 Eternal Archive: pheromones.xml

**File Location:** `~/.aether/eternal/pheromones.xml`

**Purpose:** Long-term storage of pheromone signals. Survives colony destruction.

**Export Command:** `pheromone-export`

**XSD Schema:** `.aether/schemas/pheromone.xsd`

**XML Structure:**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<ph:pheromones xmlns:ph="http://aether.colony/schemas/pheromones"
               version="1.0.0"
               generated_at="2026-02-16T17:25:00Z"
               colony_id="aether-dev">
  <metadata>
    <source type="user">Colony Session</source>
    <context>Feature development phase</context>
  </metadata>
  <signal id="sig_focus_001"
          type="FOCUS"
          priority="normal"
          source="user"
          created_at="2026-02-16T10:00:00Z"
          expires_at="2026-02-17T10:00:00Z"
          active="true">
    <content>
      <text>XML migration and pheromone system implementation</text>
      <data format="json">
        <additionalData>...</additionalData>
      </data>
    </content>
    <tags>
      <tag weight="1.0" category="tech">xml</tag>
      <tag weight="0.9" category="feature">pheromones</tag>
    </tags>
    <scope global="false">
      <castes match="any">
        <caste>builder</caste>
        <caste>architect</caste>
      </castes>
      <paths match="any">
        <path>.aether/utils/*.sh</path>
        <path>.aether/schemas/*.xsd</path>
      </paths>
    </scope>
  </signal>
</ph:pheromones>
```

### 2.4 Signal Propagation

#### 2.4.1 Distribution Mechanism

1. **Emission:** User or system creates signal in pheromones.json
2. **Distribution:** Workers read signals at spawn time via `pheromone-read` utility
3. **Filtering:** Expired signals filtered on read (no cleanup process)
4. **Priority Processing:** high -> normal -> low
5. **Scope Matching:** Global, caste-specific, or path-specific

#### 2.4.2 Worker Integration

Workers receive pheromone signals through their initialization context:

```bash
# At spawn time, workers read active pheromones
active_signals=$(bash .aether/aether-utils.sh pheromone-read --caste "$CASTE" --path "$WORKING_PATH")
```

### 2.5 Priority Handling

#### 2.5.1 Priority Levels

| Priority | Value | Processing Order | Use Case |
|----------|-------|------------------|----------|
| high | 3 | First | REDIRECT signals, critical constraints |
| normal | 2 | Second | FOCUS signals, attention guidance |
| low | 1 | Third | FEEDBACK signals, gentle adjustments |

#### 2.5.2 Priority Processing Algorithm

```
1. Collect all active signals
2. Sort by priority (high -> normal -> low)
3. Within same priority, sort by created_at (newest first)
4. Apply signals in order:
   - REDIRECT: Add to constraint list
   - FOCUS: Add to attention list
   - FEEDBACK: Add to adjustment list
5. Deduplicate by content hash
```

### 2.6 TTL (Time-To-Live) System

#### 2.6.1 Expiration Types

| Expiration | Description | Use Case |
|------------|-------------|----------|
| `phase_end` | Signal expires when current phase completes | Default for all signals |
| Wall-clock | Specific timestamp when signal expires | Time-limited focus |
| `never` | Signal persists until manually cleared | Permanent constraints |

#### 2.6.2 Duration Format

Wall-clock TTL uses duration format: `<number><unit>`

| Unit | Meaning | Example |
|------|---------|---------|
| `m` | Minutes | `--ttl 30m` (30 minutes) |
| `h` | Hours | `--ttl 2h` (2 hours) |
| `d` | Days | `--ttl 1d` (1 day) |

#### 2.6.3 Pause-Aware TTL

When colony is paused:
- **Wall-clock TTLs** are extended by pause duration on resume
- **Phase-scoped signals** are unaffected by pause

This ensures signals don't expire while user is away from project.

### 2.7 Scope System

#### 2.7.1 Global Scope

```json
{
  "scope": {
    "global": true
  }
}
```

Applies to all workers regardless of caste or path.

#### 2.7.2 Caste Scope

```json
{
  "scope": {
    "global": false,
    "castes": ["builder", "architect"],
    "caste_match": "any"
  }
}
```

**Match Types:**
- `any` - Signal applies if worker caste is in list
- `all` - Signal applies only if worker has all listed castes (rare)
- `none` - Signal applies if worker caste is NOT in list

#### 2.7.3 Path Scope

```json
{
  "scope": {
    "global": false,
    "paths": [".aether/utils/*.sh", "src/**/*.ts"],
    "path_match": "any"
  }
}
```

Uses glob patterns for path matching. Workers check if their assigned files match any pattern.

### 2.8 Tag System

#### 2.8.1 Tag Structure

```json
{
  "tags": [
    {"value": "xml", "weight": 1.0, "category": "tech"},
    {"value": "pheromones", "weight": 0.9, "category": "feature"},
    {"value": "testing", "weight": 0.7, "category": "quality"}
  ]
}
```

#### 2.8.2 Tag Categories

| Category | Description |
|----------|-------------|
| `tech` | Technology or stack-related |
| `feature` | Feature or functionality |
| `quality` | Code quality concerns |
| `constraint` | Hard constraints |
| `metric` | Measurable metrics |
| `path` | File path patterns |

#### 2.8.3 Tag Weight

Weight range: 0.0 - 1.0

- 1.0 = Critical relevance
- 0.5 = Moderate relevance
- 0.1 = Minor relevance

Used for signal ranking when multiple signals match.

### 2.9 Auto-Emitted Pheromones

The colony automatically emits pheromones during builds:

| Trigger | Signal Type | Source | Content |
|---------|-------------|--------|---------|
| Phase complete | FEEDBACK | worker:builder | Summary of what worked/failed |
| Recurring error | REDIRECT | worker:continue | Pattern to avoid |
| Global learning injection | FEEDBACK | global:inject | Relevant past learnings |

### 2.10 Signal Combinations

| Combination | Effect |
|-------------|--------|
| FOCUS + FEEDBACK | Workers concentrate on focused area and adjust approach |
| FOCUS + REDIRECT | Workers prioritize focused area while avoiding redirected pattern |
| FEEDBACK + REDIRECT | Workers adjust approach and avoid specific patterns |
| All three | Full steering: attention, avoidance, and adjustment |

---

## 3. Checkpoint System

### 3.1 Overview

The checkpoint system creates recoverable checkpoints before potentially destructive operations (auto-fixes, refactors). It uses git stash to preserve system file state.

**Design Philosophy:**
- Protect user work above all else
- Only stash system files (Aether-managed)
- Never touch user data or uncommitted work
- Fast recovery path

### 3.2 Checkpoint Allowlist

**File:** `.aether/data/checkpoint-allowlist.json`

The allowlist defines which files Aether is permitted to modify:

```json
{
  "version": "1.0.0",
  "description": "Files safe for Aether to checkpoint/modify. NEVER touch files outside this list.",
  "system_files": [
    ".aether/aether-utils.sh",
    ".aether/workers.md",
    ".aether/docs/**/*.md",
    ".claude/commands/ant/**/*.md",
    ".claude/commands/st/**/*.md",
    ".opencode/commands/ant/**/*.md",
    ".opencode/agents/**/*.md",
    "runtime/**/*",
    "bin/**/*"
  ],
  "user_data_never_touch": [
    ".aether/data/",
    ".aether/dreams/",
    ".aether/oracle/",
    ".aether/COLONY_STATE.json",
    "TO-DOs.md",
    "*.log",
    ".env",
    ".env.*"
  ]
}
```

### 3.3 Checkpoint Mechanism

#### 3.3.1 Creating a Checkpoint

**Command:** `autofix-checkpoint [label]`

**Implementation:**
```bash
# 1. Check for changes in Aether-managed directories
target_dirs=".aether .claude/commands/ant .claude/commands/st .opencode runtime bin"
has_changes=false

for dir in $target_dirs; do
  if [[ -d "$dir" ]] && [[ -n "$(git status --porcelain "$dir" 2>/dev/null)" ]]; then
    has_changes=true
    break
  fi
done

# 2. If changes exist, create git stash
if [[ "$has_changes" == "true" ]]; then
  label="${1:-autofix-$(date +%s)}"
  stash_name="aether-checkpoint: $label"
  git stash push -m "$stash_name" -- $target_dirs
  json_ok '{"type":"stash","ref":"$stash_name"}'
else
  # No changes - record commit hash
  hash=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
  json_ok '{"type":"commit","ref":"$hash"}'
fi
```

#### 3.3.2 Checkpoint Types

| Type | When Created | Recovery Method |
|------|--------------|-----------------|
| `stash` | Changes in Aether-managed files | `git stash pop` |
| `commit` | No changes, clean state | `git reset --hard` |
| `none` | Not in git repository | None |

### 3.4 Rollback Mechanism

#### 3.4.1 Rollback Command

**Command:** `autofix-rollback <type> <ref>`

**Implementation:**
```bash
case "$ref_type" in
  stash)
    stash_ref=$(git stash list | grep "$ref" | head -1 | cut -d: -f1)
    if [[ -n "$stash_ref" ]]; then
      git stash pop "$stash_ref"
      json_ok '{"rolled_back":true,"method":"stash"}'
    fi
    ;;
  commit)
    if [[ -n "$ref" && "$ref" != "unknown" ]]; then
      git reset --hard "$ref"
      json_ok '{"rolled_back":true,"method":"reset"}'
    fi
    ;;
  none)
    json_ok '{"rolled_back":false,"method":"none"}'
    ;;
esac
```

### 3.5 Recovery Mechanisms

#### 3.5.1 Automatic Recovery

Some commands auto-rollback on failure:

```bash
# Create checkpoint before operation
checkpoint=$(bash .aether/aether-utils.sh autofix-checkpoint "operation-name")

# Attempt operation
if ! operation; then
  # Operation failed - rollback
  bash .aether/aether-utils.sh autofix-rollback "$checkpoint"
  exit 1
fi
```

#### 3.5.2 Manual Recovery

Users can manually restore checkpoints:

```bash
# List checkpoints
git stash list | grep "aether-checkpoint"

# Pop specific checkpoint
git stash pop stash@{n}
```

### 3.6 Known Issues

#### 3.6.1 Critical: Git Stash Data Loss (Fixed)

**Location:** `aether-utils.sh:1452`

**Bug:** Original implementation stashed ALL dirty files, not just system files.

**Impact:** Nearly lost 1,145 lines of user work.

**Fix:** Allowlist now restricts stashing to system files only.

**Prevention:**
```bash
# Current implementation only stashes allowlisted paths
git stash push -m "$stash_name" -- $target_dirs
```

### 3.7 Checkpoint Lifecycle

```
Operation Starts
       |
       v
Create Checkpoint (stash/commit/none)
       |
       v
Attempt Operation
       |
   +---+---+
   |       |
Success  Failure
   |       |
   |       v
   |   Rollback Checkpoint
   |       |
   v       v
Continue  Exit
```

---

## 4. Session Management

### 4.1 Overview

The session management system tracks colony session state, detects stale sessions, and manages session continuity across interruptions.

### 4.2 Session Freshness Detection

#### 4.2.1 Purpose

Prevent stale session files from silently breaking workflows when resuming after long gaps.

#### 4.2.2 Commands Affected

| Command | Files Checked | Protected? | Auto-Clear? |
|---------|---------------|------------|-------------|
| survey | PROVISIONS.md, TRAILS.md, BLUEPRINT.md, etc. | No | Yes |
| oracle | progress.md, research.json | No | Yes |
| watch | watch-status.txt, watch-progress.txt | No | Yes |
| swarm | findings.json | No | Yes |
| init | COLONY_STATE.json, constraints.json | **YES** | **No** |
| seal | manifest.json | **YES** | **No** |
| entomb | manifest.json | **YES** | **No** |

#### 4.2.3 Verification Mechanism

**Command:** `session-verify-fresh --command <name> <session_start_unixtime>`

**Implementation:**
```bash
# 1. Map command to required files
case "$command_name" in
  survey) required_docs="PROVISIONS.md TRAILS.md ..." ;;
  oracle) required_docs="progress.md research.json" ;;
  # ... etc
esac

# 2. Check each file's mtime against session start
file_mtime=$(stat -f %m "$doc_path" 2>/dev/null || stat -c %Y "$doc_path")
if [[ "$file_mtime" -ge "$session_start_time" ]]; then
  fresh_docs+="$doc "
else
  stale_docs+="$doc "
fi

# 3. Return pass/fail
echo '{"ok":true/false,"fresh":[...],"stale":[...],"missing":[...]}'
```

#### 4.2.4 Cross-Platform Timestamp Handling

**Location:** `aether-utils.sh:3241`

```bash
# macOS uses -f %m, Linux uses -c %Y
file_mtime=$(stat -f %m "$doc_path" 2>/dev/null || stat -c %Y "$doc_path" 2>/dev/null || echo "0")
```

**Risk:** If both stat commands fail, returns 0 (epoch), which will always be stale.

### 4.3 Session File Structure

**File:** `.aether/data/session.json`

```json
{
  "session_id": "1708000000_a1b2c3d4",
  "started_at": "2026-02-15T16:00:00Z",
  "last_command": "/ant:build 2",
  "last_command_at": "2026-02-15T17:00:00Z",
  "colony_goal": "Implement user authentication",
  "current_phase": 2,
  "current_milestone": "Open Chambers",
  "suggested_next": "/ant:continue",
  "context_cleared": false,
  "resumed_at": null,
  "active_todos": [
    "Complete login form",
    "Add password validation",
    "Write tests"
  ],
  "summary": "Phase 2 build in progress"
}
```

### 4.4 Session Fields

| Field | Type | Description |
|-------|------|-------------|
| `session_id` | string | Unique session identifier (timestamp + random). |
| `started_at` | string (ISO8601) | When session was created. |
| `last_command` | string\|null | Most recent command executed. |
| `last_command_at` | string\|null | When last command ran. |
| `colony_goal` | string | Current colony goal. |
| `current_phase` | number | Active phase number. |
| `current_milestone` | string | Current milestone name. |
| `suggested_next` | string | Recommended next command. |
| `context_cleared` | boolean | Whether context was cleared. |
| `resumed_at` | string\|null | When session was resumed after pause. |
| `active_todos` | array[string] | Top 3 TODOs from TO-DOs.md. |
| `summary` | string | Brief session summary. |

### 4.5 Handoff Mechanism

#### 4.5.1 Handoff Document

**File:** `.aether/HANDOFF.md`

Created when colony is paused, read on resume:

```markdown
# Colony Session — Build Complete

## Quick Resume
Run `/ant:continue` to advance phase, or `/ant:resume-colony` to restore full context.

## State at Build Completion
- Goal: "Implement user authentication"
- Phase: 2 — Authentication Flow
- Build Status: completed
- Updated: 2026-02-15T17:50:00Z

## Build Summary
Phase 2 build completed successfully...

## Next Steps
- Phase 2 is complete and ready to advance
- Run `/ant:continue` to advance to Phase 3
```

#### 4.5.2 Handoff Detection

**In state-loader.sh:**
```bash
handoff_file="$AETHER_ROOT/.aether/HANDOFF.md"
if [[ -f "$handoff_file" ]]; then
  HANDOFF_DETECTED=true
  HANDOFF_CONTENT=$(cat "$handoff_file")
fi
```

#### 4.5.3 Resumption Flow

```
Session Resumes
      |
      v
Check for HANDOFF.md
      |
   +--+--+
   |     |
 Exists  Missing
   |     |
   v     v
Display  Normal
Context  Startup
   |
   v
Remove HANDOFF.md
   |
   v
Continue Session
```

### 4.6 State Migration

#### 4.6.1 State Loader

**File:** `.aether/utils/state-loader.sh`

```bash
load_colony_state() {
  # 1. Check file exists
  # 2. Acquire lock
  # 3. Validate state
  # 4. Check for handoff
  # 5. Export LOADED_STATE
}

unload_colony_state() {
  # Release lock if acquired
  # Clear state variables
}
```

#### 4.6.2 State Validation

Validation checks on load:
1. File exists and is readable
2. JSON is valid
3. Required fields present
4. Type constraints satisfied
5. No corruption detected

### 4.7 Session Clear Operations

#### 4.7.1 Protected Commands

Commands that never auto-clear:

| Command | Reason |
|---------|--------|
| `init` | COLONY_STATE.json is precious |
| `seal` | Archives are precious |
| `entomb` | Chambers are precious |

#### 4.7.2 Clear Implementation

**Command:** `session-clear --command <name> [--dry-run]`

```bash
case "$command_name" in
  survey)
    files="PROVISIONS.md TRAILS.md BLUEPRINT.md ..."
    ;;
  oracle)
    files="progress.md research.json .stop"
    ;;
  init)
    # Protected - return error
    json_err "Command 'init' is protected and cannot be auto-cleared"
    ;;
esac

# Clear files
for doc in $files; do
  if [[ "$dry_run" == "--dry-run" ]]; then
    echo "Would clear: $doc"
  else
    rm -f "$session_dir/$doc"
  fi
done
```

---

## 5. File Locking

### 5.1 Overview

The file locking system prevents concurrent modifications to colony state files, ensuring data integrity during parallel operations.

### 5.2 Lock Implementation

**File:** `.aether/utils/file-lock.sh`

#### 5.2.1 Lock Directory Structure

```
.aether/locks/
├── COLONY_STATE.json.lock
├── COLONY_STATE.json.lock.pid
├── flags.json.lock
├── flags.json.lock.pid
└── ...
```

#### 5.2.2 Lock Configuration

```bash
LOCK_DIR="$AETHER_ROOT/.aether/locks"
LOCK_TIMEOUT=300          # 5 minutes max lock time
LOCK_RETRY_INTERVAL=0.5   # 500ms between retries
LOCK_MAX_RETRIES=100      # Total 50 seconds max wait
```

#### 5.2.3 Acquire Lock Function

```bash
acquire_lock() {
  local file_path="$1"
  local lock_file="${LOCK_DIR}/$(basename "$file_path").lock"
  local lock_pid_file="${lock_file}.pid"

  # Check for stale lock (PID not running)
  if [ -f "$lock_file" ]; then
    lock_pid=$(cat "$lock_pid_file" 2>/dev/null)
    if [ -n "$lock_pid" ]; then
      if ! kill -0 "$lock_pid" 2>/dev/null; then
        rm -f "$lock_file" "$lock_pid_file"
      fi
    fi
  fi

  # Try to acquire with timeout
  while [ $retry_count -lt $LOCK_MAX_RETRIES ]; do
    if (set -o noclobber; echo $$ > "$lock_file") 2>/dev/null; then
      echo $$ > "$lock_pid_file"
      export LOCK_ACQUIRED=true
      export CURRENT_LOCK="$lock_file"
      return 0
    fi
    sleep $LOCK_RETRY_INTERVAL
  done
  return 1
}
```

#### 5.2.4 Release Lock Function

```bash
release_lock() {
  if [ "$LOCK_ACQUIRED" = "true" ] && [ -n "$CURRENT_LOCK" ]; then
    rm -f "$CURRENT_LOCK" "${CURRENT_LOCK}.pid"
    export LOCK_ACQUIRED=false
    export CURRENT_LOCK=""
    return 0
  fi
  return 1
}
```

### 5.3 Usage Pattern

#### 5.3.1 Standard Lock Pattern

```bash
# Acquire lock
acquire_lock "$flags_file" || json_err "$E_LOCK_FAILED" "Failed to acquire lock"

# Critical section
updated=$(jq ... "$flags_file")
atomic_write "$flags_file" "$updated"

# Release lock
release_lock "$flags_file"
```

#### 5.3.2 Error Handling Pattern

```bash
# With error handling (correct pattern)
updated=$(jq ... "$flags_file") || {
  release_lock "$flags_file" 2>/dev/null || true
  json_err "$E_JSON_INVALID" "Failed to process file"
}
```

### 5.4 Deadlock Prevention

#### 5.4.1 Stale Lock Detection

Locks are automatically cleaned up if the owning process dies:

```bash
# In acquire_lock
if [ -f "$lock_file" ]; then
  lock_pid=$(cat "$lock_pid_file" 2>/dev/null)
  if [ -n "$lock_pid" ]; then
    if ! kill -0 "$lock_pid" 2>/dev/null; then
      # Process not running - clean up stale lock
      rm -f "$lock_file" "$lock_pid_file"
    fi
  fi
fi
```

#### 5.4.2 Timeout Mechanism

Maximum wait time: 50 seconds (100 retries * 0.5s interval)

After timeout, operation fails with `E_LOCK_FAILED`.

### 5.5 BUG-005/BUG-011 Analysis

#### 5.5.1 Bug Description

**Location:** `aether-utils.sh:1022, 1207, 1268, 1301, 1382`

**Issue:** If jq fails after lock acquired, lock may not be released.

**Vulnerable Pattern:**
```bash
# BAD - lock never released if jq fails
acquire_lock "$flags_file"
updated=$(jq ... "$flags_file")  # If this fails...
atomic_write "$flags_file" "$updated"
release_lock "$flags_file"  # ...this never runs
```

#### 5.5.2 Fix Pattern

```bash
# GOOD - lock released on error
acquire_lock "$flags_file"
updated=$(jq ... "$flags_file") || {
  release_lock "$flags_file" 2>/dev/null || true
  json_err "$E_JSON_INVALID" "Failed to process file"
}
atomic_write "$flags_file" "$updated"
release_lock "$flags_file"
```

#### 5.5.3 Affected Locations

| Line | Command | Status |
|------|---------|--------|
| 1022 | flag-auto-resolve | Fixed |
| 1207 | flag-add | Fixed |
| 1268 | flag-resolve | Fixed |
| 1301 | flag-acknowledge | Fixed |
| 1382 | flag-auto-resolve | Fixed |

#### 5.5.4 Workaround

If deadlock occurs:
```bash
# Manually clear locks
rm -f .aether/locks/*.lock .aether/locks/*.lock.pid
```

### 5.6 Lock Utilities

#### 5.6.1 Helper Functions

```bash
# Check if file is locked
is_locked() {
  local file_path="$1"
  local lock_file="${LOCK_DIR}/$(basename "$file_path").lock"
  [ -f "$lock_file" ]
}

# Get PID of lock holder
get_lock_holder() {
  local file_path="$1"
  local lock_file="${LOCK_DIR}/$(basename "$file_path").lock.pid"
  cat "$lock_file" 2>/dev/null || echo ""
}

# Wait for lock to be released
wait_for_lock() {
  local file_path="$1"
  local max_wait=${2:-$LOCK_TIMEOUT}
  local waited=0

  while is_locked "$file_path" && [ $waited -lt $max_wait ]; do
    sleep 1
    waited=$((waited + 1))
  done

  [ $waited -lt $max_wait ]
}
```

### 5.7 Cleanup Mechanisms

#### 5.7.1 Automatic Cleanup

```bash
# Register cleanup on exit
cleanup_locks() {
  if [ "$LOCK_ACQUIRED" = "true" ]; then
    release_lock
  fi
}
trap cleanup_locks EXIT TERM INT
```

#### 5.7.2 Manual Cleanup

```bash
# Clear all locks (emergency only)
rm -rf .aether/locks/*
```

---

## Appendix: File Locations

### State Files

| Component | Path | Purpose |
|-----------|------|---------|
| Main State | `.aether/data/COLONY_STATE.json` | Central colony state |
| Session | `.aether/data/session.json` | Session tracking |
| Pheromones | `.aether/data/pheromones.json` | Active signals |
| Flags | `.aether/data/flags.json` | Blockers/issues/notes |
| Constraints | `.aether/data/constraints.json` | User constraints |
| Learnings | `.aether/data/learnings.json` | Global learnings |
| Error Patterns | `.aether/data/error-patterns.json` | Recurring errors |
| View State | `.aether/data/view-state.json` | UI collapse state |

### Log Files

| Component | Path | Purpose |
|-----------|------|---------|
| Activity Log | `.aether/data/activity.log` | Colony activity stream |
| Spawn Tree | `.aether/data/spawn-tree.txt` | Worker spawn tracking |
| Timing Log | `.aether/data/timing.log` | Worker timing data |

### Lock Files

| Component | Path | Purpose |
|-----------|------|---------|
| Lock Directory | `.aether/locks/` | File lock storage |

### Handoff Files

| Component | Path | Purpose |
|-----------|------|---------|
| Handoff Doc | `.aether/HANDOFF.md` | Session handoff |

### Context Files

| Component | Path | Purpose |
|-----------|------|---------|
| Context | `.aether/CONTEXT.md` | Human-readable context |
| Queen Wisdom | `.aether/docs/QUEEN.md` | Accumulated wisdom |

### Utility Scripts

| Component | Path | Purpose |
|-----------|------|---------|
| Main Utils | `.aether/aether-utils.sh` | Core utilities |
| State Loader | `.aether/utils/state-loader.sh` | State loading |
| File Lock | `.aether/utils/file-lock.sh` | Lock implementation |
| Error Handler | `.aether/utils/error-handler.sh` | Error handling |
| Atomic Write | `.aether/utils/atomic-write.sh` | Atomic writes |

---

## Document Metadata

| Property | Value |
|----------|-------|
| **Title** | Aether State Management - Comprehensive Technical Documentation |
| **Version** | 1.0 |
| **Date** | 2026-02-16 |
| **Author** | Oracle Caste Analysis |
| **Word Count** | ~15,000+ words |
| **Status** | Complete |

---

*End of Document*
