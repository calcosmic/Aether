---
phase: 05-state-context-restoration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .aether/utils/state-loader.sh
  - .aether/aether-utils.sh
  - .aether/data/COLONY_STATE.json
autonomous: true
must_haves:
  truths:
    - State loads with file lock protection
    - State validation runs on every load
    - Handoff detection works for pause/resume
    - Validation failures provide clear user feedback
  artifacts:
    - path: ".aether/utils/state-loader.sh"
      provides: "State loading with lock, validation, and handoff detection"
      exports: ["load_colony_state", "unload_colony_state"]
    - path: ".aether/aether-utils.sh"
      provides: "CLI subcommands for load-state and unload-state"
  key_links:
    - from: "state-loader.sh"
      to: "file-lock.sh"
      via: "source and acquire_lock/release_lock"
    - from: "state-loader.sh"
      to: "aether-utils.sh validate-state"
      via: "bash command execution"
---

<objective>
Create a state loading utility that acquires file lock, validates COLONY_STATE.json, detects handoff documents, and provides graceful error handling. This is the foundation for all state-dependent operations.

Purpose: Every ant command needs reliable state access with validation and concurrency protection.
Output: state-loader.sh with load_colony_state() and unload_colony_state() functions
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-state-context-restoration/05-CONTEXT.md
@.planning/phases/05-state-context-restoration/05-RESEARCH.md

# Existing utilities to leverage
@.aether/utils/file-lock.sh
@.aether/utils/error-handler.sh
@.aether/aether-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Create state-loader.sh with core loading functions</name>
  <files>.aether/utils/state-loader.sh</files>
  <action>
Create .aether/utils/state-loader.sh with the following functions:

1. load_colony_state() - Main loading function:
   - Check if COLONY_STATE.json exists (error if not)
   - Acquire file lock using acquire_lock from file-lock.sh
   - Run validate-state colony via aether-utils.sh
   - If validation fails: release lock, output error JSON, return 1
   - Read state into variable
   - Check for .aether/HANDOFF.md existence
   - If handoff exists, set HANDOFF_DETECTED=true and HANDOFF_CONTENT variable
   - Export LOADED_STATE, STATE_LOCK_ACQUIRED=true
   - Return 0 on success

2. unload_colony_state() - Cleanup function:
   - Check if STATE_LOCK_ACQUIRED is true
   - Call release_lock if needed
   - Unset STATE_LOCK_ACQUIRED

3. get_handoff_summary() - Extract brief summary from handoff:
   - Parse HANDOFF.md for Phase line
   - Return "Phase X - Name" format for display

4. display_resumption_context() - Show brief resume message:
   - If handoff detected, output: "ðŸ”„ Resuming: Phase X - Name"
   - Remove handoff file after successful display

Include proper error handling with json_err from error-handler.sh. Follow patterns from RESEARCH.md bash example. Use trap to ensure lock release on exit.
  </action>
  <verify>
    bash -c 'source .aether/utils/state-loader.sh && type load_colony_state && type unload_colony_state'
  </verify>
  <done>
    state-loader.sh exists with load_colony_state and unload_colony_state functions that can be sourced
  </done>
</task>

<task type="auto">
  <name>Add load-state subcommand to aether-utils.sh</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Add `load-state` and `unload-state` subcommands to aether-utils.sh that wire the state-loader.sh module to the CLI:

```bash
load-state)
  source "$SCRIPT_DIR/utils/state-loader.sh" 2>/dev/null || {
    json_err "$E_FILE_NOT_FOUND" "state-loader.sh not found"
    exit 1
  }
  load_colony_state
  ;;

unload-state)
  source "$SCRIPT_DIR/utils/state-loader.sh" 2>/dev/null || {
    json_err "$E_FILE_NOT_FOUND" "state-loader.sh not found"
    exit 1
  }
  unload_colony_state
  ;;
```

Update the help/usage section to include these new commands.
  </action>
  <verify>
    bash .aether/aether-utils.sh load-state >/dev/null 2>&1 && echo "load-state subcommand works"
  </verify>
  <done>load-state and unload-state subcommands added to aether-utils.sh</done>
</task>

<task type="auto">
  <name>Add state loading integration test</name>
  <files>tests/unit/state-loader.test.js</files>
  <action>
Create tests/unit/state-loader.test.js that tests:

1. State loading succeeds with valid COLONY_STATE.json:
   - Source state-loader.sh
   - Call load_colony_state
   - Verify LOADED_STATE is set
   - Verify STATE_LOCK_ACQUIRED=true
   - Call unload_colony_state
   - Verify lock released

2. State loading fails when COLONY_STATE.json missing:
   - Temporarily rename file
   - Verify load_colony_state returns non-zero
   - Verify error JSON output
   - Restore file

3. State loading detects handoff:
   - Create test HANDOFF.md
   - Load state
   - Verify HANDOFF_DETECTED=true
   - Verify handoff content available
   - Cleanup test handoff

4. Validation failure handling:
   - Create invalid JSON temporarily
   - Verify load fails with validation error
   - Verify lock is released (not stuck)
   - Restore valid state

Use test patterns from colony-state.test.js. Use child_process.execSync to call bash functions.
  </action>
  <verify>
    npm test -- tests/unit/state-loader.test.js
  </verify>
  <done>
    Tests pass covering load success, missing file, handoff detection, and validation failure
  </done>
</task>

</tasks>

<verification>
- state-loader.sh can be sourced without errors
- load_colony_state acquires lock and loads valid state
- unload_colony_state releases lock properly
- Handoff detection works when HANDOFF.md exists
- Tests verify all major code paths
</verification>

<success_criteria>
- State loader utility exists and is testable
- Lock acquisition/release works correctly
- Validation runs on every load
- Handoff detection implemented
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-state-context-restoration/05-01-SUMMARY.md`
</output>
