---
phase: 06-foundation-safe-checkpoints-testing-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/cli.js
  - .aether/checkpoints/.gitkeep
autonomous: true

must_haves:
  truths:
    - User can run `aether checkpoint create` to create a safe checkpoint
    - Checkpoint only captures allowlisted files (never user data)
    - Checkpoint metadata includes SHA-256 hashes for integrity
    - User can list checkpoints with `aether checkpoint list`
    - User can restore a checkpoint with `aether checkpoint restore <id>`
  artifacts:
    - path: "bin/cli.js"
      provides: "checkpoint command implementation"
      contains: ["checkpoint", "createCheckpoint", "listCheckpoints", "restoreCheckpoint"]
    - path: ".aether/checkpoints/"
      provides: "Checkpoint metadata storage directory"
  key_links:
    - from: "checkpoint command"
      to: "CHECKPOINT_ALLOWLIST"
      via: "getAllowlistedFiles() function"
    - from: "checkpoint metadata"
      to: "hashFileSync()"
      via: "SHA-256 hash generation"
---

<objective>
Implement safe checkpoint system in CLI that only captures Aether-managed files using explicit allowlist, with metadata including file hashes.

Purpose: Prevent data loss by ensuring checkpoints never capture user data (TO-DOs.md, .aether/data/, etc.) while providing rollback capability for Aether system files.
Output: New `aether checkpoint` command with create, list, restore, and verify subcommands.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/06-foundation-safe-checkpoints-testing-infrastructure/06-RESEARCH.md
@/Users/callumcowie/repos/Aether/bin/cli.js
</context>

<tasks>

<task type="auto">
  <name>Create checkpoint utility functions</name>
  <files>bin/cli.js</files>
  <action>
    First, verify the existing functions exist in bin/cli.js:
    - hashFileSync(filePath) - should return 'sha256:...' or null
    - writeJsonSync(filePath, data) - writes JSON with indentation
    - generateManifest(hubDir) - returns { generated_at, files }

    If any are missing, report the missing function before proceeding.

    Then add the following checkpoint-related functions to bin/cli.js (before the command definitions, after the existing utility functions):

    1. Define CHECKPOINT_ALLOWLIST constant (exact paths from SAFE-02 requirement):
       ```javascript
       // Checkpoint allowlist - only these files are captured in checkpoints
       // NEVER include: data/, dreams/, oracle/, TO-DOs.md (user data)
       const CHECKPOINT_ALLOWLIST = [
         '.aether/*.md',                    // All .md files directly in .aether/
         '.claude/commands/ant/**',         // All files in .claude/commands/ant/ recursively
         '.opencode/commands/ant/**',       // All files in .opencode/commands/ant/ recursively
         '.opencode/agents/**',             // All files in .opencode/agents/ recursively
         'runtime/**',                      // All files in runtime/ recursively
         'bin/cli.js',                      // Specific file: bin/cli.js
       ];
       ```

    2. `getAllowlistedFiles(repoPath)` - Returns array of files matching CHECKPOINT_ALLOWLIST:
       - Use glob matching to find files matching each pattern in CHECKPOINT_ALLOWLIST
       - For '.aether/*.md': use fs.readdirSync to find .md files in .aether/ (not subdirs)
       - For '**' patterns: recursively walk directories
       - Return array of file paths relative to repo root
       - Filter out any files that match user data patterns (data/, dreams/, oracle/, TO-DOs.md)

    3. `isUserData(filePath)` - Returns true if file is user data that should never be checkpointed:
       - Check against forbidden patterns: data/, dreams/, oracle/, TO-DOs.md
       - Return true if any pattern matches

    4. `generateCheckpointMetadata(repoPath, message)` - Creates checkpoint metadata object:
       - Generate unique checkpoint ID: `chk_YYYYMMDD_HHMMSS`
       - Get allowlisted files using getAllowlistedFiles
       - For each file, compute SHA-256 hash using hashFileSync
       - Return object with:
         ```javascript
         {
           checkpoint_id: 'chk_YYYYMMDD_HHMMSS',
           created_at: '2025-01-15T10:30:00.000Z',
           message: message || 'Checkpoint created',
           files: {
             '.aether/coding-standards.md': 'sha256:abc123...',
             'bin/cli.js': 'sha256:def456...'
           },
           excluded: []  // Any files that were in allowlist but excluded as user data
         }
         ```

    5. `saveCheckpointMetadata(repoPath, metadata)` - Saves metadata to .aether/checkpoints/:
       - Ensure .aether/checkpoints/ directory exists
       - Write JSON file: .aether/checkpoints/{checkpoint_id}.json using writeJsonSync

    6. `loadCheckpointMetadata(repoPath, checkpointId)` - Loads checkpoint metadata by ID:
       - Read from .aether/checkpoints/{checkpoint_id}.json
       - Return parsed metadata or null if not found

    Follow the patterns from existing functions like generateManifest and hashFileSync.
  </action>
  <verify>grep -n "CHECKPOINT_ALLOWLIST\|getAllowlistedFiles\|isUserData\|generateCheckpointMetadata" bin/cli.js | head -15</verify>
  <done>CHECKPOINT_ALLOWLIST constant and all 5 checkpoint utility functions added to bin/cli.js</done>
</task>

<task type="auto">
  <name>Create checkpoint directory and implement checkpoint command</name>
  <files>.aether/checkpoints/.gitkeep, bin/cli.js</files>
  <action>
    1. Create .aether/checkpoints/ directory with .gitkeep file to ensure it exists in repo

    2. Add the `checkpoint` command to bin/cli.js CLI (after the `uninstall` command):

       ```javascript
       program
         .command('checkpoint')
         .description('Manage Aether checkpoints (safe snapshots of system files)')
         .addCommand(
           program.createCommand('create')
             .description('Create a new checkpoint of Aether system files')
             .argument('[message]', 'optional message describing the checkpoint')
             .action(wrapCommand(async (message) => {
               const repoPath = process.cwd();

               // 1. Check if in git repo
               if (!isGitRepo(repoPath)) {
                 console.error(c.error('Error: Not in a git repository'));
                 process.exit(1);
               }

               // 2. Get allowlisted files using CHECKPOINT_ALLOWLIST
               const allowlistedFiles = getAllowlistedFiles(repoPath);
               if (allowlistedFiles.length === 0) {
                 console.log(c.warning('No allowlisted files found to checkpoint'));
                 return;
               }

               // 3. Verify no user data in allowlist (safety check)
               const userDataFiles = allowlistedFiles.filter(f => isUserData(f));
               if (userDataFiles.length > 0) {
                 console.error(c.error('Safety check failed: user data detected in allowlist:'));
                 for (const f of userDataFiles) console.error(`  - ${f}`);
                 process.exit(1);
               }

               // 4. Generate checkpoint metadata with hashes
               const metadata = generateCheckpointMetadata(repoPath, message);

               // 5. Create git stash with allowlisted files
               // Command format: git stash push -m "aether-checkpoint-{timestamp}" -- {files}
               const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
               const stashMessage = `aether-checkpoint-${timestamp}`;
               const fileArgs = allowlistedFiles.map(f => `"${f}"`).join(' ');

               try {
                 execSync(`git stash push -m "${stashMessage}" -- ${fileArgs}`, {
                   cwd: repoPath,
                   stdio: 'pipe'
                 });
               } catch (err) {
                 console.error(c.error(`Failed to create git stash: ${err.message}`));
                 process.exit(1);
               }

               // 6. Save metadata to .aether/checkpoints/
               saveCheckpointMetadata(repoPath, metadata);

               // 7. Output success with checkpoint ID
               console.log(c.success(`Checkpoint created: ${metadata.checkpoint_id}`));
               console.log(`  Files: ${Object.keys(metadata.files).length}`);
               console.log(`  Stash: ${stashMessage}`);
               if (message) console.log(`  Message: ${message}`);
             }))
         )
         .addCommand(
           program.createCommand('list')
             .description('List all checkpoints')
             .action(wrapCommand(async () => {
               const repoPath = process.cwd();
               const checkpointsDir = path.join(repoPath, '.aether', 'checkpoints');

               if (!fs.existsSync(checkpointsDir)) {
                 console.log(c.info('No checkpoints found'));
                 return;
               }

               const files = fs.readdirSync(checkpointsDir)
                 .filter(f => f.endsWith('.json'))
                 .sort();

               if (files.length === 0) {
                 console.log(c.info('No checkpoints found'));
                 return;
               }

               console.log(c.header('Checkpoints:'));
               for (const file of files) {
                 const metadata = loadCheckpointMetadata(repoPath, file.replace('.json', ''));
                 if (metadata) {
                   const fileCount = Object.keys(metadata.files).length;
                   const date = new Date(metadata.created_at).toLocaleString();
                   console.log(`  ${metadata.checkpoint_id}  ${date}  ${fileCount} files  ${metadata.message || ''}`);
                 }
               }
             }))
         )
         .addCommand(
           program.createCommand('restore')
             .description('Restore Aether files from a checkpoint')
             .argument('<checkpoint-id>', 'checkpoint ID to restore from')
             .action(wrapCommand(async (checkpointId) => {
               const repoPath = process.cwd();

               // 1. Load checkpoint metadata
               const metadata = loadCheckpointMetadata(repoPath, checkpointId);
               if (!metadata) {
                 console.error(c.error(`Checkpoint not found: ${checkpointId}`));
                 process.exit(1);
               }

               // 2. Verify metadata integrity (hashes match current files if they exist)
               let integrityCheck = true;
               for (const [filePath, storedHash] of Object.entries(metadata.files)) {
                 const fullPath = path.join(repoPath, filePath);
                 if (fs.existsSync(fullPath)) {
                   const currentHash = hashFileSync(fullPath);
                   if (currentHash !== storedHash) {
                     console.warn(c.warning(`File changed since checkpoint: ${filePath}`));
                     integrityCheck = false;
                   }
                 }
               }

               // 3. Use git stash to restore files
               // Find stash by message pattern
               try {
                 const stashList = execSync('git stash list', { cwd: repoPath, encoding: 'utf8' });
                 const stashMatch = stashList.match(/stash@\{([^}]+)\}.*aether-checkpoint-/);
                 if (stashMatch) {
                   execSync(`git stash pop stash@{${stashMatch[1]}}`, {
                     cwd: repoPath,
                     stdio: 'pipe'
                   });
                   console.log(c.success(`Restored from checkpoint: ${checkpointId}`));
                   console.log(`  Files restored: ${Object.keys(metadata.files).length}`);
                 } else {
                   console.error(c.error('Could not find matching git stash'));
                   process.exit(1);
                 }
               } catch (err) {
                 console.error(c.error(`Failed to restore checkpoint: ${err.message}`));
                 process.exit(1);
               }
             }))
         )
         .addCommand(
           program.createCommand('verify')
             .description('Verify checkpoint integrity')
             .argument('<checkpoint-id>', 'checkpoint ID to verify')
             .action(wrapCommand(async (checkpointId) => {
               const repoPath = process.cwd();

               // 1. Load checkpoint metadata
               const metadata = loadCheckpointMetadata(repoPath, checkpointId);
               if (!metadata) {
                 console.error(c.error(`Checkpoint not found: ${checkpointId}`));
                 process.exit(1);
               }

               // 2. Re-compute hashes for all files in metadata
               // 3. Compare with stored hashes
               let passed = 0;
               let failed = 0;
               let missing = 0;

               for (const [filePath, storedHash] of Object.entries(metadata.files)) {
                 const fullPath = path.join(repoPath, filePath);
                 if (!fs.existsSync(fullPath)) {
                   console.log(c.error(`  MISSING: ${filePath}`));
                   missing++;
                 } else {
                   const currentHash = hashFileSync(fullPath);
                   if (currentHash === storedHash) {
                     console.log(c.success(`  OK: ${filePath}`));
                     passed++;
                   } else {
                     console.log(c.error(`  MISMATCH: ${filePath}`));
                     failed++;
                   }
                 }
               }

               // 4. Report any mismatches
               console.log('');
               if (failed === 0 && missing === 0) {
                 console.log(c.success(`All ${passed} files verified successfully`));
               } else {
                 console.log(c.warning(`Verification complete: ${passed} passed, ${failed} mismatched, ${missing} missing`));
                 process.exit(1);
               }
             }))
         );
       ```

    Follow the existing command patterns (install, update, version, uninstall).
    Use wrapCommand for consistent error handling.
    Use c.header(), c.success(), c.warning(), c.error() for colored output.
  </action>
  <verify>grep -n "program.command('checkpoint')" bin/cli.js</verify>
  <done>checkpoint command with create/list/restore/verify subcommands added to CLI</done>
</task>

</tasks>

<verification>
- [ ] .aether/checkpoints/ directory exists with .gitkeep
- [ ] `aether checkpoint --help` shows available subcommands
- [ ] `aether checkpoint create` creates a checkpoint with metadata
- [ ] Checkpoint metadata includes file hashes
- [ ] User data (data/, dreams/, oracle/) is never included in checkpoints
</verification>

<success_criteria>
- CHECKPOINT_ALLOWLIST constant exists with exact SAFE-02 paths
- Checkpoint utility functions exist in bin/cli.js
- `aether checkpoint create` creates checkpoints with metadata
- `aether checkpoint list` displays all checkpoints
- `aether checkpoint restore <id>` restores from checkpoint
- `aether checkpoint verify <id>` verifies integrity
- Checkpoints only include allowlisted files (CHECKPOINT_ALLOWLIST)
- User data directories are explicitly excluded
</success_criteria>

<output>
After completion, create `.planning/phases/06-foundation-safe-checkpoints-testing-infrastructure/06-02-SUMMARY.md`
</output>
