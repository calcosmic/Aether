---
phase: 09-caste-model-assignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - bin/lib/model-profiles.js
autonomous: true
must_haves:
  truths:
    - js-yaml package is installed and importable
    - Model profiles library can read model-profiles.yaml
    - Model profiles library can validate caste and model names
  artifacts:
    - path: package.json
      provides: "js-yaml dependency added"
      contains: "js-yaml"
    - path: bin/lib/model-profiles.js
      provides: "Model profile utilities"
      exports: ["loadModelProfiles", "getModelForCaste", "validateCaste", "validateModel", "getProviderForModel"]
  key_links:
    - from: bin/lib/model-profiles.js
      to: .aether/model-profiles.yaml
      via: "fs.readFileSync + yaml.load"
      pattern: "yaml.load.*model-profiles.yaml"
---

<objective>
Add js-yaml dependency and create model profile library for reading and validating caste-to-model assignments from model-profiles.yaml.

Purpose: Foundation for all model routing features - provides reliable YAML parsing and profile access.
Output: Working model-profiles.js library with full test coverage.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-caste-model-assignment/09-RESEARCH.md
@/Users/callumcowie/repos/Aether/.aether/model-profiles.yaml
@/Users/callumcowie/repos/Aether/package.json
</context>

<tasks>

<task type="auto">
  <name>Add js-yaml dependency to package.json</name>
  <files>package.json</files>
  <action>
    Add "js-yaml": "^4.1.0" to the dependencies section of package.json.
    Keep existing dependencies (commander, picocolors) intact.
    Ensure proper JSON formatting with commas.
  </action>
  <verify>cat package.json | grep -A5 '"dependencies"' | grep 'js-yaml'</verify>
  <done>js-yaml ^4.1.0 appears in dependencies section</done>
</task>

<task type="auto">
  <name>Create model-profiles.js library</name>
  <files>bin/lib/model-profiles.js</files>
  <action>
    Create bin/lib/model-profiles.js with the following exports:

    1. loadModelProfiles(repoPath) - Reads and parses .aether/model-profiles.yaml
       - Returns full parsed YAML object
       - Throws ConfigurationError if file not found or invalid

    2. getModelForCaste(profiles, caste) - Returns model for given caste
       - Looks up in profiles.worker_models[caste]
       - Returns default (kimi-k2.5) if caste not found
       - Logs warning when using default

    3. validateCaste(profiles, caste) - Returns {valid: boolean, castes: string[]}
       - valid: true if caste exists in worker_models
       - castes: array of valid caste names

    4. validateModel(profiles, model) - Returns {valid: boolean, models: string[]}
       - valid: true if model exists in model_metadata
       - models: array of valid model names

    5. getProviderForModel(profiles, model) - Returns provider string
       - Looks up in profiles.model_metadata[model].provider
       - Returns null if not found

    6. getAllAssignments(profiles) - Returns array of {caste, model, provider} objects
       - For each caste in worker_models
       - Includes provider lookup from model_metadata

    Use js-yaml for parsing. Handle errors gracefully with descriptive messages.
    Follow the error handling patterns from bin/lib/errors.js.
  </action>
  <verify>node -e "const mp = require('./bin/lib/model-profiles'); console.log(Object.keys(mp))"</verify>
  <done>Library exports all 6 functions and loads without errors</done>
</task>

<task type="auto">
  <name>Create unit tests for model-profiles.js</name>
  <files>tests/unit/model-profiles.test.js</files>
  <action>
    Create comprehensive unit tests for model-profiles.js:

    1. loadModelProfiles tests:
       - Successfully loads valid YAML
       - Throws ConfigurationError for missing file
       - Throws ConfigurationError for invalid YAML

    2. getModelForCaste tests:
       - Returns correct model for known castes (builder, watcher, etc.)
       - Returns default for unknown caste
       - Handles null/undefined profiles gracefully

    3. validateCaste tests:
       - Returns valid=true for known castes
       - Returns valid=false for unknown castes
       - Returns complete list of valid castes

    4. validateModel tests:
       - Returns valid=true for known models (glm-5, kimi-k2.5, minimax-2.5)
       - Returns valid=false for unknown models
       - Returns complete list of valid models

    5. getProviderForModel tests:
       - Returns correct provider for each model
       - Returns null for unknown model

    6. getAllAssignments tests:
       - Returns array with all castes
       - Each entry has caste, model, provider fields

    Use existing test patterns from tests/unit/*.test.js files.
    Mock fs for file system tests.
  </action>
  <verify>npm run test:unit -- tests/unit/model-profiles.test.js</verify>
  <done>All 6 test suites pass with 100% function coverage</done>
</task>

</tasks>

<verification>
- npm install completes without errors
- node -e "require('./bin/lib/model-profiles')" loads successfully
- npm run test:unit -- tests/unit/model-profiles.test.js passes
- All 6 exported functions are callable
</verification>

<success_criteria>
1. js-yaml is listed in package.json dependencies
2. bin/lib/model-profiles.js exists and exports 6 functions
3. Unit tests exist and pass
4. Library can read and parse .aether/model-profiles.yaml correctly
5. All caste/model validations work as expected
</success_criteria>

<output>
After completion, create `.planning/phases/09-caste-model-assignment/09-01-SUMMARY.md`
</output>
