---
phase: 07-core-reliability-state-guards-update-system
plan: 06
type: execute
wave: 3
depends_on: ["07-03", "07-05"]
files_modified:
  - bin/lib/init.js
  - bin/cli.js
  - tests/unit/init.test.js
  - tests/integration/state-guard-integration.test.js
  - tests/e2e/update-rollback.test.js
autonomous: false

must_haves:
  truths:
    - New repo initialization creates COLONY_STATE.json locally
    - Initialization creates required local files (.aether/, codebase docs)
    - State guards work for both new and existing repos
    - End-to-end update with rollback is tested
    - User can verify initialization worked correctly
    - COLONY_STATE.json syncs with .planning/STATE.md (no split brain)
    - Model routing is verified to be active (ANTHROPIC_MODEL set per caste)
  artifacts:
    - path: "bin/lib/init.js"
      provides: "Repo initialization with local state"
      exports: ["initializeRepo", "isInitialized"]
      min_lines: 150
    - path: "bin/lib/state-sync.js"
      provides: "State synchronization between planning and runtime"
      exports: ["syncStateFromPlanning", "reconcileStates"]
      min_lines: 100
    - path: "bin/cli.js"
      provides: "Init command integrated"
      modifies: ["init command"]
    - path: "tests/unit/init.test.js"
      provides: "Initialization unit tests"
      min_tests: 6
    - path: "tests/integration/state-guard-integration.test.js"
      provides: "Integration tests for state guards"
      min_tests: 4
    - path: "tests/e2e/update-rollback.test.js"
      provides: "E2E test for update with rollback"
  key_links:
    - from: "initializeRepo()"
      to: "COLONY_STATE.json"
      via: "local state file creation"
    - from: "isInitialized()"
      to: "fs.existsSync('.aether/data/COLONY_STATE.json')"
      via: "initialization check"
    - from: "syncStateFromPlanning()"
      to: ".planning/STATE.md"
      via: "parses markdown state"
    - from: "reconcileStates()"
      to: "COLONY_STATE.json"
      via: "updates runtime state"
---

<objective>
Ensure proper initialization for new repos (creating local state files) and create integration tests for the complete state guard and update system.

Purpose: Support both updating existing Aether repos and initializing new repos with Aether; verify all components work together.
Output: Init module, integration tests, and E2E test for update with rollback.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-core-reliability-state-guards-update-system/07-RESEARCH.md
@.aether/data/COLONY_STATE.json
@bin/cli.js
@bin/lib/state-guard.js
@bin/lib/update-transaction.js
</context>

<tasks>

<task type="auto">
  <name>Create initialization module for new repos</name>
  <files>bin/lib/init.js</files>
  <action>
Create bin/lib/init.js for repo initialization (handles new repos):

1. isInitialized(repoPath) function:
   - Check if .aether/data/COLONY_STATE.json exists
   - Check if required directories exist
   - Return boolean

2. initializeRepo(repoPath, options = {}) function:
   - Options: { goal, version, skipIfExists }
   - Create directory structure:
     - .aether/
     - .aether/data/
     - .aether/checkpoints/
     - .aether/locks/
   - Create COLONY_STATE.json with:
     ```json
     {
       "version": "3.0",
       "goal": options.goal || "Aether colony initialization",
       "state": "INITIALIZING",
       "current_phase": 0,
       "session_id": "session_{timestamp}_{random}",
       "initialized_at": "ISO 8601 timestamp",
       "build_started_at": null,
       "plan": { "generated_at": null, "confidence": null, "phases": [] },
       "memory": { "phase_learnings": [], "decisions": [], "instincts": [] },
       "errors": { "records": [], "flagged_patterns": [] },
       "signals": [],
       "graveyards": [],
       "events": [
         {
           "timestamp": "ISO 8601",
           "type": "colony_initialized",
           "worker": "init",
           "details": "Colony initialized with goal: {goal}"
         }
       ],
       "created_at": "ISO 8601",
       "last_updated": "ISO 8601"
     }
     ```
   - Create placeholder files:
     - .aether/.gitignore (ignore data/, checkpoints/, locks/)
   - Return { success: true, stateFile: path }

3. validateInitialization(repoPath) function:
   - Verify all required files exist
   - Verify COLONY_STATE.json is valid JSON
   - Verify required fields present
   - Return { valid: boolean, errors: string[] }

4. createInitialState(goal) helper:
   - Generate new state object
   - Create session ID
   - Set timestamps

5. Export: module.exports = { initializeRepo, isInitialized, validateInitialization };

This ensures new repos get local state files, not looking for global stuff.
  </action>
  <verify>node -e "const init = require('./bin/lib/init.js'); console.log('Exports:', typeof init.initializeRepo, typeof init.isInitialized)"</verify>
  <done>Init module created with local state file generation</done>
</task>

<task type="auto">
  <name>Integrate init command into CLI</name>
  <files>bin/cli.js</files>
  <action>
Modify bin/cli.js to add/refine the init command:

1. Import init module:
   - const { initializeRepo, isInitialized } = require('./lib/init');

2. Add or update init command:
   ```javascript
   program
     .command('init')
     .description('Initialize Aether in current repository')
     .option('-g, --goal <goal>', 'Initial colony goal', 'Aether colony')
     .option('-f, --force', 'Reinitialize even if already initialized')
     .action(wrapCommand(async (options) => {
       const repoPath = process.cwd();

       // Check if already initialized
       if (isInitialized(repoPath) && !options.force) {
         console.log('Aether is already initialized in this repository.');
         console.log('Use --force to reinitialize (WARNING: may overwrite state).');
         return;
       }

       // Initialize
       const result = await initializeRepo(repoPath, {
         goal: options.goal,
         skipIfExists: !options.force
       });

       if (result.success) {
         console.log('Aether initialized successfully!');
         console.log(`State file: ${result.stateFile}`);
         console.log('');
         console.log('Next steps:');
         console.log('  1. Define your colony goal in .aether/data/COLONY_STATE.json');
         console.log('  2. Run: aether status');
         console.log('  3. Start building: /ant:init');
       }
     }));
   ```

3. Update other commands to check initialization:
   - Add initialization check to update, checkpoint, status commands
   - If not initialized, show helpful error with init command

4. Ensure init creates local files only:
   - No global state references
   - All files in repo-local .aether/ directory

Test the init command in a temp directory to verify it works.
  </action>
  <verify>cd /tmp && mkdir -p test-init && cd test-init && git init && node /Users/callumcowie/repos/Aether/bin/cli.js init --goal "Test colony" && cat .aether/data/COLONY_STATE.json | head -10</verify>
  <done>Init command integrated and tested</done>
</task>

<task type="auto">
  <name>Create unit tests for initialization</name>
  <files>tests/unit/init.test.js</files>
  <action>
Create tests/unit/init.test.js for initialization testing:

1. Test setup:
   - Mock fs module
   - Load init module via proxyquire
   - Create temp directory path for tests

2. Test: initializeRepo creates directory structure
   - Call: initializeRepo('/test/repo', { goal: 'Test' })
   - Assert: mkdirSync called for .aether/data, .aether/checkpoints, .aether/locks

3. Test: initializeRepo creates COLONY_STATE.json
   - Call: initializeRepo('/test/repo', { goal: 'Test goal' })
   - Assert: writeFileSync called with COLONY_STATE.json path
   - Assert: written content is valid JSON
   - Assert: state.goal === 'Test goal'
   - Assert: state.current_phase === 0
   - Assert: state.events has colony_initialized event

4. Test: isInitialized returns true when state exists
   - Setup: existsSync returns true for COLONY_STATE.json
   - Assert: isInitialized('/test/repo') === true

5. Test: isInitialized returns false when state missing
   - Setup: existsSync returns false
   - Assert: isInitialized('/test/repo') === false

6. Test: validateInitialization checks all requirements
   - Setup: valid state file
   - Assert: validateInitialization returns valid: true
   - Setup: missing required field
   - Assert: validateInitialization returns valid: false with errors

7. Test: initializeRepo respects skipIfExists
   - Setup: isInitialized returns true
   - Call: initializeRepo with skipIfExists: true
   - Assert: no files written, returns early

Use test.serial() for all tests.
  </action>
  <verify>npm test -- tests/unit/init.test.js</verify>
  <done>All 6+ initialization tests pass</done>
</task>

<task type="auto">
  <name>Create integration tests for state guards</name>
  <files>tests/integration/state-guard-integration.test.js</files>
  <action>
Create tests/integration/state-guard-integration.test.js:

1. Test setup:
   - Use real filesystem in temp directory (not mocks)
   - Create temp dir with .aether structure
   - Initialize real COLONY_STATE.json
   - Load real StateGuard and FileLock

2. Test: complete phase advancement flow
   - Initialize repo at phase 0
   - Create StateGuard
   - Advance to phase 1 with valid evidence
   - Assert: state updated to phase 1
   - Assert: event recorded
   - Assert: lock released

3. Test: concurrent access is serialized
   - Start two simultaneous advancePhase calls
   - Assert: one succeeds, one waits or fails gracefully
   - Assert: final state is consistent (no corruption)

4. Test: Iron Law prevents advancement without evidence
   - Initialize repo at phase 0
   - Attempt advance without evidence
   - Assert: throws E_IRON_LAW_VIOLATION
   - Assert: state unchanged

5. Test: checkpoint → update → verify flow
   - Create checkpoint
   - Run update (dry-run)
   - Verify checkpoint exists
   - Assert: all components integrate correctly

6. Test: idempotency across multiple calls
   - Advance to phase 2
   - Attempt to advance phase 1→2 again
   - Assert: returns already_complete
   - Assert: no duplicate events

Use test.serial() due to filesystem operations.
Clean up temp directories after each test.
  </action>
  <verify>npm test -- tests/integration/state-guard-integration.test.js</verify>
  <done>All 4+ integration tests pass</done>
</task>

<task type="auto">
  <name>Create state synchronization module</name>
  <files>bin/lib/state-sync.js</files>
  <action>
Create bin/lib/state-sync.js to fix the "split brain" between .planning/STATE.md and COLONY_STATE.json:

1. parseStateMd(content) function:
   - Parse STATE.md markdown
   - Extract: current phase, milestone, status, last action
   - Return structured object: { phase, milestone, status, lastAction }

2. syncStateFromPlanning(repoPath) function:
   - Read .planning/STATE.md
   - Parse current state using parseStateMd()
   - Read .aether/data/COLONY_STATE.json
   - Update COLONY_STATE.json with:
     - goal: from STATE.md milestone
     - state: "BUILDING" if Phase 7 in progress
     - current_phase: from STATE.md
     - Add phases from .planning/ROADMAP.md to plan.phases
   - Add event: "state_synced_from_planning"
   - Return { synced: true, updates: [...] }

3. reconcileStates(repoPath) function:
   - Compare STATE.md and COLONY_STATE.json
   - Detect mismatches:
     - Phase numbers differ
     - Goals differ
     - Status contradicts (e.g., "ready for Phase 7" vs "COMPLETED")
   - Return { consistent: boolean, mismatches: [...], resolution: "action needed" }

4. updateColonyStateFromPlanning(repoPath) function:
   - Full sync: read STATE.md → update COLONY_STATE.json
   - Update these fields:
     - goal: from STATE.md milestone
     - current_phase: parsed from "Phase X"
     - state: "INITIALIZING"|"PLANNING"|"BUILDING"|"COMPLETED" based on status
     - plan.phases: from ROADMAP.md phases
     - Add sync event to events array

5. Export: module.exports = { syncStateFromPlanning, reconcileStates, parseStateMd };

This fixes the dream-identified issue where STATE.md says "Phase 6 complete, ready for 7" but COLONY_STATE.json says "COMPLETED" with no phases.
  </action>
  <verify>node -e "const sync = require('./bin/lib/state-sync.js'); console.log('Exports:', typeof sync.syncStateFromPlanning, typeof sync.reconcileStates)"</verify>
  <done>State sync module created with planning → runtime state sync</done>
</task>

<task type="auto">
  <name>Add sync command to CLI and run initial sync</name>
  <files>bin/cli.js</files>
  <action>
Extend bin/cli.js with state synchronization:

1. Import state-sync module:
   - const { syncStateFromPlanning, reconcileStates } = require('./lib/state-sync');

2. Add sync-state command:
   ```javascript
   program
     .command('sync-state')
     .description('Synchronize COLONY_STATE.json with .planning/STATE.md')
     .option('-d, --dry-run', 'Show what would change without applying')
     .action(wrapCommand(async (options) => {
       const repoPath = process.cwd();

       if (!isInitialized(repoPath)) {
         console.error('Aether not initialized. Run: aether init');
         return;
       }

       // Check for mismatches
       const reconciliation = await reconcileStates(repoPath);
       if (!reconciliation.consistent) {
         console.log('State mismatch detected:');
         reconciliation.mismatches.forEach(m => console.log(`  - ${m}`));
         console.log('');
       }

       if (options.dryRun) {
         console.log('Dry run - no changes made');
         return;
       }

       // Perform sync
       const result = await syncStateFromPlanning(repoPath);
       if (result.synced) {
         console.log('State synchronized successfully');
         console.log('Updates:', result.updates.join(', '));
       }
     }));
   ```

3. Run initial sync for this repo:
   ```bash
   node bin/cli.js sync-state
   ```

4. Verify COLONY_STATE.json now matches STATE.md:
   - Goal should be "v1.1 Bug Fixes & Update System Repair"
   - current_phase should be 6
   - state should be "BUILDING" or "PLANNING"
   - plan.phases should have entries from ROADMAP

This ensures the runtime state matches the planning documents.
  </action>
  <verify>node bin/cli.js sync-state --dry-run && cat .aether/data/COLONY_STATE.json | grep -E '"goal"|"current_phase"|"state"' | head -5</verify>
  <done>Sync command added and initial sync completed</done>
</task>

<task type="auto">
  <name>Create model routing verification utility</name>
  <files>bin/lib/model-verify.js</files>
  <action>
Create bin/lib/model-verify.js to verify model routing is actually working:

1. checkLiteLLMProxy() function:
   - Try to connect to http://localhost:4000/health
   - Return { running: boolean, latency: number }

2. verifyModelAssignment(caste) function:
   - Call: bash .aether/aether-utils.sh model-profile get {caste}
   - Parse JSON result
   - Return { assigned: boolean, model: string, via: "profile|default" }

3. checkAntrhopicModelEnv() function:
   - Check process.env.ANTHROPIC_MODEL
   - Check process.env.ANTHROPIC_BASE_URL
   - Return { model: string|null, baseUrl: string|null, routingActive: boolean }

4. verifyWorkerSpawnEnv() function:
   - Simulate what build.md does before spawning workers
   - Check that ANTHROPIC_MODEL would be set correctly
   - Return { wouldRoute: boolean, model: string, issues: [...] }

5. createVerificationReport() function:
   - Run all checks above
   - Return structured report:
     ```javascript
     {
       proxy: { running: boolean, latency: number },
       env: { model: string, baseUrl: string },
       castes: {
         prime: { model: "glm-5", assigned: true },
         builder: { model: "kimi-k2.5", assigned: true },
         oracle: { model: "minimax-2.5", assigned: true }
       },
       issues: [...],
       recommendation: "string"
     }
     ```

6. Export: module.exports = { checkLiteLLMProxy, verifyModelAssignment, checkAntrhopicModelEnv, verifyWorkerSpawnEnv, createVerificationReport };

This addresses the dream concern: "configuration exists but execution isn't verified"
  </action>
  <verify>node -e "const mv = require('./bin/lib/model-verify.js'); console.log('Exports:', typeof mv.checkLiteLLMProxy, typeof mv.createVerificationReport)"</verify>
  <done>Model verification module created</done>
</task>

<task type="auto">
  <name>Add model-verify command to CLI</name>
  <files>bin/cli.js</files>
  <action>
Add model verification command to bin/cli.js:

1. Import model-verify module:
   - const { createVerificationReport } = require('./lib/model-verify');

2. Add verify-models command:
   ```javascript
   program
     .command('verify-models')
     .description('Verify model routing configuration is active')
   .action(wrapCommand(async () => {
       const report = await createVerificationReport();

       console.log('=== Model Routing Verification ===\n');

       // Proxy status
       console.log(`LiteLLM Proxy: ${report.proxy.running ? '✓ Running' : '✗ Not running'}`);
       if (report.proxy.running) {
         console.log(`  Latency: ${report.proxy.latency}ms`);
       }

       // Environment
       console.log(`\nEnvironment:`);
       console.log(`  ANTHROPIC_MODEL: ${report.env.model || '(not set)'}`);
       console.log(`  ANTHROPIC_BASE_URL: ${report.env.baseUrl || '(not set)'}`);

       // Caste assignments
       console.log(`\nCaste Model Assignments:`);
       for (const [caste, info] of Object.entries(report.castes)) {
         const status = info.assigned ? '✓' : '✗';
         console.log(`  ${status} ${caste}: ${info.model || 'default'}`);
       }

       // Issues
       if (report.issues.length > 0) {
         console.log(`\nIssues Found:`);
         report.issues.forEach(issue => console.log(`  ⚠ ${issue}`));
       }

       // Recommendation
       console.log(`\n${report.recommendation}`);
     }));
   ```

3. Test the command:
   ```bash
   node bin/cli.js verify-models
   ```

This verifies the dream-identified gap between "configuration exists" and "execution verified"
  </action>
  <verify>node bin/cli.js verify-models 2>&1 | head -20</verify>
  <done>Model verify command added and tested</done>
</task>

<task type="checkpoint:human-verify">
  <name>Verify E2E update with rollback</name>
  <what-built>
End-to-end test script at tests/e2e/update-rollback.test.js that verifies:
1. Update creates checkpoint before sync
2. Failed update automatically rolls back
3. Recovery commands are displayed
4. State remains consistent after rollback
  </what-built>
  <how-to-verify>
1. Run the E2E test:
   ```
   npm test -- tests/e2e/update-rollback.test.js
   ```

2. Manual verification (optional but recommended):
   ```
   # Create a test repo
   cd /tmp
   mkdir aether-e2e-test
   cd aether-e2e-test
   git init

   # Initialize Aether
   node /Users/callumcowie/repos/Aether/bin/cli.js init --goal "E2E test"

   # Create a checkpoint
   node /Users/callumcowie/repos/Aether/bin/cli.js checkpoint create "pre-e2e"

   # Check status
   node /Users/callumcowie/repos/Aether/bin/cli.js status

   # Cleanup
   cd /tmp
   rm -rf aether-e2e-test
   ```

3. Verify the test output shows:
   - Checkpoint created successfully
   - State file created locally (not global)
   - No errors during initialization
  </how-to-verify>
  <resume-signal>Type "approved" to continue or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- Init module creates local state files correctly
- Init command works in fresh repo
- All unit tests pass
- Integration tests pass
- E2E test verifies complete flow
</verification>

<success_criteria>
1. Init module creates repo-local COLONY_STATE.json
2. Init command integrated into CLI
3. State guards work for both new and existing repos
4. 6+ unit tests for initialization
5. 4+ integration tests for state guards
6. E2E test for update with rollback
7. State sync module fixes split brain (STATE.md ↔ COLONY_STATE.json)
8. COLONY_STATE.json updated with current v1.1 goal and phases
9. Model routing verification utility created
10. All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/07-core-reliability-state-guards-update-system/07-06-SUMMARY.md`
</output>
