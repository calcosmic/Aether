---
phase: 07-core-reliability-state-guards-update-system
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/file-lock.js
  - tests/unit/file-lock.test.js
autonomous: true

must_haves:
  truths:
    - FileLock class acquires exclusive locks atomically
    - Stale locks are detected and cleaned up automatically
    - Lock acquisition has timeout with retry logic
    - Lock release is guaranteed via cleanup handlers
  artifacts:
    - path: "bin/lib/file-lock.js"
      provides: "FileLock class with acquire/release methods"
      exports: ["FileLock"]
      min_lines: 150
    - path: "tests/unit/file-lock.test.js"
      provides: "Unit tests for FileLock class"
      min_tests: 8
  key_links:
    - from: "FileLock.acquire()"
      to: "fs.openSync with 'wx' flag"
      via: "atomic file creation"
    - from: "FileLock.release()"
      to: "fs.unlinkSync"
      via: "lock file cleanup"
    - from: "stale detection"
      to: "process.kill(pid, 0)"
      via: "PID existence check"
---

<objective>
Create a Node.js FileLock class that implements PID-based file locking with stale detection, extending the pattern from .aether/utils/file-lock.sh for use in the CLI.

Purpose: Enable safe concurrent access to COLONY_STATE.json by multiple processes, preventing race conditions during phase transitions.
Output: FileLock module in bin/lib/file-lock.js with comprehensive unit tests.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-core-reliability-state-guards-update-system/07-RESEARCH.md
@.aether/utils/file-lock.sh
@tests/unit/helpers/mock-fs.js
</context>

<tasks>

<task type="auto">
  <name>Create FileLock class in bin/lib/file-lock.js</name>
  <files>bin/lib/file-lock.js</files>
  <action>
Create bin/lib/file-lock.js implementing the FileLock class based on the pattern in .aether/utils/file-lock.sh:

1. Class constructor:
   - Accepts options: lockDir (default: '.aether/locks'), timeout (default: 5000ms), retryInterval (default: 50ms), maxRetries (default: 100)
   - Initialize state: currentLock = null, currentPidFile = null

2. acquire(filePath) method:
   - Generate lockFile path: \${lockDir}/\${path.basename(filePath)}.lock
   - Generate pidFile path: \${lockFile}.pid
   - Check for existing lock file
   - If exists, read PID from pidFile and check if process is running via process.kill(pid, 0)
   - If PID not running, clean up stale lock files (both .lock and .pid)
   - Attempt atomic lock creation using fs.openSync(lockFile, 'wx')
   - On success, write current PID to lockFile and pidFile
   - On EEXIST error, retry with backoff up to maxRetries
   - Return true on success, false on timeout

3. release() method:
   - If currentLock exists, delete lockFile and pidFile using fs.unlinkSync
   - Clear currentLock and currentPidFile state
   - Safe to call multiple times (idempotent)

4. isLocked(filePath) static method:
   - Check if lock file exists for given path
   - Return boolean

5. cleanup() method:
   - Internal method to clean up stale locks
   - Called automatically during acquire

6. Error handling:
   - Wrap fs operations in try/catch
   - Throw FileSystemError for unexpected fs errors (not EEXIST)

7. Export: module.exports = { FileLock };

Reference the bash implementation in file-lock.sh lines 30-66 for the stale lock detection pattern.
  </action>
  <verify>node -e "const {FileLock} = require('./bin/lib/file-lock.js'); console.log('FileLock loaded:', typeof FileLock)"</verify>
  <done>FileLock class exists with acquire(), release(), isLocked() methods and compiles without errors</done>
</task>

<task type="auto">
  <name>Create unit tests for FileLock class</name>
  <files>tests/unit/file-lock.test.js</files>
  <action>
Create tests/unit/file-lock.test.js with comprehensive tests using sinon + proxyquire pattern:

1. Test setup (beforeEach):
   - Create mockFs using helper pattern from tests/unit/helpers/mock-fs.js
   - Stub fs methods: existsSync, readFileSync, writeFileSync, openSync, closeSync, unlinkSync
   - Load FileLock via proxyquire with mocked fs
   - Reset stubs between tests

2. Test: acquire creates lock file atomically
   - existsSync returns false (no existing lock)
   - openSync returns file descriptor 1
   - Call fileLock.acquire('/test/state.json')
   - Assert openSync called with lock path and 'wx' flag
   - Assert writeFileSync called with PID

3. Test: acquire detects and cleans stale locks
   - existsSync returns true (lock exists)
   - readFileSync returns old PID "12345"
   - process.kill(12345, 0) throws (process not running)
   - openSync returns file descriptor 1
   - Call fileLock.acquire('/test/state.json')
   - Assert unlinkSync called for stale lock files
   - Assert new lock created

4. Test: acquire respects running process locks
   - existsSync returns true
   - readFileSync returns current process PID
   - process.kill succeeds (simulated via stub)
   - openSync throws EEXIST
   - Call fileLock.acquire('/test/state.json')
   - Assert returns false after retries exhausted

5. Test: release cleans up lock files
   - Acquire lock first (setup stubs)
   - Call fileLock.release()
   - Assert unlinkSync called for both .lock and .pid files
   - Assert currentLock cleared

6. Test: isLocked returns correct state
   - existsSync returns true
   - Assert FileLock.isLocked('/test/state.json') === true
   - existsSync returns false
   - Assert FileLock.isLocked('/test/state.json') === false

7. Test: handles fs errors gracefully
   - openSync throws non-EEXIST error (e.g., EACCES)
   - Assert throws FileSystemError with proper code

8. Test: multiple acquire calls are idempotent
   - Acquire lock
   - Release lock
   - Release lock again
   - Assert no errors, unlinkSync called only once per file

Use test.serial() to avoid commander.js conflicts (pattern from cli-sync.test.js).
  </action>
  <verify>npm test -- tests/unit/file-lock.test.js</verify>
  <done>All 8+ unit tests pass with mocked filesystem</done>
</task>

</tasks>

<verification>
- FileLock class loads without errors
- All unit tests pass (npm test -- tests/unit/file-lock.test.js)
- Test coverage includes: acquire, release, stale detection, error handling
</verification>

<success_criteria>
1. FileLock class exists in bin/lib/file-lock.js with full implementation
2. Unit tests exist in tests/unit/file-lock.test.js with 8+ test cases
3. All tests pass
4. Pattern matches existing file-lock.sh behavior
</success_criteria>

<output>
After completion, create `.planning/phases/07-core-reliability-state-guards-update-system/07-01-SUMMARY.md`
</output>
