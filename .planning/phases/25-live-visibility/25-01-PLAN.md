---
phase: 25-live-visibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .aether/aether-utils.sh
autonomous: true

must_haves:
  truths:
    - "activity-log subcommand appends timestamped structured lines to .aether/data/activity.log"
    - "activity-log-init subcommand archives previous log and creates fresh log with phase header"
    - "activity-log-read subcommand returns log content filtered by caste, as JSON-escaped string"
    - "help subcommand lists all three new subcommands"
  artifacts:
    - path: ".aether/aether-utils.sh"
      provides: "activity-log, activity-log-init, activity-log-read subcommands"
      contains: "activity-log)"
  key_links:
    - from: "activity-log subcommand"
      to: ".aether/data/activity.log"
      via: "echo append"
      pattern: "activity.log"
    - from: "activity-log-init subcommand"
      to: ".aether/data/activity.log"
      via: "archive + fresh write"
      pattern: "activity-phase-"
---

<objective>
Add activity log subcommands to aether-utils.sh so workers and the Queen can write, initialize, and read structured progress lines.

Purpose: VIS-01 requires workers to write structured progress to `.aether/data/activity.log`. The utility layer is the established place for deterministic file operations -- workers call subcommands, not raw file writes.

Output: Three new subcommands in aether-utils.sh: `activity-log`, `activity-log-init`, `activity-log-read`
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-live-visibility/25-RESEARCH.md
@.aether/aether-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add activity-log, activity-log-init, activity-log-read subcommands</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Read the current aether-utils.sh (229 lines, 13 subcommands). Add three new case branches BEFORE the catch-all `*)` case.

**1. `activity-log` subcommand** -- appends a structured progress line:
```bash
activity-log)
  action="${1:-}"
  caste="${2:-}"
  description="${3:-}"
  [[ -z "$action" || -z "$caste" || -z "$description" ]] && json_err "Usage: activity-log <action> <caste> <description>"
  log_file="$DATA_DIR/activity.log"
  ts=$(date -u +"%H:%M:%S")
  echo "[$ts] $action $caste: $description" >> "$log_file"
  json_ok '"logged"'
  ;;
```

Valid actions: START, COMPLETE, ERROR, CREATED, MODIFIED, RESEARCH, SPAWN. Do NOT validate the action value -- keep it flexible for future use.

**2. `activity-log-init` subcommand** -- archives previous log and starts fresh:
```bash
activity-log-init)
  phase_num="${1:-}"
  phase_name="${2:-}"
  [[ -z "$phase_num" ]] && json_err "Usage: activity-log-init <phase_num> [phase_name]"
  log_file="$DATA_DIR/activity.log"
  archive_file="$DATA_DIR/activity-phase-${phase_num}.log"
  if [ -f "$log_file" ] && [ -s "$log_file" ]; then
    mv "$log_file" "$archive_file"
  fi
  ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  echo "# Phase $phase_num: ${phase_name:-unnamed} -- $ts" > "$log_file"
  json_ok "{\"archived\":$([ -f \"$archive_file\" ] && echo 'true' || echo 'false')}"
  ;;
```

**3. `activity-log-read` subcommand** -- reads log content, optionally filtered by caste:
```bash
activity-log-read)
  caste_filter="${1:-}"
  log_file="$DATA_DIR/activity.log"
  [[ -f "$log_file" ]] || json_err "activity.log not found"
  if [ -n "$caste_filter" ]; then
    content=$(grep "$caste_filter" "$log_file" | tail -20)
  else
    content=$(cat "$log_file")
  fi
  json_ok "$(echo "$content" | jq -Rs '.')"
  ;;
```

**4. Update the `help` subcommand:** Add the three new commands to the commands array in the help output. The current list is:
`["help","version","pheromone-decay","pheromone-effective","pheromone-batch","pheromone-cleanup","pheromone-validate","validate-state","spawn-check","memory-compress","error-add","error-pattern-check","error-summary"]`

Add `"activity-log","activity-log-init","activity-log-read"` to this array.
  </action>
  <verify>
Run each subcommand and confirm JSON output:

```bash
# Init a test log
bash .aether/aether-utils.sh activity-log-init 99 "test-phase"
# Should return {"ok":true,"result":{"archived":...}}

# Write a log entry
bash .aether/aether-utils.sh activity-log "START" "builder-ant" "test task"
# Should return {"ok":true,"result":"logged"}

# Read the log
bash .aether/aether-utils.sh activity-log-read
# Should return {"ok":true,"result":"# Phase 99: test-phase -- ...\n[HH:MM:SS] START builder-ant: test task\n"}

# Read filtered
bash .aether/aether-utils.sh activity-log-read "builder-ant"
# Should return only builder-ant lines

# Verify help lists new commands
bash .aether/aether-utils.sh help | grep -c "activity-log"
# Should return 3 (or at least confirm they appear)

# Cleanup test log
rm -f .aether/data/activity.log .aether/data/activity-phase-99.log
```
  </verify>
  <done>
All three subcommands exist in aether-utils.sh and return valid JSON. `activity-log` appends timestamped lines. `activity-log-init` archives and creates fresh log with phase header. `activity-log-read` returns log content as JSON string, with optional caste filter. Help output lists all three.
  </done>
</task>

</tasks>

<verification>
- `bash .aether/aether-utils.sh help` lists activity-log, activity-log-init, activity-log-read
- Each subcommand returns `{"ok":true,"result":...}` on success
- Each subcommand returns `{"ok":false,"error":"..."}` on invalid usage
- Log lines follow format: `[HH:MM:SS] ACTION caste-name: description`
- Init creates phase header: `# Phase N: name -- ISO-timestamp`
- Init archives previous log as `activity-phase-{N}.log` if it exists
- Read returns JSON-escaped string content
- No existing subcommands broken (run `bash .aether/aether-utils.sh version` to confirm)
</verification>

<success_criteria>
aether-utils.sh has 16 subcommands (was 13), all three activity-log subcommands work correctly, existing functionality unbroken.
</success_criteria>

<output>
After completion, create `.planning/phases/25-live-visibility/25-01-SUMMARY.md`
</output>
