---
phase: 08-colony-learning
plan: 03
type: execute
wave: 3
depends_on: [08-02]
files_modified:
  - .aether/utils/spawn-decision.sh
autonomous: true
user_setup: []

must_haves:
  truths:
    - "spawn-decision.sh sources bayesian-confidence.sh after line 25 (after atomic-write.sh sourcing block)"
    - "Configuration constants added after WORKER_ANTS_FILE definition (around line 30)"
    - "recommend_specialist_by_confidence() finds highest confidence specialist for task type"
    - "Sample size weighting prevents over-reliance on sparse data (min 5 samples required)"
    - "map_gap_to_specialist() enhanced to consult meta-learning before falling back to semantic analysis"
    - "Confidence threshold (0.7) filters out low-confidence recommendations"
    - "detect_capability_gaps() enhanced to use Bayesian specialist recommendations when spawning"
    - "Bayesian recommendation integrated into actual spawn decision workflow (not just function definition)"
  artifacts:
    - path: ".aether/utils/spawn-decision.sh"
      provides: "Spawn decision logic with Bayesian confidence integration"
      min_lines: 450
      exports: ["recommend_specialist_by_confidence", "get_weighted_specialist_scores"]
  key_links:
    - from: ".aether/utils/spawn-decision.sh"
      to: ".aether/data/COLONY_STATE.json"
      via: "jq queries to meta_learning.specialist_confidence"
      pattern: "jq '.meta_learning.specialist_confidence.*.*'"
    - from: ".aether/utils/spawn-decision.sh"
      to: ".aether/utils/bayesian-confidence.sh"
      via: "Source statement after line 25"
      pattern: "source .aether/utils/bayesian-confidence.sh"
    - from: ".aether/utils/spawn-decision.sh/detect_capability_gaps"
      to: ".aether/utils/spawn-decision.sh/recommend_specialist_by_confidence"
      via: "Function call for Bayesian specialist recommendation"
      pattern: "recommend_specialist_by_confidence"
    - from: ".aether/utils/spawn-decision.sh/map_gap_to_specialist"
      to: ".aether/utils/spawn-decision.sh/recommend_specialist_by_confidence"
      via: "Function call for confidence-based ranking"
      pattern: "recommend_specialist_by_confidence"
---

<objective>
Integrate Bayesian confidence scoring into spawn-decision.sh for intelligent specialist recommendation

Purpose: Enhance specialist selection to prefer historically successful specialists for task types. Use Bayesian confidence scores with sample size weighting to avoid premature strong recommendations from sparse data. Integrate recommendations into actual spawn decision logic at the capability gap detection point.

Output: Enhanced spawn-decision.sh with recommend_specialist_by_confidence(), meta-learning integration in map_gap_to_specialist(), and detect_capability_gaps() using Bayesian recommendations for specialist selection during spawn decisions
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/phases/08-colony-learning/08-RESEARCH.md
@.planning/phases/08-colony-learning/08-02-SUMMARY.md
@.planning/STATE.md
@.planning/ROADMAP.md

@.aether/utils/spawn-decision.sh
@.aether/utils/spawn-outcome-tracker.sh
@.aether/data/COLONY_STATE.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Source bayesian-confidence.sh and add configuration constants</name>
  <files>.aether/utils/spawn-decision.sh</files>
  <action>
Update .aether/utils/spawn-decision.sh to source bayesian-confidence.sh:

**1. Add source statement after line 25 (after atomic-write.sh sourcing block ends):**

Find this block (lines 13-23):
```bash
# Source atomic-write for state operations
# We use absolute path from AETHER_ROOT or relative from this file's location
AETHER_ROOT="${AETHER_ROOT:-$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)}"
if [ -f "${AETHER_ROOT}/.aether/utils/atomic-write.sh" ]; then
    source "${AETHER_ROOT}/.aether/utils/atomic-write.sh"
else
    # Try relative path from current directory
    if [ -f ".aether/utils/atomic-write.sh" ]; then
        source ".aether/utils/atomic-write.sh"
    fi
fi
```

**Add immediately after (after line 23, before WORKER_ANTS_FILE at line 25):**
```bash
# Source Bayesian confidence library for meta-learning recommendations
if [ -f "${AETHER_ROOT}/.aether/utils/bayesian-confidence.sh" ]; then
    source "${AETHER_ROOT}/.aether/utils/bayesian-confidence.sh"
else
    # Try relative path from current directory
    if [ -f ".aether/utils/bayesian-confidence.sh" ]; then
        source ".aether/utils/bayesian-confidence.sh"
    fi
fi
```

**2. Add configuration constants after WORKER_ANTS_FILE definition (after line 26):**
```bash
# Worker ants data file
WORKER_ANTS_FILE=".aether/data/worker_ants.json"

# Meta-learning configuration
MIN_CONFIDENCE_FOR_RECOMMENDATION=0.7  # 70% - minimum confidence to use meta-learning
MIN_SAMPLES_FOR_RECOMMENDATION=5      # Minimum spawns before trusting confidence
META_LEARNING_ENABLED=true             # Can be disabled to fall back to semantic-only
```

**3. Update WORKER_ANTS_FILE path to use COLONY_STATE_FILE (since meta-learning data is in COLONY_STATE.json, not worker_ants.json):**
```bash
# Colony state file (contains meta_learning.specialist_confidence)
COLONY_STATE_FILE="${AETHER_ROOT}/.aether/data/COLONY_STATE.json"
# Keep WORKER_ANTS_FILE for caste capabilities/mappings
WORKER_ANTS_FILE="${AETHER_ROOT}/.aether/data/worker_ants.json"
```

**IMPORTANT:**
- Place source statement after atomic-write.sh block (line 23+), before WORKER_ANTS_FILE (line 25)
- Use AETHER_ROOT variable for path detection
- Provide fallback to relative path
- Add constants before function definitions
- Add COLONY_STATE_FILE constant for Bayesian queries
  </action>
  <verify>
Check source statement and constants exist:
```bash
# Verify bayesian-confidence.sh is sourced
grep -n "bayesian-confidence.sh" .aether/utils/spawn-decision.sh
# Should show source statement after line 23

# Verify configuration constants exist
grep -n "MIN_CONFIDENCE_FOR_RECOMMENDATION\|MIN_SAMPLES_FOR_RECOMMENDATION\|META_LEARNING_ENABLED" .aether/utils/spawn-decision.sh
# Should show all three constants after line 26

# Verify COLONY_STATE_FILE constant added
grep -n "COLONY_STATE_FILE" .aether/utils/spawn-decision.sh
# Should show COLONY_STATE_FILE path definition
```
  </verify>
  <done>
spawn-decision.sh sources bayesian-confidence.sh after line 23. Configuration constants MIN_CONFIDENCE_FOR_RECOMMENDATION=0.7, MIN_SAMPLES_FOR_RECOMMENDATION=5, META_LEARNING_ENABLED=true added after line 26. COLONY_STATE_FILE constant added for Bayesian queries.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add Bayesian confidence recommendation functions to spawn-decision.sh</name>
  <files>.aether/utils/spawn-decision.sh</files>
  <action>
Add Bayesian confidence-based recommendation functions to .aether/utils/spawn-decision.sh:

**Add these functions after calculate_spawn_score() (around line 248, before detect_capability_gaps at line 252):**

**1. recommend_specialist_by_confidence(task_type, min_confidence, min_samples)**
```bash
# Recommend specialist by Bayesian confidence for a task type
# Arguments: task_type, min_confidence (default 0.7), min_samples (default 5)
# Returns: "specialist_caste|confidence" or "none|0.0" if no confident recommendation
recommend_specialist_by_confidence() {
    local task_type="$1"
    local min_confidence="${2:-$MIN_CONFIDENCE_FOR_RECOMMENDATION}"
    local min_samples="${3:-$MIN_SAMPLES_FOR_RECOMMENDATION}"

    # Validate meta-learning is enabled
    if [ "$META_LEARNING_ENABLED" != "true" ]; then
        echo "none|0.0"
        return 0
    fi

    # Validate COLONY_STATE_FILE exists
    if [ ! -f "$COLONY_STATE_FILE" ]; then
        echo "none|0.0"
        return 0
    fi

    # Find best specialist for this task type from COLONY_STATE.json
    local best=$(jq -r "
        .meta_learning.specialist_confidence |
        to_entries[] |
        select(.value | has(\"$task_type\")) |
        select(.value.\"$task_type\".total_spawns >= $min_samples) |
        select(.value.\"$task_type\".confidence >= $min_confidence) |
        \"\(.key)|\(.value.\"$task_type\".confidence)\"
    " "$COLONY_STATE_FILE" 2>/dev/null | sort -t'|' -k2 -nr | head -1)

    if [ -n "$best" ] && [[ "$best" != *"|"* ]]; then
        # Handle jq error case (no valid data)
        echo "none|0.0"
    elif [ -n "$best" ]; then
        echo "$best"
    else
        echo "none|0.0"
    fi
}
```

**2. get_weighted_specialist_scores(task_type)**
```bash
# Get all specialists with weighted confidence scores for a task type
# Arguments: task_type
# Returns: Ranked list of specialists with alpha/beta/confidence/weight/weighted_score
get_weighted_specialist_scores() {
    local task_type="$1"

    # Validate COLONY_STATE_FILE exists
    if [ ! -f "$COLONY_STATE_FILE" ]; then
        return 1
    fi

    # Get all specialists with this task type
    jq -r "
        .meta_learning.specialist_confidence |
        to_entries[] |
        select(.value | has(\"$task_type\")) |
        \"\(.key)|\(.value.\"$task_type\".alpha)|\(.value.\"$task_type\".beta)|\(.value.\"$task_type\".confidence)|\(.value.\"$task_type\".total_spawns)\"
    " "$COLONY_STATE_FILE" 2>/dev/null | while IFS='|' read -r specialist alpha beta confidence total_spawns; do
        # Skip if data missing
        [ -z "$specialist" ] && continue

        # Calculate sample size weight (min 10 samples for full weight)
        local weight=$(echo "scale=6; $total_spawns / 10" | bc)
        if (( $(echo "$weight > 1.0" | bc -l) )); then
            weight=1.0
        fi

        # Apply weighting: weighted = raw * (0.5 + 0.5 * weight)
        local weighted=$(echo "scale=6; $confidence * (0.5 + 0.5 * $weight)" | bc)

        echo "$specialist|$alpha|$beta|$confidence|$total_spawns|$weight|$weighted"
    done | sort -t'|' -k7 -nr  # Sort by weighted confidence descending
}
```

**3. Update function exports at bottom of file (around line 334):**
Find the export section:
```bash
# Export functions
export -f analyze_task_requirements
export -f compare_capabilities
export -f detect_capability_gaps
export -f calculate_spawn_score
export -f map_gap_to_specialist
```

**Add the new exports:**
```bash
# Export functions
export -f analyze_task_requirements
export -f compare_capabilities
export -f detect_capability_gaps
export -f calculate_spawn_score
export -f map_gap_to_specialist
export -f recommend_specialist_by_confidence
export -f get_weighted_specialist_scores
```

**IMPORTANT:**
- Add functions after calculate_spawn_score() (around line 248)
- Handle "none|0.0" return for no confident recommendation
- Handle missing COLONY_STATE_FILE gracefully (return "none|0.0")
- Handle jq errors by redirecting stderr to /dev/null
- Validate output format before returning (check for "|" separator)
- Export new functions at bottom
- Add comments explaining Bayesian approach
  </action>
  <verify>
Test Bayesian recommendation functions:
```bash
source .aether/utils/spawn-decision.sh

# Test 1: Recommend specialist for known task type
result=$(recommend_specialist_by_confidence "database" 0.7 5)
echo "Result: $result"
# Should return "specialist_caste|confidence" or "none|0.0"
# Validate format: should contain "|"
if [[ "$result" == *"|"* ]]; then
    caste=$(echo "$result" | cut -d'|' -f1)
    conf=$(echo "$result" | cut -d'|' -f2)
    echo "  Caste: $caste, Confidence: $conf"
fi

# Test 2: Get weighted scores
scores=$(get_weighted_specialist_scores "database")
echo "Scores:"
echo "$scores"
# Should list all specialists with alpha/beta/confidence/weight/weighted (or nothing if no data)

# Test 3: Verify functions are exported
declare -f recommend_specialist_by_confidence
declare -f get_weighted_specialist_scores
# Both should show function definitions
```
  </verify>
  <done>
spawn-decision.sh has recommend_specialist_by_confidence() and get_weighted_specialist_scores() functions. Functions handle missing data gracefully (return "none|0.0" or empty output). Functions validate output format and handle jq errors. Functions exported for use by other scripts.
  </done>
</task>

<task type="auto">
  <name>Task 3: Enhance map_gap_to_specialist() with meta-learning consultation</name>
  <files>.aether/utils/spawn-decision.sh</files>
  <action>
Update map_gap_to_specialist() in .aether/utils/spawn-decision.sh to consult meta-learning before semantic analysis:

**Find existing map_gap_to_specialist() function (starts around line 252)**

**Replace the function with this enhanced version:**

```bash
# Map capability gaps to appropriate specialist caste
# Arguments: gaps (JSON array), task_description
# Returns: JSON with caste name, specialization, and source (meta_learning or semantic_analysis)
map_gap_to_specialist() {
    local gaps="$1"
    local task_description="$2"

    # Convert to lowercase for matching
    local task_lower=$(echo "$task_description" | tr '[:upper:]' '[:lower:]')

    # Determine primary task type from gaps
    local primary_task_type=""
    if [ -n "$gaps" ]; then
        primary_task_type=$(echo "$gaps" | jq -r '.[0]' 2>/dev/null || echo "general")
    else
        primary_task_type="general"
    fi

    # Try Bayesian meta-learning recommendation first
    if [ "$META_LEARNING_ENABLED" = "true" ]; then
        local meta_learning_result=$(recommend_specialist_by_confidence "$primary_task_type" "$MIN_CONFIDENCE_FOR_RECOMMENDATION" "$MIN_SAMPLES_FOR_RECOMMENDATION")
        local specialist_caste=$(echo "$meta_learning_result" | cut -d'|' -f1)
        local confidence=$(echo "$meta_learning_result" | cut -d'|' -f2)

        # Check if we got a valid recommendation (not "none" and confidence meets threshold)
        if [ "$specialist_caste" != "none" ] && [ -n "$confidence" ] && [ "$confidence" != "0.0" ]; then
            # Validate confidence is a number and meets threshold
            local conf_check=$(echo "$confidence >= $MIN_CONFIDENCE_FOR_RECOMMENDATION" | bc -l 2>/dev/null || echo "0")
            if [ "$conf_check" -eq 1 ]; then
                # Use meta-learning recommendation
                local specialization="$primary_task_type specialist (confidence: $confidence)"
                # Build result JSON
                local result=$(jq -n \
                    --arg caste "$specialist_caste" \
                    --arg specialization "$specialization" \
                    --argjson confidence "$confidence" \
                    --arg source "meta_learning" \
                    '{caste: $caste, specialization: $specialization, confidence: $confidence, source: $source}')
                echo "$result"
                return 0
            fi
        fi
    fi

    # Fallback to semantic analysis (existing logic)
    # Get specialist mappings from worker_ants.json
    local mappings=$(jq -r '.specialist_mappings.capability_to_caste // {}' "$WORKER_ANTS_FILE")

    # Try direct mapping first
    local specialist_caste=""
    local specialization=""

    # Check each gap for direct mapping
    while IFS= read -r gap; do
        # Try exact match in mappings
        local mapped_caste=$(echo "$mappings" | jq -r --arg gap "$gap" '.[$gap] // empty')

        if [ -n "$mapped_caste" ]; then
            specialist_caste="$mapped_caste"
            specialization="$gap specialist"
            break
        fi
    done <<< "$(echo "$gaps" | jq -r '.[]' 2>/dev/null || echo "")"

    # Fallback to semantic analysis if no direct mapping
    if [ -z "$specialist_caste" ]; then
        # Semantic analysis based on task description
        if [[ "$task_lower" =~ (database|sql|nosql|mongo|postgres|schema|migration) ]]; then
            specialist_caste="scout"
            specialization="database expert"
        elif [[ "$task_lower" =~ (security|auth|authentication|authorization|encryption) ]]; then
            specialist_caste="watcher"
            specialization="security specialist"
        elif [[ "$task_lower" =~ (test|testing|validation|verification) ]]; then
            specialist_caste="watcher"
            specialization="testing specialist"
        elif [[ "$task_lower" =~ (api|endpoint|route|rest|graphql) ]]; then
            specialist_caste="route_setter"
            specialization="api design expert"
        elif [[ "$task_lower" =~ (react|vue|angular|frontend|ui|component) ]]; then
            specialist_caste="builder"
            specialization="frontend specialist"
        elif [[ "$task_lower" =~ (backend|server|service|controller) ]]; then
            specialist_caste="builder"
            specialization="backend specialist"
        elif [[ "$task_lower" =~ (performance|optimization|cache|scalability) ]]; then
            specialist_caste="architect"
            specialization="performance optimizer"
        elif [[ "$task_lower" =~ (document|documentation|readme|guide) ]]; then
            specialist_caste="scout"
            specialization="documentation expert"
        elif [[ "$task_lower" =~ (infrastructure|deploy|devops|ci/cd|docker) ]]; then
            specialist_caste="builder"
            specialization="infrastructure specialist"
        elif [[ "$task_lower" =~ (research|investigate|explore|analyze) ]]; then
            specialist_caste="scout"
            specialization="research specialist"
        elif [[ "$task_lower" =~ (plan|planning|design|architect) ]]; then
            specialist_caste="route_setter"
            specialization="planning specialist"
        elif [[ "$task_lower" =~ (compress|memory|pattern|synthesize) ]]; then
            specialist_caste="architect"
            specialization="memory specialist"
        else
            # Default fallback: scout for information gathering
            specialist_caste="scout"
            specialization="general specialist"
        fi
    fi

    # Build result JSON with semantic_analysis source
    local result=$(jq -n \
        --arg caste "$specialist_caste" \
        --arg specialization "$specialization" \
        --arg source "semantic_analysis" \
        '{caste: $caste, specialization: $specialization, source: $source}')

    echo "$result"
}
```

**IMPORTANT:**
- Call recommend_specialist_by_confidence() BEFORE semantic analysis
- Check for META_LEARNING_ENABLED flag
- Add "source" field to result JSON ("meta_learning" or "semantic_analysis")
- Keep existing semantic analysis as fallback
- Handle missing gaps gracefully
- Return early if meta-learning recommendation found
- Validate confidence is numeric before comparing to threshold
- Validate specialist_caste is not "none" and confidence is not "0.0"
  </action>
  <verify>
Test enhanced map_gap_to_specialist():
```bash
source .aether/utils/spawn-decision.sh

# Test 1: Map gap uses meta-learning first (if confident recommendation exists)
gaps='["database"]'
task_desc="Database schema migration"
result=$(map_gap_to_specialist "$gaps" "$task_desc")
echo "Result: $result"
source_field=$(echo "$result" | jq -r '.source')
echo "Source: $source_field"
# If confidence >= 0.7 and samples >= 5, source should be "meta_learning"
# Otherwise source should be "semantic_analysis"

# Test 2: Verify result structure
caste=$(echo "$result" | jq -r '.caste')
specialization=$(echo "$result" | jq -r '.specialization')
echo "Caste: $caste, Specialization: $specialization"
# Should have valid caste and specialization
```
  </verify>
  <done>
map_gap_to_specialist() calls recommend_specialist_by_confidence() before semantic analysis. Uses meta-learning recommendation if confidence >= 0.7 and samples >= 5. Falls back to semantic analysis otherwise. Result JSON includes source field. Validates confidence is numeric before comparison.
  </done>
</task>

<task type="auto">
  <name>Task 4: Integrate Bayesian recommendations into spawn decision workflow</name>
  <files>.aether/utils/spawn-decision.sh</files>
  <action>
Update detect_capability_gaps() in .aether/utils/spawn-decision.sh to use Bayesian specialist recommendations for actual spawn decisions:

**Find existing detect_capability_gaps() function (starts around line 193)**

**Find this section (lines 214-215):**
```bash
    # Pattern recognition from meta_learning (placeholder for now)
    # This will be enhanced in later phases with actual meta-learning integration
```

**Replace with this integration:**
```bash
    # Meta-learning pattern recognition
    # If spawning, use Bayesian confidence to recommend which specialist
    if [ "$decision" = "spawn" ] && [ "$META_LEARNING_ENABLED" = "true" ]; then
        # Try to get Bayesian recommendation for specialist type
        local task_type_for_rec=""
        if [ -n "$gaps" ]; then
            task_type_for_rec=$(echo "$gaps" | jq -r '.[0]' 2>/dev/null || echo "general")
        fi

        if [ -n "$task_type_for_rec" ]; then
            local meta_rec=$(recommend_specialist_by_confidence "$task_type_for_rec" "$MIN_CONFIDENCE_FOR_RECOMMENDATION" "$MIN_SAMPLES_FOR_RECOMMENDATION")
            local rec_caste=$(echo "$meta_rec" | cut -d'|' -f1)
            local rec_confidence=$(echo "$meta_rec" | cut -d'|' -f2)

            # Enhance reason with Bayesian recommendation if available
            if [ "$rec_caste" != "none" ] && [ -n "$rec_confidence" ] && [ "$rec_confidence" != "0.0" ]; then
                reason="$reason (Bayesian recommendation: $rec_caste with confidence=$rec_confidence)"
            fi
        fi
    fi
```

**Full updated function context:**
```bash
# Detect capability gaps and decide whether to spawn
# Arguments: gaps (JSON array), task_type, failure_count
# Returns: JSON with decision and reason
detect_capability_gaps() {
    local gaps="$1"
    local task_type="$2"
    local failure_count="$3"

    local gaps_count=$(echo "$gaps" | jq '. | length')
    local decision="attempt"
    local reason="No significant capability gaps detected"

    # Explicit domain mismatch
    if [ "$gaps_count" -gt 0 ]; then
        decision="spawn"
        reason="Explicit domain mismatch: missing capabilities: $(echo "$gaps" | jq -r '. | join(", ")')"
    fi

    # Failure after attempts
    if [ "$failure_count" -gt 0 ]; then
        decision="spawn"
        reason="Failure after $failure_count attempts, spawning specialist for assistance"
    fi

    # Meta-learning pattern recognition
    # If spawning, use Bayesian confidence to recommend which specialist
    if [ "$decision" = "spawn" ] && [ "$META_LEARNING_ENABLED" = "true" ]; then
        # Try to get Bayesian recommendation for specialist type
        local task_type_for_rec=""
        if [ -n "$gaps" ]; then
            task_type_for_rec=$(echo "$gaps" | jq -r '.[0]' 2>/dev/null || echo "general")
        fi

        if [ -n "$task_type_for_rec" ]; then
            local meta_rec=$(recommend_specialist_by_confidence "$task_type_for_rec" "$MIN_CONFIDENCE_FOR_RECOMMENDATION" "$MIN_SAMPLES_FOR_RECOMMENDATION")
            local rec_caste=$(echo "$meta_rec" | cut -d'|' -f1)
            local rec_confidence=$(echo "$meta_rec" | cut -d'|' -f2)

            # Enhance reason with Bayesian recommendation if available
            if [ "$rec_caste" != "none" ] && [ -n "$rec_confidence" ] && [ "$rec_confidence" != "0.0" ]; then
                reason="$reason (Bayesian recommendation: $rec_caste with confidence=$rec_confidence)"
            fi
        fi
    fi

    # Build result JSON
    local result=$(jq -n \
        --arg decision "$decision" \
        --arg reason "$reason" \
        '{decision: $decision, reason: $reason}')

    echo "$result"
}
```

**IMPORTANT:**
- Only call recommend_specialist_by_confidence() when decision="spawn"
- Check META_LEARNING_ENABLED flag before using meta-learning
- Extract task_type from gaps for recommendation
- Enhance reason string with Bayesian recommendation details
- Handle "none|0.0" return gracefully by checking both caste and confidence
- Validate rec_caste is not "none" AND rec_confidence is not "0.0" AND rec_confidence is not empty
- Maintain backward compatibility (decision/reason structure unchanged)
- This is the PRIMARY integration point: the spawn decision workflow now uses Bayesian recommendations
  </action>
  <verify>
Test enhanced detect_capability_gaps():
```bash
source .aether/utils/spawn-decision.sh

# Test 1: Spawn decision includes Bayesian recommendation
gaps='["database"]'
result=$(detect_capability_gaps "$gaps" "database" 0)
echo "Result: $result"
reason=$(echo "$result" | jq -r '.reason')
echo "Reason: $reason"
# Should include "Bayesian recommendation: X with confidence=Y" if confident specialist exists

# Test 2: Non-spawn decision unchanged
result=$(detect_capability_gaps "[]" "general" 0)
echo "Result: $result"
decision=$(echo "$result" | jq -r '.decision')
echo "Decision: $decision"
# Should be "attempt" with no Bayesian recommendation mentioned
```
  </verify>
  <done>
detect_capability_gaps() calls recommend_specialist_by_confidence() when decision="spawn". This is the PRIMARY integration into the actual spawn decision workflow. Enhances reason string with Bayesian recommendation details when confident specialist available. Works with META_LEARNING_ENABLED flag. Validates rec_caste is not "none", rec_confidence is not "0.0", and rec_confidence is not empty before enhancing reason.
  </done>
</task>

</tasks>

<verification>
1. spawn-decision.sh sources bayesian-confidence.sh after line 23 (after atomic-write.sh block)
2. Configuration constants MIN_CONFIDENCE_FOR_RECOMMENDATION=0.7, MIN_SAMPLES_FOR_RECOMMENDATION=5, META_LEARNING_ENABLED=true added after line 26
3. COLONY_STATE_FILE constant added for Bayesian queries
4. recommend_specialist_by_confidence() function defined and exported
5. get_weighted_specialist_scores() function defined and exported
6. map_gap_to_specialist() calls recommend_specialist_by_confidence() before semantic analysis
7. map_gap_to_specialist() result includes source field (meta_learning vs semantic_analysis)
8. detect_capability_gaps() uses Bayesian recommendations when spawning (PRIMARY INTEGRATION POINT)
9. Meta-learning recommendation requires min_confidence=0.7 and min_samples=5
10. Fallback to semantic analysis works when no confident recommendation
11. All functions handle missing data gracefully (return "none|0.0" or empty)
12. recommend_specialist_by_confidence() validates output format (checks for "|" separator)
13. recommend_specialist_by_confidence() handles jq errors (stderr redirected to /dev/null)
14. detect_capability_gaps() validates rec_caste != "none", rec_confidence != "0.0", rec_confidence is not empty
</verification>

<success_criteria>
Spawn decision logic uses Bayesian meta-learning for intelligent specialist selection. Colony prefers historically successful specialists for task types while avoiding premature strong recommendations from sparse data. Meta-learning recommendations integrated into both map_gap_to_specialist() (specialist selection) and detect_capability_gaps() (spawn decision workflow at capability gap detection point).
</success_criteria>

<output>
After completion, create `.planning/phases/08-colony-learning/08-03-SUMMARY.md`
</output>
