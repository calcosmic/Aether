---
phase: 12-colony-visualization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .aether/aether-utils.sh
  - bin/lib/telemetry.js
  - .aether/data/swarm-display.json
autonomous: true
must_haves:
  truths:
    - Tool usage counters exist for each active ant
    - Token consumption is tracked per spawn/task
    - Timing information (start time, duration, ETA) is available
    - Activity data is written atomically to prevent corruption
  artifacts:
    - path: bin/lib/telemetry.js
      provides: Tool usage tracking functions
      exports: ["updateToolUsage", "updateTokenUsage"]
    - path: .aether/aether-utils.sh
      provides: Shell commands for activity tracking
      contains: ["swarm-activity-log", "swarm-display-update"]
    - path: .aether/data/swarm-display.json
      provides: Real-time activity state
      contains: ["active_ants", "tools", "tokens", "timing"]
  key_links:
    - from: bin/lib/telemetry.js
      to: .aether/data/telemetry.json
      via: atomic writes
      pattern: "fs.writeFileSync.*tmp.*rename"
    - from: .aether/aether-utils.sh
      to: .aether/data/swarm-display.json
      via: swarm-display-update command
      pattern: "atomic_write.*swarm-display.json"
---

<objective>
Build the foundation for colony visualization by implementing activity tracking infrastructure. Add tool usage counters (Read/Grep/Edit/Bash), token consumption tracking (trophallaxis metrics), and timing information to the telemetry and display systems.

Purpose: Provides the data layer that all visualization features depend on. Without accurate tracking, the displays would show mock data.
Output: Extended telemetry.js with tool/token tracking, new aether-utils.sh commands for activity logging, and swarm-display.json data structure.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-colony-visualization/12-RESEARCH.md
@/Users/callumcowie/repos/Aether/bin/lib/telemetry.js
@/Users/callumcowie/repos/Aether/.aether/aether-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend telemetry.js with tool and token tracking</name>
  <files>bin/lib/telemetry.js</files>
  <action>
Add two new functions to bin/lib/telemetry.js:

1. `updateToolUsage(repoPath, spawnId, toolType, count = 1)`
   - Find the routing decision by timestamp (spawnId)
   - Initialize tools object if not exists: `{read: 0, grep: 0, edit: 0, bash: 0}`
   - Increment the specified tool type counter
   - Save atomically using existing saveTelemetry
   - Return boolean success

2. `updateTokenUsage(repoPath, spawnId, tokens)`
   - Find the routing decision by timestamp (spawnId)
   - Add tokens to existing count (cumulative)
   - Save atomically
   - Return boolean success

Also update `recordSpawnTelemetry` to initialize the tools object in new decisions:
```javascript
tools: { read: 0, grep: 0, edit: 0, bash: 0 },
tokens: 0,
started_at: timestamp  // for timing calculations
```

Add exports for the new functions in module.exports.

Follow existing code patterns: use loadTelemetry/saveTelemetry, handle errors silently (return false on failure), use atomic writes via temp file + rename.
  </action>
  <verify>grep -q "updateToolUsage" bin/lib/telemetry.js && grep -q "updateTokenUsage" bin/lib/telemetry.js && echo "Functions added"</verify>
  <done>telemetry.js contains updateToolUsage and updateTokenUsage functions, tools and tokens fields initialized in recordSpawnTelemetry, functions exported</done>
</task>

<task type="auto">
  <name>Task 2: Add swarm activity tracking commands to aether-utils.sh</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Add three new subcommands to aether-utils.sh:

1. `swarm-activity-log <ant_name> <action> <details>`
   - Append to .aether/data/swarm-activity.log with timestamp
   - Format: "[HH:MM:SS] <ant_name>: <action> <details>"
   - Create file if doesn't exist
   - Return JSON ok response

2. `swarm-display-init <swarm_id>`
   - Create/reset .aether/data/swarm-display.json with structure:
   ```json
   {
     "swarm_id": "<swarm_id>",
     "timestamp": "ISO timestamp",
     "active_ants": [],
     "summary": { "total_active": 0, "by_caste": {}, "by_zone": {} },
     "chambers": {
       "fungus_garden": {"activity": 0, "icon": "üçÑ"},
       "nursery": {"activity": 0, "icon": "ü•ö"},
       "refuse_pile": {"activity": 0, "icon": "üóëÔ∏è"},
       "throne_room": {"activity": 0, "icon": "üëë"},
       "foraging_trail": {"activity": 0, "icon": "üåø"}
     }
   }
   ```
   - Use atomic_write for safe file creation

3. `swarm-display-update <ant_name> <caste> <status> <task> [parent] [tools_json] [tokens]`
   - Read existing swarm-display.json
   - Find or create ant entry in active_ants array
   - Update fields: name, caste, status, task, parent, tools (parsed from JSON), tokens, started_at (if new), updated_at
   - Recalculate summary counts (total_active, by_caste, by_zone)
   - Write back atomically
   - Return JSON with updated ant info

Add these to the commands list in the help output.

Follow existing patterns: use atomic_write, json_ok/json_err, validate inputs, use get_caste_emoji for consistency.
  </action>
  <verify>bash .aether/aether-utils.sh help | grep -q "swarm-activity-log" && echo "Commands added"</verify>
  <done>aether-utils.sh has swarm-activity-log, swarm-display-init, and swarm-display-update commands; help output includes them</done>
</task>

<task type="auto">
  <name>Task 3: Add timing utilities to aether-utils.sh</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Add timing utility commands to aether-utils.sh:

1. `swarm-timing-start <ant_name>`
   - Record start time for an ant in .aether/data/timing.log
   - Format: "ant_name|start_timestamp|ISO_date"
   - Return JSON with started_at timestamp

2. `swarm-timing-get <ant_name>`
   - Read timing.log and calculate elapsed time
   - Return JSON: {"ant": "name", "started_at": "ISO", "elapsed_seconds": N, "elapsed_formatted": "MM:SS"}
   - If ant not found, return elapsed_seconds: 0

3. `swarm-timing-eta <ant_name> <percent_complete>`
   - Calculate ETA based on elapsed time and percent complete
   - Return JSON: {"ant": "name", "percent": N, "eta_seconds": N, "eta_formatted": "MM:SS"}
   - Handle edge cases: percent 0 (eta unknown), percent 100 (eta 0)

4. `swarm-display-get`
   - Read and return swarm-display.json content as JSON
   - If file doesn't exist, return empty structure
   - Used by visualization scripts to get current state

These utilities support VIZ-05 (timing information) and provide the data foundation for real-time displays.

Use existing patterns: append to log files for timing data (simple and efficient), JSON output via json_ok, error handling via json_err.
  </action>
  <verify>bash .aether/aether-utils.sh help | grep -q "swarm-timing" && echo "Timing commands added"</verify>
  <done>swarm-timing-start, swarm-timing-get, swarm-timing-eta, and swarm-display-get commands exist and return valid JSON</done>
</task>

</tasks>

<verification>
1. Run: `bash .aether/aether-utils.sh swarm-display-init test-swarm` - should create swarm-display.json
2. Run: `bash .aether/aether-utils.sh swarm-display-update Hammer-42 builder excavating "Implement auth"` - should update the file
3. Run: `bash .aether/aether-utils.sh swarm-display-get` - should return JSON with the ant
4. Run: `bash .aether/aether-utils.sh swarm-timing-start Hammer-42` then `swarm-timing-get Hammer-42` - should show elapsed time
5. Verify telemetry.js exports: `node -e "const t = require('./bin/lib/telemetry.js'); console.log(typeof t.updateToolUsage, typeof t.updateTokenUsage);"` - should print "function function"
</verification>

<success_criteria>
- Tool usage tracking functions exist in telemetry.js and are exported
- Token consumption tracking functions exist in telemetry.js and are exported
- aether-utils.sh has swarm-display-init, swarm-display-update, swarm-display-get commands
- aether-utils.sh has swarm-timing-start, swarm-timing-get, swarm-timing-eta commands
- swarm-display.json is created with proper structure including chambers, summary, active_ants
- All commands return valid JSON and use atomic writes
</success_criteria>

<output>
After completion, create `.planning/phases/12-colony-visualization/12-01-SUMMARY.md`
</output>
