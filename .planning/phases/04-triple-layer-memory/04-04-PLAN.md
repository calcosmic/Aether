---
phase: 04-triple-layer-memory
plan: 04
type: execute
wave: 4
depends_on: ["04-03"]
files_modified:
  - .aether/utils/memory-compress.sh
  - .aether/data/memory.json
  - .aether/data/pheromones.json
autonomous: true
must_haves:
  truths:
    - "Phase boundary compression trigger works (Architect compresses Working to Short-term)"
    - "Pattern extraction trigger moves high-value items to Long-term"
    - "Compression and extraction update metrics correctly"
  artifacts:
    - path: ".aether/utils/memory-compress.sh"
      provides: "Compression and extraction trigger functions"
      exports: ["trigger_phase_boundary_compression", "trigger_pattern_extraction"]
    - path: ".aether/data/pheromones.json"
      provides: "Pheromone signals for compression triggers"
      contains: "phase_complete or token_threshold signals"
  key_links:
    - from: ".aether/utils/memory-compress.sh"
      to: ".aether/data/pheromones.json"
      via: "read pheromones to detect phase boundary"
      pattern: "jq.*pheromones.json|phase_complete"
    - from: ".aether/utils/memory-compress.sh"
      to: ".aether/data/COLONY_STATE.json"
      via: "read colony state to determine current phase"
      pattern: "jq.*COLONY_STATE.json|current_phase"
---

<objective>
Implement phase boundary compression trigger and pattern extraction trigger that Architect Ant uses to compress memory at boundaries and extract high-value patterns.

Purpose: Compression happens automatically at phase boundaries (Architect detects phase complete), pattern extraction moves high-value items from Short-term to Long-term
Output: Trigger functions that Architect Ant calls to manage memory compression and pattern extraction
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-triple-layer-memory/04-RESEARCH.md

# Key Patterns to Follow
@.aether/workers/architect-ant.md - compression trigger workflow (lines 94-99)
@.aether/utils/memory-compress.sh - compression functions from 04-02, 04-03
@.aether/utils/memory-ops.sh - Working Memory from 04-01
@.aether/data/memory.json - all three memory layers
@.aether/data/pheromones.json - phase completion signals
@.aether/data/COLONY_STATE.json - phase tracking
</context>

<tasks>

<task type="auto">
  <name>Implement phase boundary compression trigger</name>
  <files>.aether/utils/memory-compress.sh</files>
  <action>
Add trigger_phase_boundary_compression(phase_number) function to memory-compress.sh:

**trigger_phase_boundary_compression(phase_number)**
- Check if phase is complete (read pheromones.json for phase_complete signal)
- Get current Working Memory items and token count
- If Working Memory is empty or below threshold, skip compression
- Otherwise:
  1. Read all Working Memory items: `jq '.working_memory.items' .aether/data/memory.json`
  2. Calculate target tokens: original_tokens / 2.5
  3. Trigger Architect Ant compression workflow (in practice, Architect Ant reads items and produces compressed session)
  4. Receive compressed session JSON (LLM output)
  5. Call create_short_term_session(phase_number, compressed_json)
  6. Call clear_working_memory()
  7. Increment metrics.total_compressions
  8. Update metrics.average_compression_ratio
- Return compression summary: items compressed, original tokens, compressed tokens, ratio

Note: In practice, steps 3-4 are done by Architect Ant (LLM), not bash. This function orchestrates the workflow and receives Architect's output.

Reference 04-RESEARCH.md lines 440-492 for compression trigger pattern.
Reference architect-ant.md lines 94-136 for compression workflow.

The function should:
1. Prepare Working Memory data for Architect Ant
2. Call Architect Ant to compress (LLM task)
3. Process Architect's output into Short-term session
4. Clear Working Memory
5. Update metrics
  </action>
  <verify>
```bash
# Source and test (requires mock Architect Ant output for testing)
source .aether/utils/memory-compress.sh

# Add test items to Working Memory
source .aether/utils/memory-ops.sh
add_working_memory_item "Decision: Use JSON for state" "decision" 1.0
add_working_memory_item "Outcome: Schema created successfully" "outcome" 0.9

# Test compression trigger (with mock compressed output)
compressed_output='{
  "id": "phase_1_test",
  "session_id": "phase_1_test",
  "compressed_at": "2026-02-01T12:00:00Z",
  "original_tokens": 500,
  "compressed_tokens": 200,
  "phase": 1,
  "summary": "Phase 1: Implemented colony state schemas with JSON persistence",
  "key_decisions": [
    {"decision": "Use JSON for state", "rationale": "Human-readable and universal"}
  ],
  "outcomes": [
    {"result": "Schema created", "impact": "Colony state persists across sessions"}
  ],
  "high_value_items": []
}'

# Process compressed output
create_short_term_session 1 "$compressed_output"
clear_working_memory

# Verify Working Memory cleared
jq '.working_memory.current_tokens' .aether/data/memory.json

# Verify Short-term session created
jq '.short_term_memory.sessions | length' .aether/data/memory.json
jq '.short_term_memory.sessions[-1]' .aether/data/memory.json
```
  </verify>
  <done>
Phase boundary compression trigger prepares Working Memory for Architect Ant, processes compressed output into Short-term session, clears Working Memory, and updates metrics.
  </done>
</task>

<task type="auto">
  <name>Implement token threshold compression trigger</name>
  <files>.aether/utils/memory-compress.sh</files>
  <action>
Add check_token_threshold() function to memory-compress.sh:

**check_token_threshold()**
- Get current_tokens from Working Memory
- Get max_capacity_tokens from Working Memory
- Calculate threshold: max_tokens * 80 / 100
- If current_tokens >= threshold:
  - Return 1 (compression needed)
- Else:
  - Return 0 (no compression needed)

Add auto_compress_if_needed() function:
- Call check_token_threshold()
- If returns 1, trigger compression (similar to phase boundary but for threshold)
- Use current phase from COLONY_STATE.json

This allows automatic compression when Working Memory exceeds 80% capacity, not just at phase boundaries.

Reference memory.json compression.triggers section for threshold trigger.
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-compress.sh
source .aether/utils/memory-ops.sh

# Add items until threshold
max=$(jq '.working_memory.max_capacity_tokens' .aether/data/memory.json)
threshold=$((max * 80 / 100))
echo "Threshold: $threshold tokens"

# Check threshold before adding
check_token_threshold
echo "Threshold check result: $?"

# Add large items
add_working_memory_item "$(printf 'A%.0s' {1..50000})" "test" 0.5

# Check threshold after adding
check_token_threshold
echo "Threshold check result: $?"
```
  </verify>
  <done>
Token threshold compression trigger detects when Working Memory exceeds 80% capacity and can trigger automatic compression before phase boundary.
  </done>
</task>

<task type="auto">
  <name>Implement pattern extraction trigger</name>
  <files>.aether/utils/memory-compress.sh</files>
  <action>
Add trigger_pattern_extraction() function to memory-compress.sh:

**trigger_pattern_extraction()**
- Get all Short-term sessions
- For each session:
  - Check high_value_items array
  - For items with relevance_score > 0.8:
    - Check if similar pattern exists in Long-term Memory
    - If pattern appears 3+ times across sessions:
      - Call extract_pattern_to_long_term with high confidence
      - Determine pattern_type (success/failure/preference/constraint)
    - Update last_seen timestamp for existing patterns
- Call detect_patterns_across_sessions() to find repeated patterns
- Increment metrics.total_pattern_extractions

Triggers:
1. High relevance (relevance_score > 0.8)
2. Repeated success (appears 3+ times)

Reference 04-RESEARCH.md lines 99-121, 566-620 for pattern extraction triggers.
Reference architect-ant.md lines 138-146 for pattern extraction workflow.

This function should be called:
- After Short-term session is created (post-compression)
- When Short-term session is about to be evicted (pre-eviction)
- Manually via Queen command
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-compress.sh

# Create test sessions with high-value items
session1='{
  "id": "test_1",
  "session_id": "test_1",
  "compressed_at": "2026-02-01T10:00:00Z",
  "original_tokens": 1000,
  "compressed_tokens": 400,
  "phase": 1,
  "summary": "Test session 1",
  "key_decisions": [],
  "outcomes": [],
  "high_value_items": [
    {"content": "Use atomic writes for state files", "relevance_score": 0.9, "type": "preference"}
  ]
}'

session2='{
  "id": "test_2",
  "session_id": "test_2",
  "compressed_at": "2026-02-01T11:00:00Z",
  "original_tokens": 1000,
  "compressed_tokens": 400,
  "phase": 2,
  "summary": "Test session 2",
  "key_decisions": [],
  "outcomes": [],
  "high_value_items": [
    {"content": "Use atomic writes for state files", "relevance_score": 0.9, "type": "preference"}
  ]
}'

create_short_term_session 1 "$session1"
create_short_term_session 2 "$session2"

# Trigger pattern extraction
trigger_pattern_extraction

# Check for patterns
jq '.long_term_memory.patterns | length' .aether/data/memory.json
jq '.metrics.total_pattern_extractions' .aether/data/memory.json
```
  </verify>
  <done>
Pattern extraction trigger finds high-value items (relevance > 0.8) and repeated patterns (3+ occurrences), moves them to Long-term Memory with appropriate confidence scoring.
  </done>
</task>

</tasks>

<verification>
1. trigger_phase_boundary_compression prepares Working Memory for Architect
2. Compressed output is processed into Short-term session
3. Working Memory is cleared after compression
4. Metrics track compression count and average ratio
5. check_token_threshold detects when at 80% capacity
6. auto_compress_if_needed triggers compression at threshold
7. trigger_pattern_extraction extracts high-value items
8. Repeated patterns (3+ occurrences) detected and stored
9. Pattern extraction metrics updated
</verification>

<success_criteria>
- Phase boundary compression works end-to-end
- Token threshold compression trigger detects 80% capacity
- Pattern extraction moves high-value items to Long-term
- Metrics track compressions and pattern extractions
- Compression ratio approximately 2.5x
</success_criteria>

<output>
After completion, create `.planning/phases/04-triple-layer-memory/04-04-SUMMARY.md` with:
- Phase boundary compression trigger implemented
- Token threshold trigger implemented
- Pattern extraction trigger implemented
- Metrics tracking verified
</output>
