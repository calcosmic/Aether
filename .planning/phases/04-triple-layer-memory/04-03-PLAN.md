---
phase: 04-triple-layer-memory
plan: 03
type: execute
wave: 3
depends_on: ["04-02"]
files_modified:
  - .aether/utils/memory-compress.sh
  - .aether/data/memory.json
autonomous: true
must_haves:
  truths:
    - "Short-term Memory evicts oldest session when exceeding 10 sessions (LRU policy)"
    - "Long-term Memory stores persistent patterns with associative links"
    - "Patterns extracted from Short-term sessions with confidence scoring"
    - "Associative links connect related items across layers (e.g., pattern in Long-term links to originating Short-term session)"
  artifacts:
    - path: ".aether/utils/memory-compress.sh"
      provides: "Short-term LRU eviction and Long-term pattern extraction"
      exports: ["evict_short_term_session", "extract_pattern_to_long_term", "extract_high_value_patterns", "create_associative_link"]
    - path: ".aether/data/memory.json"
      provides: "Long-term Memory storage"
      contains: "long_term_memory.patterns array"
  key_links:
    - from: ".aether/utils/memory-compress.sh"
      to: ".aether/data/memory.json"
      via: "jq operations on short_term_memory.sessions and long_term_memory.patterns"
      pattern: "jq.*short_term_memory|long_term_memory"
    - from: ".aether/utils/memory-compress.sh"
      to: ".aether/utils/atomic-write.sh"
      via: "atomic_write_from_file calls"
      pattern: "atomic_write_from_file"
    - from: ".aether/utils/memory-compress.sh"
      to: ".aether/data/memory.json"
      via: "associative_links array updates for cross-layer references"
      pattern: "associative_links"
---

<objective>
Implement Short-term LRU eviction (max 10 sessions), Long-term Memory pattern extraction from high-value items, and associative links for cross-layer connections.

Purpose: Short-term Memory has limited capacity (10 sessions), Long-term Memory stores persistent patterns discovered across sessions, associative links connect related items across memory layers
Output: LRU eviction for Short-term sessions, pattern extraction functions for Long-term Memory, associative link creation for cross-layer references
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-triple-layer-memory/04-RESEARCH.md

# Key Patterns to Follow
@.aether/utils/memory-compress.sh - compression functions from 04-02
@.aether/utils/memory-ops.sh - LRU pattern from 04-01
@.claude/commands/ant/init.md - jq + atomic-write pattern
@.aether/data/memory.json - Short-term and Long-term Memory schemas
@.aether/workers/architect-ant.md - pattern extraction workflow (lines 138-250)
</context>

<tasks>

<task type="auto">
  <name>Implement Short-term LRU eviction</name>
  <files>.aether/utils/memory-compress.sh</files>
  <action>
Add evict_short_term_session() function to memory-compress.sh:

**evict_short_term_session()**
- Get current_sessions count from memory.json
- If current_sessions <= max_sessions (10), return 0 (no eviction needed)
- Before evicting, check oldest session's high_value_items for patterns:
  - Call extract_high_value_patterns() on session's high_value_items
- Sort sessions by compressed_at ascending (oldest first) via jq sort_by
- Remove oldest session from short_term_memory.sessions array
- Decrement short_term_memory.current_sessions
- Increment metrics.short_term_evictions counter
- Use atomic-write.sh

Reference 04-RESEARCH.md lines 531-564 for Short-term LRU pattern.
Reference Working Memory LRU from 04-01 for similar implementation.

Eviction happens automatically when create_short_term_session would exceed 10 sessions.
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-compress.sh

# Create 11 sessions to trigger eviction
for i in {1..11}; do
  session_json="{
    \"id\": \"test_session_$i\",
    \"session_id\": \"test_session_$i\",
    \"compressed_at\": \"2026-02-01T$(printf '%02d' $i):00:00Z\",
    \"original_tokens\": 10000,
    \"compressed_tokens\": 4000,
    \"phase\": $i,
    \"summary\": \"Test session $i\",
    \"key_decisions\": [],
    \"outcomes\": [],
    \"high_value_items\": []
  }"
  create_short_term_session $i "$session_json"
  sleep 1  # Ensure different timestamps
done

# Verify only 10 sessions exist
jq '.short_term_memory.current_sessions' .aether/data/memory.json

# Verify oldest session was evicted
jq '.short_term_memory.sessions | map(.id) | sort' .aether/data/memory.json

# Verify eviction counter incremented
jq '.metrics.short_term_evictions' .aether/data/memory.json
```
  </verify>
  <done>
Short-term Memory LRU eviction removes oldest session when exceeding 10 sessions. Before eviction, high-value items are checked for pattern extraction.
  </done>
</task>

<task type="auto">
  <name>Implement Long-term pattern extraction</name>
  <files>.aether/utils/memory-compress.sh</files>
  <action>
Add pattern extraction functions to memory-compress.sh:

1. **extract_pattern_to_long_term(pattern_type, pattern_content, confidence, context, source_session_id)**
   - Generate pattern_id: "pattern_$(date +%s)_$(md5sum | cut -c1-8)"
   - Timestamp: ISO-8601 format
   - Add pattern to long_term_memory.patterns array via jq with:
     - id, type (success_pattern|failure_pattern|preference|constraint)
     - pattern (content)
     - confidence (0.0-1.0)
     - occurrences (1 for new pattern)
     - created_at, last_seen (timestamp)
     - associative_links: [] (if source_session_id provided, call create_associative_link)
     - metadata.context, related_castes: [], related_phases: []
   - Use atomic-write.sh
   - Return pattern_id

2. **extract_high_value_patterns(session_id)**
   - Get session's high_value_items from short_term_memory.sessions
   - For each item with relevance_score > 0.8:
     - Check if similar pattern exists in long_term_memory.patterns using jq contains() for text substring matching
     - Similarity check: `.pattern | ascii_downcase | contains($item_content | ascii_downcase)`
     - If exists: increment occurrences, update confidence, update last_seen
     - If not exists: call extract_pattern_to_long_term with source_session_id
   - For items appearing 3+ times across sessions (pattern detection):
     - Determine pattern_type based on content
     - Extract with higher confidence (0.5 + occurrences * 0.1, max 1.0)

Reference 04-RESEARCH.md lines 566-620 for pattern extraction pattern.
Reference architect-ant.md lines 219-250 for pattern examples.

3. **detect_patterns_across_sessions()**
   - Scan all short_term_memory.sessions for repeated patterns
   - Count occurrences of similar high_value_items using jq contains() for substring matching
   - For patterns appearing 3+ times, call extract_pattern_to_long_term
   - Update metrics.total_pattern_extractions
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-compress.sh

# Add a pattern manually
pattern_id=$(extract_pattern_to_long_term "success_pattern" "API Error Handling: Try-catch with specific exceptions" 0.9 "FastAPI endpoints" "")
echo "Created pattern: $pattern_id"

# Verify pattern in long-term memory
jq ".long_term_memory.patterns[] | select(.id == \"$pattern_id\")" .aether/data/memory.json

# Test pattern detection (add similar items to multiple sessions)
# Then run detect_patterns_across_sessions
detect_patterns_across_sessions

# Verify patterns extracted
jq '.long_term_memory.patterns | length' .aether/data/memory.json
jq '.metrics.total_pattern_extractions' .aether/data/memory.json
```
  </verify>
  <done>
Long-term Memory stores patterns extracted from high-value items. Similarity detection uses jq contains() for substring matching (case-insensitive). Patterns detected across 3+ sessions get higher confidence. Pattern types: success, failure, preference, constraint.
  </done>
</task>

<task type="auto">
  <name>Implement associative link creation</name>
  <files>.aether/utils/memory-compress.sh</files>
  <action>
Add create_associative_link() function to memory-compress.sh:

**create_associative_link(source_pattern_id, target_type, target_id, link_type)**
- Add bidirectional associative link between items across layers
- Source: pattern in Long-term Memory (pattern_id)
- Target: can be Short-term session (session_id) or Working Memory item (item_id)
- Link types: "originated_from", "related_to", "extracted_from"
- Update both source and target with cross-references:
  - For pattern: add to associative_links array
  - For target: add reverse link to its metadata

Implementation:
1. Read source pattern from long_term_memory.patterns
2. Add link to pattern's associative_links array:
   ```json
   {
     "target_id": target_id,
     "target_type": target_type,  // "short_term_session" | "working_memory_item"
     "link_type": link_type,      // "originated_from" | "extracted_from" | "related_to"
     "created_at": "ISO-8601"
   }
   ```
3. If target_type is "short_term_session":
   - Read session from short_term_memory.sessions
   - Add reverse link to session's metadata.related_patterns array
4. Use atomic-write.sh for both updates
5. Return link_id

Modify extract_pattern_to_long_term() to call create_associative_link() when source_session_id is provided, creating "extracted_from" link.

Reference MEM-07 requirement: "Associative links connect related items across layers"
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-compress.sh

# Create a pattern with session source
pattern_id=$(extract_pattern_to_long_term "preference" "Use atomic writes for state" 0.95 "Phase 1 session" "phase_1_test")

# Verify associative link created
jq ".long_term_memory.patterns[] | select(.id == \"$pattern_id\") | .associative_links" .aether/data/memory.json

# Verify reverse link in session
jq '.short_term_memory.sessions[] | select(.id == "phase_1_test") | .metadata.related_patterns' .aether/data/memory.json

# Test manual link creation
create_associative_link "$pattern_id" "short_term_session" "another_session" "related_to"

# Verify bidirectional links
jq ".long_term_memory.patterns[] | select(.id == \"$pattern_id\") | .associative_links | length" .aether/data/memory.json
```
  </verify>
  <done>
Associative links connect related items across layers bidirectionally. When pattern is extracted from Short-term session, link created with "extracted_from" type. Reverse link stored in target's metadata.related_patterns array.
  </done>
</task>

<task type="auto">
  <name>Verify Long-term Memory schema is complete</name>
  <files>.aether/data/memory.json</files>
  <action>
Verify that memory.json has complete Long-term Memory schema.

Check that long_term_memory section includes:
- patterns: [] (array to store patterns)
- pattern_schema with all required fields (id, type, pattern, confidence, occurrences, created_at, last_seen, associative_links, metadata)
- learned_preferences.focus_preferences: []
- learned_preferences.redirect_constraints: []

The schema should already exist in memory.json. Verify it's complete and matches the requirements.
  </action>
  <verify>
```bash
# Verify Long-term Memory schema
jq '.long_term_memory | has("patterns", "pattern_schema", "learned_preferences")' .aether/data/memory.json
jq '.long_term_memory.pattern_schema.type' .aether/data/memory.json
jq '.long_term_memory.pattern_schema.associative_links' .aether/data/memory.json
```
  </verify>
  <done>
Long-term Memory schema is complete with patterns array, pattern schema (id, type, pattern, confidence, occurrences, timestamps, associative_links, metadata), and learned_preferences.
  </done>
</task>

</tasks>

<verification>
1. evict_short_term_session removes oldest session when exceeding 10
2. Before eviction, high-value items are checked for patterns
3. extract_pattern_to_long_term creates patterns with full metadata
4. extract_high_value_patterns detects patterns from session items using jq contains() for similarity
5. detect_patterns_across_sessions finds repeated patterns
6. Patterns appearing 3+ times get higher confidence
7. Pattern types: success_pattern, failure_pattern, preference, constraint
8. create_associative_link creates bidirectional cross-layer links
9. Patterns extracted from sessions have "extracted_from" links
10. Long-term Memory schema verified complete
11. Metrics track pattern extractions
</verification>

<success_criteria>
- Short-term LRU eviction triggers at 10 sessions, removes oldest
- Long-term Memory receives extracted patterns from high-value items
- Pattern detection works across sessions (3+ occurrences) using substring matching
- Confidence scoring based on occurrences (0.5 + occurrences * 0.1)
- Associative links connect patterns to originating sessions (bidirectional)
- Reverse links stored in target metadata for cross-layer navigation
</success_criteria>

<output>
After completion, create `.planning/phases/04-triple-layer-memory/04-03-SUMMARY.md` with:
- Short-term LRU eviction implemented
- Long-term pattern extraction implemented with similarity detection
- Associative link creation implemented for cross-layer references
- Schema verification complete
</output>
