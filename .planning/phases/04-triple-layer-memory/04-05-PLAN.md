---
phase: 04-triple-layer-memory
plan: 05
type: execute
wave: 5
depends_on: ["04-01", "04-02", "04-03", "04-04"]
files_modified:
  - .aether/utils/memory-search.sh
  - .claude/commands/ant/memory.md
autonomous: true
must_haves:
  truths:
    - "Queen can query memory and get ranked results from all three layers"
    - "Cross-layer search returns results ranked by relevance and recency"
    - "Context window never exceeds 200k tokens (compression at 80% prevents overflow)"
  artifacts:
    - path: ".aether/utils/memory-search.sh"
      provides: "Cross-layer search functions"
      exports: ["search_memory", "search_working_memory", "search_short_term_memory", "search_long_term_memory"]
    - path: ".claude/commands/ant/memory.md"
      provides: "Queen command for memory operations"
      contains: "search, status, compress subcommands"
  key_links:
    - from: ".claude/commands/ant/memory.md"
      to: ".aether/utils/memory-search.sh"
      via: "source and function calls"
      pattern: "source.*memory-search.sh"
    - from: ".aether/utils/memory-search.sh"
      to: ".aether/data/memory.json"
      via: "jq queries on all three memory layers"
      pattern: "jq.*working_memory|short_term_memory|long_term_memory"
---

<objective>
Implement cross-layer search with relevance ranking and Queen command for memory operations (search, status, compress).

Purpose: Queen can query memory and retrieve ranked results from all three layers, see memory status, and trigger manual compression
Output: Memory search functions with exact/contains match ranking, /ant:memory command for Queen interaction, 200k limit verification
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-triple-layer-memory/04-RESEARCH.md

# Key Patterns to Follow
@.aether/utils/memory-ops.sh - Working Memory functions (04-01)
@.aether/utils/memory-compress.sh - Compression functions (04-02, 04-03, 04-04)
@.claude/commands/ant/init.md - command pattern (jq + atomic-write)
@.claude/commands/ant/focus.md - command with subcommands pattern
@.aether/data/memory.json - all three memory layers
</context>

<tasks>

<task type="auto">
  <name>Implement cross-layer search functions</name>
  <files>.aether/utils/memory-search.sh</files>
  <action>
Create .aether/utils/memory-search.sh with search functions:

1. **search_memory(query, [limit])**
   - Search all three layers in parallel
   - Combine results with relevance ranking
   - Working Memory: exact match = 1.0, contains match = 0.7 (most recent first)
   - Short-term: exact match in summary = 1.0, contains match = 0.7
   - Long-term: relevance = pattern.confidence
   - Sort by: layer (working first), then relevance (descending), then recency
   - Return combined ranked results (default max 20 per layer)
   - Format: {layer, id, content, relevance, timestamp}

2. **search_working_memory(query, [limit])**
   - Search working_memory.items[].content for query
   - Use case-insensitive matching: `ascii_downcase | contains($query | ascii_downcase)`
   - For exact match (content equals query): relevance = 1.0
   - For contains match (content contains query): relevance = 0.7
   - Update access_count and last_accessed for matched items
   - Return matches sorted by relevance (descending), then last_accessed (descending)

3. **search_short_term_memory(query, [limit])**
   - Search short_term_memory.sessions[].summary for query
   - Search key_decisions[].decision and outcomes[].result arrays
   - Use case-insensitive matching: `ascii_downcase | contains($query | ascii_downcase)`
   - For exact match: relevance = 1.0
   - For contains match: relevance = 0.7
   - Return matches with relevance score

4. **search_long_term_memory(query, [limit])**
   - Search long_term_memory.patterns[].pattern for query
   - Use case-insensitive matching: `ascii_downcase | contains($query | ascii_downcase)`
   - Return matches with relevance = pattern.confidence
   - Sort by confidence (descending)

Reference 04-RESEARCH.md lines 494-529 for cross-layer search pattern.

Ranking algorithm:
- Exact match (content equals query): 1.0
- Contains match (content includes query): 0.7
- Long-term patterns: use pattern's confidence score
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-search.sh

# Add test data to Working Memory
source .aether/utils/memory-ops.sh
add_working_memory_item "Decision: Use PostgreSQL for database" "decision" 0.9
add_working_memory_item "API authentication implemented with JWT" "observation" 0.7

# Test Working Memory search
search_working_memory "PostgreSQL"
search_working_memory "authentication"
search_working_memory "decision"

# Test exact vs contains ranking
# "PostgreSQL" should rank higher (exact/contains) vs partial matches

# Test cross-layer search
search_memory "PostgreSQL"
search_memory "decision"

# Test with limit
search_memory "PostgreSQL" 5
```
  </verify>
  <done>
Cross-layer search queries all three memory layers, returns combined results ranked by layer priority (working first) and relevance score (exact=1.0, contains=0.7). Updates access metadata for Working Memory hits.
  </done>
</task>

<task type="auto">
  <name>Create memory status function</name>
  <files>.aether/utils/memory-search.sh</files>
  <action>
Add get_memory_status() function to memory-search.sh:

**get_memory_status()**
- Return formatted memory statistics:
  - Working Memory: items count, current tokens, max tokens, % used
  - Short-term: sessions count, max sessions, % used
  - Long-term: patterns count
  - Metrics: total compressions, avg ratio, evictions, pattern extractions
- Format as human-readable output with sections and stats
- Show 200k token limit for Working Memory

Format:
```
MEMORY STATUS

Working Memory:
  Items: {count}
  Tokens: {current} / {max} (200,000) ({percent}%)
  Eviction Threshold: {threshold} tokens (80%)
  Max Capacity: 200,000 tokens (hard limit)

Short-term Memory:
  Sessions: {current} / {max} ({percent}%)
  Compression Ratio: 2.5x target

Long-term Memory:
  Patterns: {count}
  Types: success={n}, failure={n}, preference={n}, constraint={n}

Metrics:
  Total Compressions: {n}
  Average Compression Ratio: {ratio}
  Working Memory Evictions: {n}
  Short-term Evictions: {n}
  Pattern Extractions: {n}
```

Include explicit 200k token limit in output for verification.
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-search.sh

# Get memory status
get_memory_status

# Verify output has all sections
get_memory_status | grep "Working Memory:"
get_memory_status | grep "Short-term Memory:"
get_memory_status | grep "Long-term Memory:"
get_memory_status | grep "Metrics:"

# Verify 200k limit is shown
get_memory_status | grep "200,000"
get_memory_status | grep "Max Capacity"
```
  </verify>
  <done>
get_memory_status returns formatted statistics for all three memory layers and system metrics, showing usage percentages and 200k token limit for Working Memory.
  </done>
</task>

<task type="auto">
  <name>Implement 200k token limit verification</name>
  <files>.aether/utils/memory-search.sh</files>
  <action>
Add verify_token_limit() function to memory-search.sh:

**verify_token_limit()**
- Verify Working Memory never exceeds 200k tokens
- Check: working_memory.max_capacity_tokens == 200000
- Check: working_memory.current_tokens <= 200000
- Check: Compression triggers at 80% (160k) to prevent overflow
- Return 0 if all checks pass, 1 if any violation detected
- Output verification result:
  ```
  TOKEN LIMIT VERIFICATION
  Max Capacity: 200,000 tokens
  Current Usage: {current} tokens ({percent}%)
  Compression Threshold: 160,000 tokens (80%)
  Status: PASS - Current usage within safe limits
  ```
- If current_tokens > 200000: Status: FAIL - Exceeded hard limit
- If current_tokens > 160000: Status: WARNING - Approaching compression threshold

This function proves the 200k token limit is enforced by compression at 80%.

Reference 04-RESEARCH.md for token limit requirements (Working Memory max 200k).
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-search.sh

# Verify token limit
verify_token_limit
echo "Verification result: $?"

# Verify max capacity is 200k
jq '.working_memory.max_capacity_tokens' .aether/data/memory.json

# Verify current tokens within limit
jq '.working_memory.current_tokens <= 200000' .aether/data/memory.json

# Verify compression threshold is 80%
max=$(jq '.working_memory.max_capacity_tokens' .aether/data/memory.json)
threshold=$((max * 80 / 100))
echo "Compression threshold: $threshold tokens"
echo "Expected: 160000 tokens (80% of 200k)"
```
  </verify>
  <done>
verify_token_limit() confirms Working Memory max_capacity_tokens=200k and current_tokens never exceeds this limit. Compression at 80% (160k) prevents overflow.
  </done>
</task>

<task type="auto">
  <name>Create /ant:memory command</name>
  <files>.claude/commands/ant/memory.md</files>
  <action>
Create .claude/commands/ant/memory.md following the pattern from init.md and focus.md:

Command structure:
- `/ant:memory search "<query>"` - Search all memory layers
- `/ant:memory status` - Show memory statistics
- `/ant:memory verify` - Verify 200k token limit
- `/ant:memory compress` - Manual compression trigger

For each subcommand:
1. **search**: Call search_memory() with query, display results
2. **status**: Call get_memory_status(), display formatted output
3. **verify**: Call verify_token_limit(), display limit verification
4. **compress**: Call trigger_phase_boundary_compression() with current phase

Command format should match init.md structure:
- name: ant:memory
- description: Colony memory operations (search, status, verify, compress)
- <objective> section
- <process> section with step-by-step instructions
- <context> section with file locations
- <allowed-tools> section

Include:
- Argument parsing for subcommands
- Error handling for invalid subcommands
- Help text showing available subcommands
- Integration with memory-search.sh and memory-compress.sh
- Note that 200k limit is enforced by compression at 80%
  </action>
  <verify>
```bash
# Test command (via the command system)
# This would be tested by running the actual command

# Verify command file exists and is valid
cat .claude/commands/ant/memory.md
grep -q "name: ant:memory" .claude/commands/ant/memory.md
grep -q "search.*status.*verify.*compress" .claude/commands/ant/memory.md
grep -q "200,000 token" .claude/commands/ant/memory.md
```
  </verify>
  <done>
/ant:memory command provides search, status, verify, and compress subcommands. Queen can query memory, view statistics, verify 200k limit, and trigger manual compression.
  </done>
</task>

</tasks>

<verification>
1. search_memory queries all three layers
2. Results ranked by layer (working first) and relevance (exact=1.0, contains=0.7)
3. search_working_memory updates access metadata
4. Ranking algorithm correctly assigns exact=1.0, contains=0.7
5. get_memory_status shows all statistics including 200k limit
6. verify_token_limit() confirms max_capacity_tokens=200000
7. verify_token_limit() confirms current_tokens <= 200000
8. verify_token_limit() confirms compression at 80% prevents overflow
9. /ant:memory command works for all subcommands
10. Search returns formatted, readable results
11. Status shows usage percentages and 200k limit
12. Manual compression trigger works
13. Context window verified under 200k tokens
</verification>

<success_criteria>
- Cross-layer search returns ranked results from all layers
- Ranking algorithm: exact match = 1.0, contains match = 0.7
- Working Memory search updates access metadata
- Memory status shows comprehensive statistics with 200k limit
- verify_token_limit() confirms max_capacity_tokens=200000 and enforcement
- /ant:memory command provides all four subcommands (search, status, verify, compress)
- Context window never exceeds 200k tokens (compression at 80% prevents overflow)
</success_criteria>

<output>
After completion, create `.planning/phases/04-triple-layer-memory/04-05-SUMMARY.md` with:
- Cross-layer search implemented with exact/contains ranking
- Memory status function implemented with 200k limit display
- Token limit verification function implemented
- /ant:memory command created with all subcommands
- 200k token limit verified (max_capacity_tokens=200000, compression at 80% enforces limit)
- All verification tests passed
</output>
