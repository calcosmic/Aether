---
phase: 04-triple-layer-memory
plan: 05
type: execute
wave: 5
depends_on: ["04-01", "04-02", "04-03", "04-04"]
files_modified:
  - .aether/utils/memory-search.sh
  - .claude/commands/ant/memory.md
autonomous: true
must_haves:
  truths:
    - "Queen can query memory and get ranked results from all three layers"
    - "Cross-layer search returns results ranked by relevance and recency"
    - "Context window never exceeds 200k tokens (compression prevents overflow)"
  artifacts:
    - path: ".aether/utils/memory-search.sh"
      provides: "Cross-layer search functions"
      exports: ["search_memory", "search_working_memory", "search_short_term_memory", "search_long_term_memory"]
    - path: ".claude/commands/ant/memory.md"
      provides: "Queen command for memory operations"
      contains: "search, status, compress subcommands"
  key_links:
    - from: ".claude/commands/ant/memory.md"
      to: ".aether/utils/memory-search.sh"
      via: "source and function calls"
      pattern: "source.*memory-search.sh"
    - from: ".aether/utils/memory-search.sh"
      to: ".aether/data/memory.json"
      via: "jq queries on all three memory layers"
      pattern: "jq.*working_memory|short_term_memory|long_term_memory"
---

<objective>
Implement cross-layer search with relevance ranking and Queen command for memory operations (search, status, compress).

Purpose: Queen can query memory and retrieve ranked results from all three layers, see memory status, and trigger manual compression
Output: Memory search functions and /ant:memory command for Queen interaction
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-triple-layer-memory/04-RESEARCH.md

# Key Patterns to Follow
@.aether/utils/memory-ops.sh - Working Memory functions (04-01)
@.aether/utils/memory-compress.sh - Compression functions (04-02, 04-03, 04-04)
@.claude/commands/ant/init.md - command pattern (jq + atomic-write)
@.claude/commands/ant/focus.md - command with subcommands pattern
@.aether/data/memory.json - all three memory layers
</context>

<tasks>

<task type="auto">
  <name>Implement cross-layer search functions</name>
  <files>.aether/utils/memory-search.sh</files>
  <action>
Create .aether/utils/memory-search.sh with search functions:

1. **search_memory(query, [limit])**
   - Search all three layers in parallel
   - Combine results with relevance ranking
   - Working Memory: relevance = 1.0 (exact matches, most recent)
   - Short-term: relevance = 0.7 (summary matches)
   - Long-term: relevance = pattern.confidence
   - Sort by: layer (working first), then relevance (descending), then recency
   - Return combined ranked results (default max 20 per layer)
   - Format: {layer, id, content, relevance, timestamp}

2. **search_working_memory(query, [limit])**
   - Search working_memory.items[].content for query
   - Use case-insensitive contains match
   - Update access_count and last_accessed for matched items
   - Return matches with relevance = 1.0

3. **search_short_term_memory(query, [limit])**
   - Search short_term_memory.sessions[].summary
   - Search key_decisions and outcomes arrays
   - Return matches with relevance = 0.7

4. **search_long_term_memory(query, [limit])**
   - Search long_term_memory.patterns[].pattern
   - Return matches with relevance = pattern.confidence
   - Sort by confidence (descending)

Reference 04-RESEARCH.md lines 494-529 for cross-layer search pattern.

Use jq contains for text matching. Case-insensitive: ascii_downcase | contains($query | ascii_downcase).
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-search.sh

# Add test data to Working Memory
source .aether/utils/memory-ops.sh
add_working_memory_item "Decision: Use PostgreSQL for database" "decision" 0.9
add_working_memory_item "API authentication implemented with JWT" "observation" 0.7

# Test Working Memory search
search_working_memory "PostgreSQL"
search_working_memory "authentication"

# Test cross-layer search
search_memory "PostgreSQL"
search_memory "decision"

# Test with limit
search_memory "PostgreSQL" 5
```
  </verify>
  <done>
Cross-layer search queries all three memory layers, returns combined results ranked by layer priority (working first) and relevance score. Updates access metadata for Working Memory hits.
  </done>
</task>

<task type="auto">
  <name>Create memory status function</name>
  <files>.aether/utils/memory-search.sh</files>
  <action>
Add get_memory_status() function to memory-search.sh:

**get_memory_status()**
- Return formatted memory statistics:
  - Working Memory: items count, current tokens, max tokens, % used
  - Short-term: sessions count, max sessions, % used
  - Long-term: patterns count
  - Metrics: total compressions, avg ratio, evictions, pattern extractions
- Format as human-readable output with sections and stats

Format:
```
MEMORY STATUS

Working Memory:
  Items: {count}
  Tokens: {current} / {max} ({percent}%)
  Eviction Threshold: {threshold} tokens (80%)

Short-term Memory:
  Sessions: {current} / {max} ({percent}%)
  Compression Ratio: 2.5x target

Long-term Memory:
  Patterns: {count}
  Types: success={n}, failure={n}, preference={n}, constraint={n}

Metrics:
  Total Compressions: {n}
  Average Compression Ratio: {ratio}
  Working Memory Evictions: {n}
  Short-term Evictions: {n}
  Pattern Extractions: {n}
```
  </action>
  <verify>
```bash
# Source and test
source .aether/utils/memory-search.sh

# Get memory status
get_memory_status

# Verify output has all sections
get_memory_status | grep "Working Memory:"
get_memory_status | grep "Short-term Memory:"
get_memory_status | grep "Long-term Memory:"
get_memory_status | grep "Metrics:"
```
  </verify>
  <done>
get_memory_status returns formatted statistics for all three memory layers and system metrics, showing usage percentages and compression performance.
  </done>
</task>

<task type="auto">
  <name>Create /ant:memory command</name>
  <files>.claude/commands/ant/memory.md</files>
  <action>
Create .claude/commands/ant/memory.md following the pattern from init.md and focus.md:

Command structure:
- `/ant:memory search "<query>"` - Search all memory layers
- `/ant:memory status` - Show memory statistics
- `/ant:memory compress` - Manual compression trigger

For each subcommand:
1. **search**: Call search_memory() with query, display results
2. **status**: Call get_memory_status(), display formatted output
3. **compress**: Call trigger_phase_boundary_compression() with current phase

Command format should match init.md structure:
- name: ant:memory
- description: Colony memory operations (search, status, compress)
- <objective> section
- <process> section with step-by-step instructions
- <context> section with file locations
- <allowed-tools> section

Include:
- Argument parsing for subcommands
- Error handling for invalid subcommands
- Help text showing available subcommands
- Integration with memory-search.sh and memory-compress.sh
  </action>
  <verify>
```bash
# Test command (via the command system)
# This would be tested by running the actual command

# Verify command file exists and is valid
cat .claude/commands/ant/memory.md
grep -q "name: ant:memory" .claude/commands/ant/memory.md
grep -q "search.*status.*compress" .claude/commands/ant/memory.md
```
  </verify>
  <done>
/ant:memory command provides search, status, and compress subcommands. Queen can query memory, view statistics, and trigger manual compression.
  </done>
</task>

</tasks>

<verification>
1. search_memory queries all three layers
2. Results ranked by layer (working first) and relevance
3. search_working_memory updates access metadata
4. get_memory_status shows all statistics
5. /ant:memory command works for all subcommands
6. Search returns formatted, readable results
7. Status shows usage percentages
8. Manual compression trigger works
9. Context window verified under 200k tokens
</verification>

<success_criteria>
- Cross-layer search returns ranked results from all layers
- Working Memory search updates access metadata
- Memory status shows comprehensive statistics
- /ant:memory command provides all three subcommands
- Context window never exceeds 200k tokens (compression at 80% prevents overflow)
</success_criteria>

<output>
After completion, create `.planning/phases/04-triple-layer-memory/04-05-SUMMARY.md` with:
- Cross-layer search implemented
- Memory status function implemented
- /ant:memory command created
- All verification tests passed
</output>
