---
phase: 07-colony-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .aether/data/watcher_weights.json
  - .aether/data/COLONY_STATE.json
  - .aether/utils/vote-aggregator.sh
  - .aether/utils/issue-deduper.sh
  - .aether/utils/weight-calculator.sh
autonomous: true

must_haves:
  truths:
    - "Colony can aggregate votes from 4 Watchers into unified decision"
    - "Supermajority calculation (67% threshold) works correctly"
    - "Critical veto power blocks approval despite supermajority"
    - "Issues are deduplicated when multiple Watchers report same issue"
    - "Watcher weights persist across sessions in watcher_weights.json"
    - "Vote recording stores verification events for meta-learning"
  artifacts:
    - path: ".aether/data/watcher_weights.json"
      provides: "Watcher reliability weights for belief calibration"
      contains: "watcher_weights with security, performance, quality, test_coverage at 1.0"
    - path: ".aether/utils/vote-aggregator.sh"
      provides: "Vote aggregation and supermajority calculation"
      exports: ["calculate_supermajority", "record_vote_outcome", "aggregate_votes"]
    - path: ".aether/utils/issue-deduper.sh"
      provides: "Issue deduplication and prioritization"
      exports: ["dedupe_and_prioritize", "create_fingerprint", "sort_by_severity"]
    - path: ".aether/utils/weight-calculator.sh"
      provides: "Belief calibration weight updates"
      exports: ["update_watcher_weight", "get_watcher_weight", "clamp_weight"]
    - path: ".aether/data/COLONY_STATE.json"
      provides: "Verification section for vote history"
      contains: "verification.votes, verification.last_updated"
  key_links:
    - from: "vote-aggregator.sh"
      to: "watcher_weights.json"
      via: "jq reads Watcher weights for supermajority calculation"
      pattern: "jq.*watcher_weights"
    - from: "vote-aggregator.sh"
      to: "COLONY_STATE.json"
      via: "atomic_write for vote recording"
      pattern: "atomic_write.*COLONY_STATE"
    - from: "issue-deduper.sh"
      to: "vote files"
      via: "jq processes vote JSON arrays"
      pattern: "jq -s '.\\|.*issues'"
    - from: "weight-calculator.sh"
      to: "watcher_weights.json"
      via: "atomic_write updates Watcher weights after phase outcome"
      pattern: "atomic_write.*watcher_weights"
---

<objective>
Build the vote aggregation infrastructure for multi-perspective verification. This creates the core utilities that aggregate votes from 4 parallel Watchers, calculate supermajority with Critical veto power, deduplicate issues, and manage belief calibration weights.

Purpose: Enable the colony to make verification decisions based on weighted voting from multiple perspectives, with Critical severity issues having veto power regardless of vote counts.

Output: Three bash utilities (vote-aggregator.sh, issue-deduper.sh, weight-calculator.sh), watcher_weights.json data file, and verification section in COLONY_STATE.json.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/07-colony-verification**---multi-perspective-verification-with-weighted-voting-and-belief-calibration/07-CONTEXT.md
@.planning/phases/07-colony-verification**---multi-perspective-verification-with-weighted-voting-and-belief-calibration/07-RESEARCH.md
@.aether/utils/spawn-tracker.sh
@.aether/utils/atomic-write.sh
@.aether/utils/file-lock.sh
@.aether/data/COLONY_STATE.json
@.aether/workers/watcher-ant.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create watcher_weights.json schema and initialize weights</name>
  <files>.aether/data/watcher_weights.json</files>
  <action>
Create watcher_weights.json with schema:

{
  "watcher_weights": {
    "security": 1.0,
    "performance": 1.0,
    "quality": 1.0,
    "test_coverage": 1.0
  },
  "weight_bounds": {
    "min": 0.1,
    "max": 3.0
  },
  "created_at": "{ISO_8601_timestamp}",
  "last_updated": "{ISO_8601_timestamp}"
}

All 4 Watchers start at equal weight (1.0) per CONTEXT.md decision.
Use date -u +"%Y-%m-%dT%H:%M:%SZ" for timestamps.

Location: .aether/data/watcher_weights.json
  </action>
  <verify>jq . .aether/data/watcher_weights.json | grep -q "security" && echo "Schema valid"</verify>
  <done>watcher_weights.json exists with all 4 Watcher weights at 1.0, min/max bounds defined</done>
</task>

<task type="auto">
  <name>Task 2: Create vote-aggregator.sh with supermajority calculation</name>
  <files>.aether/utils/vote-aggregator.sh</files>
  <action>
Create .aether/utils/vote-aggregator.sh following spawn-tracker.sh pattern:

**Functions to implement:**

1. calculate_supermajority(votes_file):
   - Combines all vote JSON files into array
   - Checks for Critical veto FIRST (any Critical severity REJECT blocks approval)
   - Calculates weighted approval percentage
   - Returns "APPROVED" if >= 67%, "REJECTED" otherwise
   - Uses bc for floating-point division

2. record_vote_outcome(watcher, decision, issues, verification_id):
   - Records vote in COLONY_STATE.json verification.votes array
   - Uses atomic_write for safe updates
   - Sets outcome to "pending" (updated after phase completes)
   - Timestamp in ISO 8601 format

3. aggregate_votes(votes_dir):
   - Combines all vote JSON files in directory
   - Validates exactly 4 votes present
   - Returns combined JSON array

**Shebang:** #!/bin/bash
**Source dependencies:** atomic-write.sh, file-lock.sh (from spawn-tracker.sh pattern)
**Configuration:**
   - COLONY_STATE_FILE="$AETHER_ROOT/.aether/data/COLONY_STATE.json"
   - WATCHER_WEIGHTS_FILE="$AETHER_ROOT/.aether/data/watcher_weights.json"
   - SUPERMAJORITY_THRESHOLD=67

**Critical veto check (before supermajority):**
```bash
has_critical=$(jq '
    [.[] | select(.decision == "REJECT")] |
    any(.issues[]?; .severity == "Critical")
' "$votes_file")
if [ "$has_critical" == "true" ]; then
    echo "REJECTED (Critical veto)"
    return 1
fi
```

**Supermajority calculation:**
```bash
approve_weight=$(jq '[.[] | select(.decision == "APPROVE")] | map(.weight) | add // 0' "$votes_file")
total_weight=$(jq '[.[] | .weight] | add' "$votes_file")
percentage=$(echo "scale=2; $approve_weight / $total_weight * 100" | bc)
```

**Export functions:** calculate_supermajority, record_vote_outcome, aggregate_votes
  </action>
  <verify>
source .aether/utils/vote-aggregator.sh && declare -f calculate_supermajority | grep -q "calculate_supermajority"
bash -n .aether/utils/vote-aggregator.sh && echo "Syntax valid"
  </verify>
  <done>vote-aggregator.sh with 3 functions, Critical veto check, supermajority calculation, atomic writes</done>
</task>

<task type="auto">
  <name>Task 3: Create issue-deduper.sh for issue aggregation</name>
  <files>.aether/utils/issue-deduper.sh</files>
  <action>
Create .aether/utils/issue-deduper.sh:

**Functions to implement:**

1. create_fingerprint(issue_description, category, location):
   - Generates SHA256 hash of description+category+location
   - Returns hex string fingerprint
   - Use: echo "${desc}${cat}${loc}" | sha256sum | cut -d' ' -f1

2. dedupe_and_prioritize(votes_file):
   - Extracts all issues from all votes
   - Creates fingerprint for each issue
   - Groups by fingerprint (deduping)
   - Takes highest severity among duplicates
   - Tags as "Multiple Watchers" or "Single Watcher"
   - Sorts by severity (Critical first) then total_weight
   - Returns aggregated issue array

**jq logic for deduping:**
```jq
[.[] | .issues[]? as $issue | {
    description: $issue.description,
    severity: $issue.severity,
    category: $issue.category,
    location: $issue.location,
    watcher: .watcher,
    watcher_weight: .weight
}] |
map(.fingerprint = (.description + .category + .location | @sha)) |
group_by(.fingerprint) |
map({
    description: .[0].description,
    severity: (map(.severity) | max_by(["Critical", "High", "Medium", "Low"])),
    category: .[0].category,
    location: .[0].location,
    watchers: map(.watcher) | unique | join(", "),
    total_weight: map(.watcher_weight) | add,
    tag: (if length > 1 then "Multiple Watchers" else "Single Watcher" end)
}) |
sort_by(.severity, .total_weight) | reverse
```

**Severity order for max_by:** Critical > High > Medium > Low

**Shebang:** #!/bin/bash
**Export functions:** create_fingerprint, dedupe_and_prioritize
  </action>
  <verify>
source .aether/utils/issue-deduper.sh && declare -f dedupe_and_prioritize | grep -q "dedupe_and_prioritize"
bash -n .aether/utils/issue-deduper.sh && echo "Syntax valid"
  </verify>
  <done>issue-deduper.sh creates fingerprints, groups by fingerprint, takes max severity, tags multi-watcher issues, sorts by severity/weight</done>
</task>

<task type="auto">
  <name>Task 4: Create weight-calculator.sh for belief calibration</name>
  <files>.aether/utils/weight-calculator.sh</files>
  <action>
Create .aether/utils/weight-calculator.sh:

**Functions to implement:**

1. get_watcher_weight(watcher_type):
   - Reads current weight from watcher_weights.json
   - Returns numeric value (not JSON)

2. clamp_weight(weight):
   - Ensures weight is within [0.1, 3.0] bounds
   - Uses bc for comparison
   - Returns clamped value
   - Logic: echo "scale=1; $weight < 0.1 ? 0.1 : ($weight > 3.0 ? 3.0 : $weight)" | bc

3. update_watcher_weight(watcher_type, vote_outcome, issue_category):
   - Reads current weight from watcher_weights.json
   - Applies asymmetric increment/decrement based on vote_outcome:
     * correct_approve: +0.1
     * correct_reject: +0.15
     * incorrect_approve: -0.2
     * incorrect_reject: -0.1
   - Clamps to [0.1, 3.0] range
   - Applies domain expertise bonus (×2) if issue_category == watcher_type
   - Atomic writes updated watcher_weights.json
   - Updates last_updated timestamp

**Domain expertise bonus:**
```bash
if [ "$issue_category" == "$watcher_type" ]; then
    new_weight=$(echo "$new_weight * 2" | bc)
fi
```

**Shebang:** #!/bin/bash
**Source dependencies:** atomic-write.sh
**Configuration:** WATCHER_WEIGHTS_FILE="$AETHER_ROOT/.aether/data/watcher_weights.json"
**Export functions:** get_watcher_weight, clamp_weight, update_watcher_weight

**Note:** This function is called AFTER phase completes, not during voting. Phase 7 records votes with outcome="pending", Phase 8 updates weights based on actual outcome.
  </action>
  <verify>
source .aether/utils/weight-calculator.sh && declare -f update_watcher_weight | grep -q "update_watcher_weight"
bash -n .aether/utils/weight-calculator.sh && echo "Syntax valid"
  </verify>
  <done>weight-calculator.sh reads weights, applies asymmetric updates, clamps to bounds, applies domain bonus, atomic writes</done>
</task>

<task type="auto">
  <name>Task 5: Add verification section to COLONY_STATE.json schema</name>
  <files>.aether/data/COLONY_STATE.json</files>
  <action>
Add verification section to COLONY_STATE.json after meta_learning section:

```json
"verification": {
  "votes": [],
  "verification_history": [],
  "last_updated": null
}
```

Use jq to add this section atomically:

```bash
updated=$(jq '
    .verification = {
        votes: [],
        verification_history: [],
        last_updated: null
    }
' .aether/data/COLONY_STATE.json)

atomic_write ".aether/data/COLONY_STATE.json" "$updated"
```

The votes array stores each Watcher's vote with:
- id: verification event UUID
- watcher: security, performance, quality, test_coverage
- decision: APPROVE or REJECT
- issues: array of issue objects
- timestamp: ISO 8601
- outcome: pending, correct_approve, correct_reject, incorrect_approve, incorrect_reject

The verification_history tracks overall verification events (aggregated results).
  </action>
  <verify>jq .verification .aether/data/COLONY_STATE.json | grep -q "votes"</verify>
  <done>COLONY_STATE.json has verification section with votes array, verification_history, last_updated</done>
</task>

</tasks>

<verification>
1. Test supermajority calculation:
   - Create test votes file with 4 APPROVE votes → should return APPROVED
   - Create test votes with 3 APPROVE, 1 REJECT → should return APPROVED (75% >= 67%)
   - Create test votes with 2 APPROVE, 2 REJECT → should return REJECTED (50% < 67%)

2. Test Critical veto:
   - Create votes with 3 APPROVE, 1 REJECT with Critical severity → should return REJECTED (veto)

3. Test issue deduping:
   - Create votes with duplicate issues from multiple Watchers → should dedupe and tag "Multiple Watchers"

4. Test weight calculator:
   - Test weight clamping at bounds (0.1 and 3.0)
   - Test asymmetric updates (correct_reject +0.15, incorrect_approve -0.2)

5. Verify all utilities source correctly and functions are exported
</verification>

<success_criteria>
1. watcher_weights.json exists with 4 Watcher weights initialized to 1.0
2. vote-aggregator.sh calculates supermajority correctly with Critical veto check
3. issue-deduper.sh fingerprints and dedupes issues, sorts by severity/weight
4. weight-calculator.sh applies asymmetric updates, clamps to bounds, applies domain bonus
5. COLONY_STATE.json has verification section for vote history
6. All utilities use atomic-write.sh and follow spawn-tracker.sh patterns
7. Bash syntax is valid (no errors when sourced)
8. All functions are properly exported
</success_criteria>

<output>
After completion, create `.planning/phases/07-colony-verification---multi-perspective-verification-with-weighted-voting-and-belief-calibration/07-01-SUMMARY.md` with:
- Files created (3 utilities, 1 data file, 1 schema update)
- Vote aggregation infrastructure ready for Watcher prompts
- Wave 1 complete, ready for Wave 2 (Watcher prompt creation)
</output>
