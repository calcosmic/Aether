---
phase: 09-stigmergic-events
plan: 06
type: execute
wave: 3
depends_on: [09-02, 09-04]
files_modified:
  - .aether/utils/event-bus.sh
  - .aether/data/events.json
autonomous: true

must_haves:
  truths:
    - "publish_event() returns immediately after writing to event_log"
    - "No waiting for subscribers to process events"
    - "Subscribers poll independently when they execute"
    - "No background processes or daemons required"
    - "Event delivery is decoupled from event publishing"
    - "Multiple Worker Ants can publish concurrently without blocking"
  artifacts:
    - path: ".aether/utils/event-bus.sh"
      provides: "Non-blocking async publish operation"
      exports: ["publish_event"]
    - path: ".aether/data/events.json"
      provides: "Event log for pull-based delivery"
      contains: ["event_log array", "subscriptions with delivery tracking"]
  key_links:
    - from: "publish_event()"
      to: ".aether/data/events.json"
      via: "Writes event and returns immediately (no subscriber notification)"
      pattern: "echo.*event_id.*return 0"
    - from: "publish_event()"
      to: "get_events_for_subscriber()"
      via: "Decoupled: publish writes, subscriber polls (no direct call)"
      pattern: "publish_event.*does not call.*get_events_for_subscriber"
---

<objective>
Verify and document async non-blocking event delivery

Purpose: Confirm that publish_event() implements true async semantics (returns immediately after write, no waiting for subscribers). This is optimal for Aether's prompt-based Worker Ants that are not persistent processes. Subscribers poll for events independently when they execute.

Output: Documentation and tests confirming non-blocking async publish behavior
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-stigmergic-events/09-RESEARCH.md
@.planning/phases/09-stigmergic-events/09-02-PLAN.md
@.planning/phases/09-stigmergic-events/09-04-PLAN.md

# Existing utilities to integrate
.aether/utils/event-bus.sh (from 09-02 with publish_event)
.aether/utils/atomic-write.sh
.aether/utils/file-lock.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify publish_event() is non-blocking and document async behavior</name>
  <files>.aether/utils/event-bus.sh</files>
  <action>
Review and verify publish_event() function from 09-02 is truly non-blocking:

1. Verify publish_event() does NOT call subscriber code
2. Verify publish_event() does NOT wait for subscribers
3. Verify publish_event() returns immediately after write

Add documentation header to event-bus.sh explaining async behavior:

```bash
#!/bin/bash
# Aether Event Bus Utility
# Implements pub/sub event system for colony-wide coordination
#
# ## Async Non-Blocking Design
#
# The event bus uses pull-based delivery for optimal compatibility with
# prompt-based Worker Ants (which are not persistent processes):
#
# - **Publish**: Worker Ants publish events via publish_event()
#   - Writes event to events.json event_log
#   - Returns immediately with event_id (non-blocking)
#   - Does NOT wait for subscribers
#   - Does NOT call subscriber code
#
# - **Subscribe**: Worker Ants register interest via subscribe_to_events()
#   - Records subscription in events.json
#   - Returns subscription_id
#
# - **Deliver**: Worker Ants poll for events via get_events_for_subscriber()
#   - Returns events matching subscriptions since last poll
#   - Worker Ant processes events when they execute
#   - Marks events as delivered via mark_events_delivered()
#
# This design provides true async semantics:
# - Publishers and subscribers are decoupled
# - No background processes or daemons required
# - Works naturally with prompt-based agents (execute, poll, exit)
# - Concurrent publishes safe (file locking prevents corruption)
#
# Usage:
#   source .aether/utils/event-bus.sh
#   initialize_event_bus
#   publish_event "topic" "type" '{"data": "value"}' "publisher" "caste"
#   subscribe_to_events "subscriber_id" "caste" "topic_pattern" '{}'
#   events=$(get_events_for_subscriber "subscriber_id" "caste")
#   mark_events_delivered "subscriber_id" "caste" "$events"

# Event bus storage file
EVENTS_FILE="$(git rev-parse --show-toplevel 2>/dev/null || echo "$PWD")/.aether/data/events.json"

# Source required utilities
SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
source "${SCRIPT_DIR}/atomic-write.sh"
source "${SCRIPT_DIR}/file-lock.sh"
```

Key points to verify:
1. publish_event() only writes to events.json and returns event_id
2. No call to get_events_for_subscriber() or any subscriber notification
3. No background process spawning
4. No waiting or sleep operations
5. Return happens immediately after atomic_write_from_file

The existing implementation from 09-02 should already be non-blocking. This task verifies and documents that behavior.
  </action>
  <verify>
# Review publish_event() implementation
grep -A 50 "^publish_event()" .aether/utils/event-bus.sh

# Verify no subscriber notification code
! grep -q "get_events_for_subscriber" .aether/utils/event-bus.sh || echo "WARNING: Direct subscriber call found"
! grep -q "notify.*subscriber" .aether/utils/event-bus.sh || echo "WARNING: Subscriber notification found"
! grep -q "spawn.*subscriber" .aether/utils/event-bus.sh || echo "WARNING: Subscriber spawning found"

# Verify return after write
grep -q "echo.*event_id" .aether/utils/event-bus.sh && echo "✓ Returns event_id after write"
grep -q "return 0" .aether/utils/event-bus.sh && echo "✓ Returns 0 after write"

echo "✓ publish_event() is non-blocking (no subscriber calls, returns immediately)"
  </verify>
  <done>
publish_event() verified as non-blocking async operation. Writes event to events.json event_log and returns event_id immediately. Does NOT call subscribers, does NOT wait for delivery, does NOT spawn background processes. Subscribers poll independently via get_events_for_subscriber(). Documentation added to event-bus.sh header explaining pull-based async design.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test script demonstrating non-blocking async behavior</name>
  <files>.aether/utils/test-event-async.sh</files>
  <action>
Create .aether/utils/test-event-async.sh with comprehensive async behavior tests:

```bash
#!/bin/bash
# Test script for async non-blocking event delivery
# Usage: .aether/utils/test-event-async.sh

SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
source "${SCRIPT_DIR}/event-bus.sh"

echo "=== Async Non-Blocking Event Delivery Test Suite ==="
echo

# Initialize event bus
echo "1. Initializing event bus..."
initialize_event_bus
echo "✓ Event bus initialized"
echo

# Test 1: Publish returns immediately
echo "2. Testing publish returns immediately..."
time_start=$(date +%s%N 2>/dev/null || date +%s)000000
event_id=$(publish_event "test" "test_event" '{"test": "data"}' "test_publisher")
time_end=$(date +%s%N 2>/dev/null || date +%s)999000
time_elapsed=$(( (time_end - time_start) / 1000000 )) # Convert to milliseconds
echo "Published event $event_id in ${time_elapsed}ms"
if [ "$time_elapsed" -lt 100 ]; then
    echo "✓ Publish returns immediately (<100ms)"
else
    echo "⚠ Publish took ${time_elapsed}ms (expected <100ms for non-blocking)"
fi
echo

# Test 2: Create subscriptions (but no polling yet)
echo "3. Creating subscriptions..."
subscribe_to_events "subscriber1" "watcher" "test_topic" '{}' > /dev/null
subscribe_to_events "subscriber2" "architect" "test_topic" '{}' > /dev/null
subscribe_to_events "subscriber3" "builder" "test_topic" '{}' > /dev/null
echo "✓ Created 3 subscriptions"
echo

# Test 3: Publish does NOT wait for subscribers to poll
echo "4. Testing publish does not wait for subscribers..."
# Publish event (should return immediately even though subscribers haven't polled)
event_id=$(publish_event "test_topic" "test_async" '{"async": "test"}' "publisher")
echo "Published event $event_id"

# Verify event is in log
event_in_log=$(jq -r ".event_log[] | select(.id == \"$event_id\") | .id" "$EVENTS_FILE")
if [ "$event_in_log" = "$event_id" ]; then
    echo "✓ Event in log (published successfully)"
else
    echo "✗ Event not in log"
    exit 1
fi

# Verify subscribers have NOT received event yet (they haven't polled)
sub1_events=$(get_events_for_subscriber "subscriber1" "watcher")
sub1_count=$(echo "$sub1_events" | jq 'length')
echo "Subscriber1 events before poll: $sub1_count"
if [ "$sub1_count" -gt 0 ]; then
    echo "⚠ Subscriber has events before polling (unexpected)"
else
    echo "✓ Subscriber has no events yet (expected - haven't polled)"
fi
echo

# Test 4: Subscribers poll independently
echo "5. Testing subscribers poll independently..."
# Subscriber1 polls
sub1_events=$(get_events_for_subscriber "subscriber1" "watcher")
sub1_count=$(echo "$sub1_events" | jq 'length')
echo "Subscriber1 events after poll: $sub1_count"
mark_events_delivered "subscriber1" "watcher" "$sub1_events" > /dev/null

# Subscriber2 polls (still sees event - independent delivery)
sub2_events=$(get_events_for_subscriber "subscriber2" "architect")
sub2_count=$(echo "$sub2_events" | jq 'length')
echo "Subscriber2 events after poll: $sub2_count"

# Subscriber3 has NOT polled yet
sub3_events=$(get_events_for_subscriber "subscriber3" "builder")
sub3_count=$(echo "$sub3_events" | jq 'length')
echo "Subscriber3 events (hasn't polled yet): $sub3_count"

if [ "$sub1_count" -ge 1 ] && [ "$sub2_count" -ge 1 ] && [ "$sub3_count" -ge 1 ]; then
    echo "✓ All subscribers can poll independently"
else
    echo "✗ Independent polling failed"
    exit 1
fi
echo

# Test 5: Publish while subscribers are not running
echo "6. Testing publish while subscribers are not running..."
# Publish another event (subscribers not "running" - prompt-based agents)
event_id=$(publish_event "test_topic" "test_inactive" '{"inactive": "subscribers"}' "publisher")
echo "Published event $event_id while subscribers inactive"

# Subscribers can still get event when they next poll
sub1_events=$(get_events_for_subscriber "subscriber1" "watcher")
sub1_count=$(echo "$sub1_events" | jq 'length')
echo "Subscriber1 events after second publish: $sub1_count"
if [ "$sub1_count" -ge 1 ]; then
    echo "✓ Subscribers receive events published while they were inactive"
else
    echo "✗ Subscribers did not receive events published while inactive"
    exit 1
fi
echo

# Test 6: Concurrent publishes do not block each other
echo "7. Testing concurrent publishes..."
publish_event "concurrent" "conc1" '{"i": 1}' "p1" > /dev/null &
pid1=$!
publish_event "concurrent" "conc2" '{"i": 2}' "p2" > /dev/null &
pid2=$!
publish_event "concurrent" "conc3" '{"i": 3}' "p3" > /dev/null &
pid3=$!

wait $pid1
wait $pid2
wait $pid3

concurrent_count=$(jq '[.event_log[] | select(.topic == "concurrent")] | length' "$EVENTS_FILE")
echo "Concurrent publishes completed: $concurrent_count events"
if [ "$concurrent_count" -eq 3 ]; then
    echo "✓ Concurrent publishes work correctly"
else
    echo "⚠ Expected 3 concurrent events, got $concurrent_count"
fi
echo

# Test 7: No background processes spawned
echo "8. Verifying no background processes..."
# Check for event bus background processes
bg_processes=$(ps aux | grep -i "event-bus" | grep -v grep | wc -l)
echo "Background event-bus processes: $bg_processes"
if [ "$bg_processes" -eq 0 ]; then
    echo "✓ No background event-bus processes (pure pull-based)"
else
    echo "⚠ Found background processes (unexpected for pull-based design)"
fi
echo

# Test 8: Decoupled publish and subscribe
echo "9. Testing decoupled publish and subscribe..."
# Publish to topic with NO subscribers
event_id=$(publish_event "no_subs_topic" "no_subs" '{"test": "data"}' "publisher")
echo "Published to topic with no subscribers: $event_id"

# Event should still be in log
event_in_log=$(jq -r ".event_log[] | select(.id == \"$event_id\") | .id" "$EVENTS_FILE")
if [ "$event_in_log" = "$event_id" ]; then
    echo "✓ Event logged even with no subscribers"
else
    echo "✗ Event not logged"
    exit 1
fi

# Now subscribe - should still see event (since it hasn't been delivered)
subscribe_to_events "late_subscriber" "watcher" "no_subs_topic" '{}' > /dev/null
late_events=$(get_events_for_subscriber "late_subscriber" "watcher")
late_count=$(echo "$late_events" | jq 'length')
echo "Late subscriber sees $late_count events"
if [ "$late_count" -ge 1 ]; then
    echo "✓ Late subscriber receives events published before subscription"
else
    echo "⚠ Late subscriber did not receive pre-subscription events"
fi
echo

# Test 9: Publish speed (100 events should be fast)
echo "10. Testing publish speed (100 events)..."
time_start=$(date +%s)
for i in {1..100}; do
    publish_event "speed_test" "speed_event" "{\"i\": $i}" "speed_tester" > /dev/null
done
time_end=$(date +%s)
time_elapsed=$((time_end - time_start))
echo "Published 100 events in ${time_elapsed}s"
if [ "$time_elapsed" -lt 10 ]; then
    echo "✓ Publish speed acceptable (<10s for 100 events)"
else
    echo "⚠ Publish slow (${time_elapsed}s for 100 events)"
fi
echo

echo "=== All Async Delivery Tests Passed ==="
echo ""
echo "Summary:"
echo "- Publish returns immediately (non-blocking)"
echo "- Publish does not wait for subscribers"
echo "- Subscribers poll independently"
echo "- No background processes required"
echo "- Concurrent publishes work correctly"
echo "- Publish and subscribe are fully decoupled"
```

Make executable: chmod +x .aether/utils/test-event-async.sh

Test script verifies:
- Publish returns immediately (<100ms)
- Publish does not wait for subscribers
- Subscribers poll independently
- Subscribers receive events published while inactive
- Concurrent publishes work without blocking
- No background processes spawned
- Decoupled publish/subscribe (publish works without subscribers)
- Late subscribers receive pre-subscription events
- Publish speed acceptable (100 events < 10s)
  </action>
  <verify>
# Run test script
.aether/utils/test-event-async.sh

# Expected output: All tests pass with ✓ checkmarks
# Verify no background processes
ps aux | grep -i "event-bus" | grep -v grep || echo "✓ No background event-bus processes"
  </verify>
  <done>
test-event-async.sh created with comprehensive async behavior tests. All tests pass: publish returns immediately, no waiting for subscribers, independent polling, no background processes, concurrent publishes, decoupled publish/subscribe. Test script confirms event bus implements true async non-blocking delivery optimal for prompt-based Worker Ants.
  </done>
</task>

</tasks>

<verification>
# Overall verification criteria

1. Non-blocking publish:
   - publish_event() returns immediately after write (<100ms)
   - Does not wait for subscribers to process
   - Returns event_id, then subscriber can poll independently

2. Decoupled publish and subscribe:
   - Publish works even with no subscribers
   - Subscribers can poll at any time (not tied to publish)
   - Late subscribers receive pre-subscription events

3. Pull-based delivery:
   - Subscribers poll via get_events_for_subscriber()
   - No push mechanism (no subscriber notification from publish)
   - Subscribers control when they receive events

4. No background processes:
   - No daemons or background workers spawned
   - Pure file-based coordination (events.json)
   - Works naturally with prompt-based agents

5. Independent polling:
   - Each subscriber polls independently
   - Delivery tracking per-subscriber (last_event_delivered)
   - One subscriber polling doesn't affect others

6. Concurrent access:
   - Multiple publishers can publish concurrently
   - File locking prevents corruption
   - No blocking between publishers
</verification>

<success_criteria>
1. publish_event() verified as non-blocking (returns <100ms)
2. No subscriber calls in publish_event() implementation
3. publish_event() does NOT call get_events_for_subscriber()
4. No background processes spawned by event bus
5. Subscribers poll independently (verified by test)
6. Test script (test-event-async.sh) passes all tests
7. Documentation added to event-bus.sh header explaining async design
8. Late subscribers receive pre-subscription events
9. Concurrent publishes work without blocking
10. Publish speed acceptable (100 events < 10s)
</success_criteria>

<output>
After completion, create `.planning/phases/09-stigmergic-events/09-06-SUMMARY.md` with:
- Async non-blocking design documentation
- Pull-based delivery pattern explanation
- Verification results (publish returns <100ms, no subscriber calls)
- Test results confirming async behavior
- Comparison with push-based alternatives (why pull is better for prompt-based agents)
- Integration examples for Worker Ants
</output>
