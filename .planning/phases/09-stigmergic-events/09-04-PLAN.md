---
phase: 09-stigmergic-events
plan: 04
type: execute
wave: 3
depends_on: [09-02, 09-03]
files_modified:
  - .aether/utils/event-bus.sh
  - .aether/data/events.json
autonomous: true

must_haves:
  truths:
    - "get_events_for_subscriber() function retrieves events matching subscriptions"
    - "Events filtered by topic pattern (with wildcard support via jq test())"
    - "Events filtered by custom filter_criteria (JSON object matching)"
    - "Only returns events since last_event_delivered (polling semantics)"
    - "mark_events_delivered() updates subscription's last_event_delivered timestamp"
    - "Pull-based delivery (subscribers poll, events not pushed)"
    - "Non-blocking (returns immediately, empty array if no events)"
  artifacts:
    - path: ".aether/utils/event-bus.sh"
      provides: "Event filtering and pull-based delivery functions"
      exports: ["get_events_for_subscriber", "mark_events_delivered"]
    - path: ".aether/data/events.json"
      provides: "Event log with filterable events"
      contains: ["event_log array", "subscriptions with last_event_delivered"]
  key_links:
    - from: "get_events_for_subscriber()"
      to: ".aether/data/events.json"
      via: "jq filters event_log by topic pattern and filter_criteria"
      pattern: "jq.*event_log\\[\\].*select.*test\\(\\$pattern\\)"
    - from: "mark_events_delivered()"
      to: ".aether/data/events.json"
      via: "jq updates subscription's last_event_delivered timestamp"
      pattern: "jq.*subscriptions\\[\\].*last_event_delivered"
    - from: "get_events_for_subscriber()"
      to: ".aether/utils/file-lock.sh"
      via: "acquire_lock before read, release_lock after"
      pattern: "acquire_lock.*release_lock"
---

<objective>
Implement event filtering and pull-based delivery for subscribers

Purpose: Enable Worker Ants to retrieve events matching their subscriptions using pull-based delivery. Subscribers poll for events when they execute, receiving only events matching their topic patterns and filter criteria since their last delivery timestamp. This approach is optimal for prompt-based agents (Worker Ants) that are not persistent processes.

Output: get_events_for_subscriber() function that filters events by topic pattern and criteria, and mark_events_delivered() that updates delivery tracking
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-stigmergic-events/09-RESEARCH.md
@.planning/phases/09-stigmergic-events/09-02-PLAN.md
@.planning/phases/09-stigmergic-events/09-03-PLAN.md

# Existing utilities to integrate
.aether/utils/event-bus.sh (from 09-01, 09-02, 09-03)
.aether/utils/atomic-write.sh
.aether/utils/file-lock.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement get_events_for_subscriber() with filtering and mark_events_delivered()</name>
  <files>.aether/utils/event-bus.sh</files>
  <action>
Add the following functions to .aether/utils/event-bus.sh (after subscribe_to_events):

```bash
# Get events for a subscriber (pull-based delivery)
# Arguments: subscriber_id, subscriber_caste
# Returns: JSON array of matching events (empty array if none)
get_events_for_subscriber() {
    local subscriber_id="$1"
    local subscriber_caste="${2:-}"

    if [ -z "$subscriber_id" ]; then
        echo "Error: subscriber_id is required" >&2
        return 1
    fi

    # Check if events.json exists
    if [ ! -f "$EVENTS_FILE" ]; then
        echo "Error: Event bus not initialized" >&2
        return 1
    fi

    # Acquire file lock for read
    if ! acquire_lock "$EVENTS_FILE"; then
        echo "Error: Failed to acquire event bus lock" >&2
        return 1
    fi

    # Get all subscriptions for this subscriber
    local subscriptions=$(jq -c --arg subscriber "$subscriber_id" \
       '.subscriptions[] | select(.subscriber_id == $subscriber)' \
       "$EVENTS_FILE")

    # If no subscriptions, return empty array
    if [ -z "$subscriptions" ]; then
        release_lock
        echo "[]"
        return 0
    fi

    # Collect matching events from all subscriptions
    local matching_events="[]"
    local subscription_timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    while IFS= read -r sub; do
        # Skip empty lines
        [ -z "$sub" ] && continue

        local topic_pattern=$(echo "$sub" | jq -r '.topic_pattern')
        local filter_criteria=$(echo "$sub" | jq -c '.filter_criteria')
        local last_delivered=$(echo "$sub" | jq -r '.last_event_delivered // "null"')

        # Find events matching topic pattern (with wildcard support)
        # jq test() function performs regex matching
        local events=$(jq -c --arg pattern "$topic_pattern" \
           --argjson filter "$filter_criteria" \
           --arg last "$last_delivered" \
           --arg caste "$subscriber_caste" \
           --arg timestamp "$subscription_timestamp" \
           '
           [.event_log[] |
           select(
             # Topic pattern matching (wildcard support via test())
             (.topic | test($pattern)) and
             # Only events since last delivery (or all if never delivered)
             (.metadata.timestamp > $last or $last == "null") and
             # Filter criteria matching (if specified)
             (
               $filter == {} or
               (.data | to_entries | all(.key as $k | $filter[$k] == .value))
             )
           )
           ] |
           # Add delivery timestamp for tracking
           map(. + {delivered_at: $timestamp})
           ' "$EVENTS_FILE")

        # Accumulate matching events
        if [ "$events" != "[]" ]; then
            matching_events=$(echo "$matching_events" | jq --argjson new "$events" '. + $new')
        fi
    done <<< "$subscriptions"

    # Release lock
    release_lock

    # Return matching events (empty array if none)
    echo "$matching_events"
    return 0
}

# Mark events as delivered for a subscriber
# Arguments: subscriber_id, subscriber_caste, events_json_array
# Returns: 0 on success, 1 on failure
mark_events_delivered() {
    local subscriber_id="$1"
    local subscriber_caste="${2:-}"
    local events_json="$3"

    if [ -z "$subscriber_id" ]; then
        echo "Error: subscriber_id is required" >&2
        return 1
    fi

    if [ -z "$events_json" ]; then
        echo "Error: events_json is required" >&2
        return 1
    fi

    # Check if events.json exists
    if [ ! -f "$EVENTS_FILE" ]; then
        echo "Error: Event bus not initialized" >&2
        return 1
    fi

    # Validate events_json is valid JSON array
    if ! echo "$events_json" | python3 -c "import json, sys; data=json.load(sys.stdin); assert isinstance(data, list)" 2>/dev/null; then
        echo "Error: events_json must be a valid JSON array" >&2
        return 1
    fi

    # If empty array, nothing to mark
    if [ "$events_json" = "[]" ]; then
        return 0
    fi

    # Get the most recent event timestamp
    local latest_timestamp=$(echo "$events_json" | jq -r '[.[].metadata.timestamp] | max' 2>/dev/null)

    if [ -z "$latest_timestamp" ] || [ "$latest_timestamp" = "null" ]; then
        echo "Error: Could not determine latest event timestamp" >&2
        return 1
    fi

    # Acquire file lock
    if ! acquire_lock "$EVENTS_FILE"; then
        echo "Error: Failed to acquire event bus lock" >&2
        return 1
    fi

    local temp_file="/tmp/event_mark_delivered.$$.tmp"

    # Update all subscriptions for this subscriber
    jq --arg subscriber "$subscriber_id" \
       --arg latest "$latest_timestamp" \
       --argjson count "$(echo "$events_json" | jq 'length')" \
       '
       .subscriptions |= map(
         if .subscriber_id == $subscriber then
           .last_event_delivered = $latest |
           .delivery_count += $count
         else
           .
         end
       ) |
       .metrics.total_delivered += $count |
       .metrics.backlog_count -= $count |
       .metrics.last_updated = ($latest | todate)
       ' "$EVENTS_FILE" > "$temp_file"

    if [ $? -ne 0 ]; then
        echo "Error: Failed to mark events as delivered" >&2
        rm -f "$temp_file"
        release_lock
        return 1
    fi

    # Atomic write
    if ! atomic_write_from_file "$EVENTS_FILE" "$temp_file"; then
        echo "Error: Failed to write delivery update to event bus" >&2
        rm -f "$temp_file"
        release_lock
        return 1
    fi

    rm -f "$temp_file"

    # Release lock
    release_lock

    return 0
}

# Export new functions
export -f get_events_for_subscriber mark_events_delivered
```

Key implementation details:
- get_events_for_subscriber() takes subscriber_id and optional subscriber_caste
- Acquires lock for read (prevents concurrent modifications while reading)
- Gets all subscriptions for the subscriber (multiple subscriptions supported)
- For each subscription:
  - Matches events by topic pattern using jq test() function (regex matching with wildcard support)
  - Filters by last_event_delivered timestamp (only returns new events since last poll)
  - Applies filter_criteria if specified (JSON object key-value matching)
  - Adds delivered_at timestamp to each event for tracking
- Accumulates matching events from all subscriptions
- Returns empty array [] if no matching events (non-blocking, returns immediately)
- mark_events_delivered() updates all subscriptions for the subscriber:
  - Sets last_event_delivered to most recent event timestamp
  - Increments delivery_count by number of events delivered
  - Updates metrics (total_delivered, backlog_count, last_updated)
- All operations use atomic_write_from_file() for safety
- Pull-based delivery: subscribers poll when they execute, events not pushed

Example usage pattern for Worker Ants:
```bash
# Poll for new events
events=$(get_events_for_subscriber "verifier" "watcher")
event_count=$(echo "$events" | jq 'length')

if [ "$event_count" -gt 0 ]; then
    echo "Received $event_count events"
    # Process each event
    echo "$events" | jq -c '.[]' | while read -r event; do
        event_topic=$(echo "$event" | jq -r '.topic')
        event_data=$(echo "$event" | jq -c '.data')
        # Process event based on topic and data
        echo "Processing $event_topic: $event_data"
    done

    # Mark events as delivered
    mark_events_delivered "verifier" "watcher" "$events"
fi
```
  </action>
  <verify>
# Source event-bus.sh and test event filtering
source .aether/utils/event-bus.sh

# Initialize event bus and add test data
initialize_event_bus

# Create subscriptions
subscribe_to_events "verifier" "watcher" "phase_complete" '{"min_phase": 5}' > /dev/null
subscribe_to_events "logger" "architect" "error.*" '{}' > /dev/null

# Publish test events
publish_event "phase_complete" "phase_8_complete" '{"phase": 8, "status": "success"}' "queen" > /dev/null
publish_event "error" "error_occurred" '{"error_code": 500, "message": "Database error"}' "worker" "builder" > /dev/null
publish_event "task_started" "task_started" '{"task_id": "123"}' "executor" "builder" > /dev/null

# Test get_events_for_subscriber
echo "Events for verifier:"
get_events_for_subscriber "verifier" "watcher"

echo "Events for logger:"
get_events_for_subscriber "logger" "architect"

# Test mark_events_delivered
events=$(get_events_for_subscriber "verifier" "watcher")
mark_events_delivered "verifier" "watcher" "$events"

# Verify delivery tracking
echo "Verifier subscription after marking delivered:"
jq '.subscriptions[] | select(.subscriber_id == "verifier")' .aether/data/events.json

echo "Metrics after delivery:"
jq '.metrics' .aether/data/events.json
  </verify>
  <done>
get_events_for_subscriber() function retrieves events matching subscriptions with topic pattern filtering (wildcards via jq test()), filter criteria matching, and since-last-delivered polling. Returns empty array if no events (non-blocking). mark_events_delivered() updates subscription's last_event_delivered timestamp and delivery_count, updates metrics. Pull-based delivery implemented - subscribers poll when executing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test script demonstrating event filtering and delivery</name>
  <files>.aether/utils/test-event-filtering.sh</files>
  <action>
Create .aether/utils/test-event-filtering.sh with comprehensive tests:

```bash
#!/bin/bash
# Test script for event filtering and pull-based delivery
# Usage: .aether/utils/test-event-filtering.sh

SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
source "${SCRIPT_DIR}/event-bus.sh"

echo "=== Event Filtering and Delivery Test Suite ==="
echo

# Initialize event bus
echo "1. Initializing event bus..."
initialize_event_bus
echo "✓ Event bus initialized"
echo

# Test 1: Create subscriptions with different patterns
echo "2. Creating test subscriptions..."
subscribe_to_events "verifier" "watcher" "phase_complete" '{"min_phase": 5}' > /dev/null
subscribe_to_events "logger" "architect" "error.*" '{}' > /dev/null
subscribe_to_events "task_monitor" "scout" "task_*" '{}' > /dev/null
echo "✓ Created 3 subscriptions"
echo

# Test 2: Publish test events
echo "3. Publishing test events..."
publish_event "phase_complete" "phase_8_complete" '{"phase": 8, "status": "success"}' "queen" > /dev/null
publish_event "error" "error_occurred" '{"error_code": 500, "message": "Database error"}' "worker" "builder" > /dev/null
publish_event "error" "error_critical" '{"error_code": 503, "severity": "critical"}' "worker" "builder" > /dev/null
publish_event "task_started" "task_started" '{"task_id": "123", "name": "build API"}' "executor" "builder" > /dev/null
publish_event "task_completed" "task_completed" '{"task_id": "123", "status": "success"}' "executor" "builder" > /dev/null
echo "✓ Published 5 events"
echo

# Test 3: Filter by topic pattern
echo "4. Testing topic pattern filtering..."
verifier_events=$(get_events_for_subscriber "verifier" "watcher")
verifier_count=$(echo "$verifier_events" | jq 'length')
echo "Verifier (phase_complete): $verifier_count events"
logger_events=$(get_events_for_subscriber "logger" "architect")
logger_count=$(echo "$logger_events" | jq 'length')
echo "Logger (error.*): $logger_count events"
task_monitor_events=$(get_events_for_subscriber "task_monitor" "scout")
task_monitor_count=$(echo "$task_monitor_events" | jq 'length')
echo "Task Monitor (task_*): $task_monitor_count events"
if [ "$verifier_count" -eq 1 ] && [ "$logger_count" -eq 2 ] && [ "$task_monitor_count" -eq 2 ]; then
    echo "✓ Topic pattern filtering works correctly"
else
    echo "✗ Topic pattern filtering failed"
    exit 1
fi
echo

# Test 4: Polling semantics (only new events since last delivery)
echo "5. Testing polling semantics..."
mark_events_delivered "verifier" "watcher" "$verifier_events" > /dev/null
# Publish new event
publish_event "phase_complete" "phase_9_complete" '{"phase": 9}' "queen" > /dev/null
# Get events again - should only see new event
new_verifier_events=$(get_events_for_subscriber "verifier" "watcher")
new_verifier_count=$(echo "$new_verifier_events" | jq 'length')
echo "Verifier events after marking delivered and publishing new: $new_verifier_count"
if [ "$new_verifier_count" -eq 1 ]; then
    echo "✓ Polling semantics work correctly (only new events since last delivery)"
else
    echo "✗ Polling semantics failed"
    exit 1
fi
echo

# Test 5: Filter criteria
echo "6. Testing filter criteria..."
subscribe_to_events "db_specialist" "builder" "spawn_request" '{"specialist_type": "database"}' > /dev/null
publish_event "spawn_request" "spawn_db" '{"specialist_type": "database", "reason": "capability gap"}' "route_setter" > /dev/null
publish_event "spawn_request" "spawn_web" '{"specialist_type": "web", "reason": "capability gap"}' "route_setter" > /dev/null
db_events=$(get_events_for_subscriber "db_specialist" "builder")
db_count=$(echo "$db_events" | jq 'length')
echo "DB specialist (spawn_request with specialist_type=database): $db_count events"
if [ "$db_count" -eq 1 ]; then
    echo "✓ Filter criteria work correctly"
else
    echo "✗ Filter criteria failed"
    exit 1
fi
echo

# Test 6: Empty result (no matching events)
echo "7. Testing empty result (no matching events)..."
subscribe_to_events "non_existent_subscriber" "watcher" "non_existent_topic" '{}' > /dev/null
no_events=$(get_events_for_subscriber "non_existent_subscriber" "watcher")
no_events_count=$(echo "$no_events" | jq 'length')
echo "Non-existent subscriber events: $no_events_count"
if [ "$no_events_count" -eq 0 ]; then
    echo "✓ Returns empty array when no matching events"
else
    echo "✗ Should return empty array"
    exit 1
fi
echo

# Test 7: Delivery tracking updates
echo "8. Testing delivery tracking..."
initial_delivery_count=$(jq -r '.subscriptions[] | select(.subscriber_id == "verifier") | .delivery_count' "$EVENTS_FILE")
mark_events_delivered "verifier" "watcher" "$new_verifier_events" > /dev/null
final_delivery_count=$(jq -r '.subscriptions[] | select(.subscriber_id == "verifier") | .delivery_count' "$EVENTS_FILE")
echo "Verifier delivery_count: $initial_delivery_count → $final_delivery_count"
if [ "$final_delivery_count" -gt "$initial_delivery_count" ]; then
    echo "✓ Delivery tracking updated correctly"
else
    echo "✗ Delivery tracking failed"
    exit 1
fi
echo

# Test 8: Metrics updates
echo "9. Testing metrics updates..."
total_delivered=$(jq -r '.metrics.total_delivered' "$EVENTS_FILE")
backlog_count=$(jq -r '.metrics.backlog_count' "$EVENTS_FILE")
echo "Metrics - total_delivered: $total_delivered, backlog_count: $backlog_count"
if [ "$total_delivered" -gt 0 ]; then
    echo "✓ Metrics updated correctly"
else
    echo "✗ Metrics not updated"
    exit 1
fi
echo

# Test 9: Non-blocking behavior
echo "10. Testing non-blocking behavior (returns immediately with no events)..."
time_start=$(date +%s)
get_events_for_subscriber "non_existent_subscriber" "watcher" > /dev/null
time_end=$(date +%s)
time_elapsed=$((time_end - time_start))
echo "Time elapsed: ${time_elapsed}s"
if [ "$time_elapsed" -lt 2 ]; then
    echo "✓ Non-blocking (returns immediately)"
else
    echo "✗ Blocking (should return immediately)"
    exit 1
fi
echo

echo "=== All Event Filtering Tests Passed ==="
```

Make executable: chmod +x .aether/utils/test-event-filtering.sh

Test script covers:
- Topic pattern filtering (exact match and wildcards)
- Polling semantics (only new events since last delivery)
- Filter criteria (JSON object matching)
- Empty results (no matching events)
- Delivery tracking updates (last_event_delivered, delivery_count)
- Metrics updates (total_delivered, backlog_count)
- Non-blocking behavior (returns immediately with no events)
  </action>
  <verify>
# Run test script
.aether/utils/test-event-filtering.sh

# Expected output: All tests pass with ✓ checkmarks
# Verify delivery tracking
jq '.subscriptions[] | select(.subscriber_id == "verifier")' .aether/data/events.json
  </verify>
  <done>
test-event-filtering.sh created with comprehensive test coverage. All tests pass: topic pattern filtering (exact and wildcard), polling semantics, filter criteria, empty results, delivery tracking, metrics updates, non-blocking behavior. Test script demonstrates event filtering works correctly with jq regex matching, since-last-delivered polling, and pull-based delivery.
  </done>
</task>

</tasks>

<verification>
# Overall verification criteria

1. Event filtering works:
   - get_events_for_subscriber() returns events matching topic patterns
   - Wildcard patterns work (error.* matches error, error_critical, etc.)
   - Filter criteria applied (JSON object key-value matching)
   - Only returns events since last_event_delivered timestamp

2. Pull-based delivery:
   - Subscribers poll for events (get_events_for_subscriber)
   - Returns immediately with empty array if no events
   - mark_events_delivered() updates delivery tracking
   - Next poll only returns new events since last delivery

3. Delivery tracking:
   - last_event_delivered timestamp updated after marking
   - delivery_count incremented by number of events delivered
   - Each subscription tracks its own delivery cursor

4. Metrics updated:
   - total_delivered incremented
   - backlog_count decremented
   - last_updated timestamp set

5. Safety patterns:
   - File locking prevents concurrent corruption
   - Atomic writes prevent partial corruption
   - Input validation (subscriber_id required, events_json valid JSON array)

6. Non-blocking:
   - Returns immediately even when no events
   - Does not wait for events to be published
</verification>

<success_criteria>
1. get_events_for_subscriber() function exists and is exported
2. Returns events matching topic pattern (exact and wildcard)
3. Applies filter criteria (JSON object matching)
4. Only returns events since last_event_delivered (polling semantics)
5. Returns empty array [] when no matching events (non-blocking)
6. mark_events_delivered() updates subscription's last_event_delivered and delivery_count
7. Metrics updated (total_delivered, backlog_count)
8. Test script (test-event-filtering.sh) passes all tests
9. Multiple subscriptions per subscriber supported (events accumulated)
</success_criteria>

<output>
After completion, create `.planning/phases/09-stigmergic-events/09-04-SUMMARY.md` with:
- get_events_for_subscriber() function signature and usage
- Event filtering documentation (topic patterns, filter criteria, since-last-delivered)
- Pull-based delivery pattern (subscribers poll, events not pushed)
- mark_events_delivered() function for delivery tracking
- Safety patterns used (file locking, atomic writes)
- Test results demonstrating filtering and delivery
- Worker Ant integration example showing polling pattern
</output>
