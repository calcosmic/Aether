---
phase: 09-stigmergic-events
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .aether/data/events.json
  - .aether/utils/event-bus.sh
autonomous: true

must_haves:
  truths:
    - "events.json file exists with valid schema"
    - "Schema includes topics, subscriptions, event_log, metrics, config sections"
    - "File can be read and validated with jq"
    - "Topic pattern supports wildcards (e.g., 'phase.*')"
    - "Subscription tracking includes per-subscriber delivery state"
    - "Ring buffer configuration limits event log growth"
  artifacts:
    - path: ".aether/data/events.json"
      provides: "Event bus storage with complete schema"
      contains: ["topics", "subscriptions", "event_log", "metrics", "config"]
    - path: ".aether/utils/event-bus.sh"
      provides: "Event bus utility functions (skeleton with initialization)"
      exports: ["EVENTS_FILE", "initialize_event_bus"]
  key_links:
    - from: ".aether/utils/event-bus.sh"
      to: ".aether/data/events.json"
      via: "EVENTS_FILE variable points to events.json path"
      pattern: "EVENTS_FILE=.*events.json"
    - from: ".aether/utils/atomic-write.sh"
      to: ".aether/data/events.json"
      via: "atomic_write_from_file for safe initialization"
      pattern: "atomic_write_from_file.*events.json"
    - from: ".aether/utils/file-lock.sh"
      to: ".aether/data/events.json"
      via: "acquire_lock for concurrent access safety"
      pattern: "acquire_lock.*events.json"
---

<objective>
Create event bus schema and initialize events.json with pub/sub infrastructure

Purpose: Establish the foundation for colony-wide event-driven communication by creating the event bus storage schema and initialization utilities. The events.json file will store topics, subscriptions, event log, metrics, and configuration in a single JSON file following Aether's proven patterns.

Output: Initialized events.json file with complete schema and event-bus.sh utility with initialization function
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-stigmergic-events/09-RESEARCH.md

# Existing patterns to follow
.aether/utils/atomic-write.sh
.aether/utils/file-lock.sh
.aether/data/pheromones.json
.aether/data/COLONY_STATE.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create events.json schema with all required sections</name>
  <files>.aether/data/events.json</files>
  <action>
Create .aether/data/events.json with the following structure:

```json
{
  "$schema": "Aether Event Bus v1.0",
  "topics": {
    "phase_complete": {
      "description": "Phase execution completed",
      "subscriber_count": 0
    },
    "error": {
      "description": "Error occurred during execution",
      "subscriber_count": 0
    },
    "spawn_request": {
      "description": "Request to spawn specialist Worker Ant",
      "subscriber_count": 0
    },
    "task_started": {
      "description": "Worker Ant started executing a task",
      "subscriber_count": 0
    },
    "task_completed": {
      "description": "Worker Ant completed a task successfully",
      "subscriber_count": 0
    },
    "task_failed": {
      "description": "Worker Ant failed to complete a task",
      "subscriber_count": 0
    }
  },
  "subscriptions": [],
  "event_log": [],
  "metrics": {
    "total_published": 0,
    "total_subscriptions": 0,
    "total_delivered": 0,
    "publish_rate_per_minute": 0.0,
    "average_delivery_latency_ms": 0,
    "backlog_count": 0,
    "last_updated": null
  },
  "config": {
    "max_event_log_size": 1000,
    "max_subscriptions_per_topic": 50,
    "event_retention_hours": 168
  }
}
```

Key design decisions:
- Single events.json file for all event data (simpler than distributed files)
- Pre-populate common topics (phase_complete, error, spawn_request, task_* events)
- Subscriptions array tracks per-subscriber state (last_event_delivered timestamp)
- Event log starts empty (events appended as they occur)
- Metrics track publish rate, delivery latency, backlog for observability
- Config section defines ring buffer size (1000 events default), retention (7 days default), subscription limits

Use atomic-write.sh pattern to create the file safely:
1. Write to temp file in .aether/temp/
2. Validate JSON with python3
3. Atomic rename to events.json
4. Create backup if file already exists
  </action>
  <verify>
# Verify events.json exists and has valid JSON
cat .aether/data/events.json | python3 -c "import json, sys; data=json.load(sys.stdin); print('✓ Valid JSON'); print('✓ Topics:', len(data['topics'])); print('✓ Subscriptions:', len(data['subscriptions'])); print('✓ Event log:', len(data['event_log'])); print('✓ Schema sections:', list(data.keys()))"
  </verify>
  <done>
events.json file exists at .aether/data/events.json with valid JSON structure containing topics (6 pre-defined), subscriptions (empty array), event_log (empty array), metrics (initialized to 0), and config (max_event_log_size=1000, max_subscriptions_per_topic=50, event_retention_hours=168)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create event-bus.sh utility with initialization function</name>
  <files>.aether/utils/event-bus.sh</files>
  <action>
Create .aether/utils/event-bus.sh with the following structure:

```bash
#!/bin/bash
# Aether Event Bus Utility
# Implements pub/sub event system for colony-wide coordination
#
# Usage:
#   source .aether/utils/event-bus.sh
#   initialize_event_bus
#   publish_event "topic" "type" '{"data": "value"}' "publisher" "caste"
#   subscribe_to_events "subscriber_id" "caste" "topic_pattern" '{}'
#   get_events_for_subscriber "subscriber_id" "caste"

# Event bus storage file
EVENTS_FILE="$(git rev-parse --show-toplevel 2>/dev/null || echo "$PWD")/.aether/data/events.json"

# Source required utilities
SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
source "${SCRIPT_DIR}/atomic-write.sh"
source "${SCRIPT_DIR}/file-lock.sh"

# Initialize event bus (create events.json if not exists)
# Arguments: none
# Returns: 0 on success, 1 on failure
initialize_event_bus() {
    local events_dir=$(dirname "$EVENTS_FILE")

    # Create directory if not exists
    mkdir -p "$events_dir"

    # Check if events.json already exists
    if [ -f "$EVENTS_FILE" ]; then
        # Validate existing file
        if ! python3 -c "import json; json.load(open('$EVENTS_FILE'))" 2>/dev/null; then
            echo "Error: Invalid JSON in $EVENTS_FILE"
            return 1
        fi
        echo "Event bus already initialized at $EVENTS_FILE"
        return 0
    fi

    # Create initial events.json structure
    local initial_content='{
  "$schema": "Aether Event Bus v1.0",
  "topics": {
    "phase_complete": {
      "description": "Phase execution completed",
      "subscriber_count": 0
    },
    "error": {
      "description": "Error occurred during execution",
      "subscriber_count": 0
    },
    "spawn_request": {
      "description": "Request to spawn specialist Worker Ant",
      "subscriber_count": 0
    },
    "task_started": {
      "description": "Worker Ant started executing a task",
      "subscriber_count": 0
    },
    "task_completed": {
      "description": "Worker Ant completed a task successfully",
      "subscriber_count": 0
    },
    "task_failed": {
      "description": "Worker Ant failed to complete a task",
      "subscriber_count": 0
    }
  },
  "subscriptions": [],
  "event_log": [],
  "metrics": {
    "total_published": 0,
    "total_subscriptions": 0,
    "total_delivered": 0,
    "publish_rate_per_minute": 0.0,
    "average_delivery_latency_ms": 0,
    "backlog_count": 0,
    "last_updated": null
  },
  "config": {
    "max_event_log_size": 1000,
    "max_subscriptions_per_topic": 50,
    "event_retention_hours": 168
  }
}'

    # Write using atomic_write for safety
    if atomic_write "$EVENTS_FILE" "$initial_content"; then
        echo "Event bus initialized at $EVENTS_FILE"
        return 0
    else
        echo "Error: Failed to initialize event bus"
        return 1
    fi
}

# Export functions
export -f initialize_event_bus
```

Key implementation details:
- EVENTS_FILE uses git rev-parse to find repository root (works from any subdirectory)
- Sources atomic-write.sh and file-lock.sh (Aether's proven safety patterns)
- initialize_event_bus() creates events.json if not exists, validates if exists
- Returns 0 on success, 1 on failure
- Uses atomic_write() for corruption-safe file creation
- Other functions (publish_event, subscribe_to_events, get_events_for_subscriber) will be added in subsequent plans

Make file executable: chmod +x .aether/utils/event-bus.sh
  </action>
  <verify>
# Source event-bus.sh and test initialization
source .aether/utils/event-bus.sh

# Remove existing events.json for test (if exists from previous run)
rm -f .aether/data/events.json

# Test initialization
initialize_event_bus

# Verify file created and valid
cat .aether/data/events.json | python3 -c "import json, sys; json.load(sys.stdin)" && echo "✓ Event bus initialization successful"
  </verify>
  <done>
event-bus.sh created at .aether/utils/event-bus.sh with initialize_event_bus() function that creates events.json with complete schema. File sources atomic-write.sh and file-lock.sh for safety. Function is exported and callable from other scripts.
  </done>
</task>

</tasks>

<verification>
# Overall phase verification

1. Schema completeness:
   - events.json contains all required sections (topics, subscriptions, event_log, metrics, config)
   - Topics include pre-defined event types (phase_complete, error, spawn_request, task_*)
   - Config section has ring buffer settings (max_event_log_size, event_retention_hours)

2. JSON validation:
   - events.json is valid JSON (python3 json.load succeeds)
   - All required fields present in each section

3. Utility integration:
   - event-bus.sh sources atomic-write.sh and file-lock.sh
   - initialize_event_bus() function creates valid events.json
   - EVENTS_FILE variable correctly points to events.json in repository root

4. Safety patterns:
   - Uses atomic-write.sh for file creation
   - Supports file locking (via file-lock.sh) for future operations
   - Validates JSON before committing
</verification>

<success_criteria>
1. events.json exists at .aether/data/events.json with complete schema
2. event-bus.sh exists at .aether/utils/event-bus.sh with initialize_event_bus() function
3. Running `source .aether/utils/event-bus.sh && initialize_event_bus` creates valid events.json
4. events.json validates as valid JSON with python3
5. All 6 pre-defined topics present (phase_complete, error, spawn_request, task_started, task_completed, task_failed)
6. Config section has ring buffer settings (max_event_log_size=1000, event_retention_hours=168)
7. Schema ready for publish/subscribe operations in next plans
</success_criteria>

<output>
After completion, create `.planning/phases/09-stigmergic-events/09-01-SUMMARY.md` with:
- Schema structure documentation
- Key design decisions (single file, ring buffer, per-subscriber tracking)
- Integration with Aether patterns (atomic-write, file-lock)
- Verification results showing valid JSON structure
</output>
