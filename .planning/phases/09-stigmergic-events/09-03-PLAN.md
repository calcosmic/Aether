---
phase: 09-stigmergic-events
plan: 03
type: execute
wave: 2
depends_on: [09-01]
files_modified:
  - .aether/utils/event-bus.sh
  - .aether/data/events.json
autonomous: true

must_haves:
  truths:
    - "subscribe_to_events() function registers subscribers for topics"
    - "Subscriptions track subscriber_id, caste, topic_pattern, filter_criteria"
    - "Subscription includes delivery tracking (last_event_delivered, delivery_count)"
    - "Subscribing increments topic subscriber_count"
    - "File locking prevents concurrent subscription corruption"
    - "Atomic writes prevent partial subscription corruption"
    - "Topic patterns support wildcards (e.g., 'error.*', 'phase.*')"
  artifacts:
    - path: ".aether/utils/event-bus.sh"
      provides: "subscribe_to_events() function for Worker Ants to register interest"
      exports: ["subscribe_to_events", "unsubscribe_from_events", "list_subscriptions"]
    - path: ".aether/data/events.json"
      provides: "Subscriptions array with subscriber records"
      contains: ["subscriptions array", "topics with subscriber_count > 0"]
  key_links:
    - from: "subscribe_to_events()"
      to: ".aether/data/events.json"
      via: "jq appends subscription to subscriptions array"
      pattern: "jq.*subscriptions \\+="
    - from: "subscribe_to_events()"
      to: ".aether/utils/file-lock.sh"
      via: "acquire_lock before write, release_lock after"
      pattern: "acquire_lock.*release_lock"
    - from: "subscribe_to_events()"
      to: ".aether/utils/atomic-write.sh"
      via: "atomic_write_from_file for corruption-safe update"
      pattern: "atomic_write_from_file.*events.json"
---

<objective>
Implement subscribe operation for Worker Ants to register interest in event topics

Purpose: Enable Worker Ants to subscribe to event topics (phase_complete, error, spawn_request) with optional filtering. Subscriptions are stored in events.json with per-subscriber delivery tracking, allowing pull-based event delivery where subscribers poll for new events when they execute.

Output: subscribe_to_events() function in event-bus.sh that records subscriptions with topic patterns, filter criteria, and delivery tracking
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-stigmergic-events/09-RESEARCH.md
@.planning/phases/09-stigmergic-events/09-01-PLAN.md

# Existing utilities to integrate
.aether/utils/event-bus.sh (from 09-01)
.aether/utils/atomic-write.sh
.aether/utils/file-lock.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement subscribe_to_events() function with topic patterns and filtering</name>
  <files>.aether/utils/event-bus.sh</files>
  <action>
Add the following functions to .aether/utils/event-bus.sh (after publish_event and trim_event_log):

```bash
# Generate unique subscription ID
# Arguments: none
# Returns: unique subscription ID (sub_<timestamp>_<random>)
generate_subscription_id() {
    local timestamp=$(date +%s)
    local random_string=$(openssl rand -hex 4 2>/dev/null || echo "$(date +%N)%")
    echo "sub_${timestamp}_${random_string}"
}

# Subscribe to event topics
# Arguments: subscriber_id, subscriber_caste, topic_pattern, filter_criteria (JSON string, optional)
# Returns: subscription_id on success, 1 on failure
subscribe_to_events() {
    local subscriber_id="$1"
    local subscriber_caste="$2"
    local topic_pattern="$3"
    local filter_criteria="${4:-{}}"

    # Validate arguments
    if [ -z "$subscriber_id" ] || [ -z "$subscriber_caste" ] || [ -z "$topic_pattern" ]; then
        echo "Error: subscriber_id, subscriber_caste, and topic_pattern are required" >&2
        return 1
    fi

    # Validate filter_criteria is valid JSON (if provided)
    if [ "$filter_criteria" != "{}" ]; then
        if ! echo "$filter_criteria" | python3 -c "import json, sys; json.load(sys.stdin)" 2>/dev/null; then
            echo "Error: filter_criteria must be valid JSON" >&2
            return 1
        fi
    fi

    # Check if events.json exists
    if [ ! -f "$EVENTS_FILE" ]; then
        echo "Error: Event bus not initialized. Run initialize_event_bus first." >&2
        return 1
    fi

    # Generate subscription metadata
    local sub_id=$(generate_subscription_id)
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Acquire file lock for concurrent access safety
    if ! acquire_lock "$EVENTS_FILE"; then
        echo "Error: Failed to acquire event bus lock" >&2
        return 1
    fi

    # Create temp file for jq update
    local temp_file="/tmp/event_subscribe.$$.tmp"

    # Add subscription and update metrics via jq
    jq --arg id "$sub_id" \
       --arg subscriber "$subscriber_id" \
       --arg caste "$subscriber_caste" \
       --arg pattern "$topic_pattern" \
       --argjson filter "$filter_criteria" \
       --arg timestamp "$timestamp" \
       '
       .subscriptions += [{
         "id": $id,
         "subscriber_id": $subscriber,
         "subscriber_caste": $caste,
         "topic_pattern": $pattern,
         "filter_criteria": $filter,
         "created_at": $timestamp,
         "last_event_delivered": null,
         "delivery_count": 0
       }] |
       .metrics.total_subscriptions += 1 |
       .metrics.last_updated = $timestamp |
       if .topics[$pattern] then
         .topics[$pattern].subscriber_count += 1
       else
         .topics[$pattern] = {
           "description": "Auto-created topic from subscription",
           "subscriber_count": 1
         }
       end
       ' "$EVENTS_FILE" > "$temp_file"

    if [ $? -ne 0 ]; then
        echo "Error: Failed to add subscription" >&2
        rm -f "$temp_file"
        release_lock
        return 1
    fi

    # Atomic write
    if ! atomic_write_from_file "$EVENTS_FILE" "$temp_file"; then
        echo "Error: Failed to write subscription to event bus" >&2
        rm -f "$temp_file"
        release_lock
        return 1
    fi

    rm -f "$temp_file"

    # Release lock
    release_lock

    # Return subscription ID
    echo "$sub_id"
    return 0
}

# Unsubscribe from event topics
# Arguments: subscription_id
# Returns: 0 on success, 1 on failure
unsubscribe_from_events() {
    local subscription_id="$1"

    if [ -z "$subscription_id" ]; then
        echo "Error: subscription_id is required" >&2
        return 1
    fi

    # Check if events.json exists
    if [ ! -f "$EVENTS_FILE" ]; then
        echo "Error: Event bus not initialized" >&2
        return 1
    fi

    # Acquire file lock
    if ! acquire_lock "$EVENTS_FILE"; then
        echo "Error: Failed to acquire event bus lock" >&2
        return 1
    fi

    # Get subscription details before removing (for updating subscriber_count)
    local subscription=$(jq -r --arg id "$subscription_id" '.subscriptions[] | select(.id == $id)' "$EVENTS_FILE")
    local topic_pattern=$(echo "$subscription" | jq -r '.topic_pattern')

    # Create temp file for jq update
    local temp_file="/tmp/event_unsubscribe.$$.tmp"

    # Remove subscription and update metrics
    jq --arg id "$subscription_id" \
       --arg pattern "$topic_pattern" \
       '
       .subscriptions = [.subscriptions[] | select(.id != $id)] |
       if .topics[$pattern] then
         .topics[$pattern].subscriber_count |= (. - 1)
       end |
       .metrics.last_updated = (now | todate)
       ' "$EVENTS_FILE" > "$temp_file"

    if [ $? -ne 0 ]; then
        echo "Error: Failed to remove subscription" >&2
        rm -f "$temp_file"
        release_lock
        return 1
    fi

    # Atomic write
    if ! atomic_write_from_file "$EVENTS_FILE" "$temp_file"; then
        echo "Error: Failed to write unsubscribe to event bus" >&2
        rm -f "$temp_file"
        release_lock
        return 1
    fi

    rm -f "$temp_file"

    # Release lock
    release_lock

    echo "Unsubscribed: $subscription_id"
    return 0
}

# List all subscriptions (optionally filter by subscriber_id)
# Arguments: [subscriber_id] (optional)
# Returns: JSON array of subscriptions
list_subscriptions() {
    local subscriber_filter="${1:-}"

    if [ ! -f "$EVENTS_FILE" ]; then
        echo "Error: Event bus not initialized" >&2
        return 1
    fi

    if [ -n "$subscriber_filter" ]; then
        jq -r --arg subscriber "$subscriber_filter" '.subscriptions[] | select(.subscriber_id == $subscriber)' "$EVENTS_FILE"
    else
        jq -r '.subscriptions[]' "$EVENTS_FILE"
    fi
}

# Export new functions
export -f generate_subscription_id subscribe_to_events unsubscribe_from_events list_subscriptions
```

Key implementation details:
- generate_subscription_id() creates unique IDs (sub_<timestamp>_<random>)
- subscribe_to_events() validates inputs (subscriber_id, caste, topic_pattern required)
- Validates filter_criteria JSON if provided (default {} for no filtering)
- Acquires file lock before read-modify-write
- Uses jq to append subscription to subscriptions array and update metrics
- Auto-creates topic if not exists (allows subscribing to topics before events published)
- Increments topic subscriber_count
- Tracks created_at timestamp, last_event_delivered (null initially), delivery_count (0 initially)
- unsubscribe_from_events() removes subscription and decrements subscriber_count
- list_subscriptions() optionally filters by subscriber_id
- All operations use atomic_write_from_file() for corruption safety
- Returns subscription_id on success
  </action>
  <verify>
# Source event-bus.sh and test subscribe
source .aether/utils/event-bus.sh

# Initialize event bus (if not already)
initialize_event_bus

# Test subscribe with sample subscription
sub_id=$(subscribe_to_events "verifier" "watcher" "phase_complete" '{"min_phase": 5}')

echo "Created subscription: $sub_id"

# Verify subscription in array
echo "Subscriptions:"
jq -r '.subscriptions[] | "\(.id): \(.subscriber_id) subscribes to \(.topic_pattern)"' .aether/data/events.json

# Verify topic subscriber_count updated
echo "Topic subscriber counts:"
jq '.topics | to_entries[] | "\(.key): \(.value.subscriber_count) subscribers"' .aether/data/events.json

# Verify metrics
echo "Total subscriptions: $(jq -r '.metrics.total_subscriptions' .aether/data/events.json)"

# Test list_subscriptions
echo "All subscriptions:"
list_subscriptions

# Test unsubscribe
unsubscribe_from_events "$sub_id"

echo "After unsubscribe, subscriptions: $(jq -r '.subscriptions | length' .aether/data/events.json)"
  </verify>
  <done>
subscribe_to_events() function successfully records subscriptions in events.json with subscriber_id, caste, topic_pattern, filter_criteria, created_at, last_event_delivered, delivery_count. Topic subscriber_count incremented. unsubscribe_from_events() removes subscriptions and decrements count. list_subscriptions() lists all or filtered subscriptions. All operations use file locking and atomic writes for safety.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test script demonstrating subscribe operation</name>
  <files>.aether/utils/test-event-subscribe.sh</files>
  <action>
Create .aether/utils/test-event-subscribe.sh with comprehensive tests:

```bash
#!/bin/bash
# Test script for event subscribe operation
# Usage: .aether/utils/test-event-subscribe.sh

SCRIPT_DIR="$(dirname "${BASH_SOURCE[0]}")"
source "${SCRIPT_DIR}/event-bus.sh"

echo "=== Event Subscribe Test Suite ==="
echo

# Initialize event bus
echo "1. Initializing event bus..."
initialize_event_bus
echo "✓ Event bus initialized"
echo

# Test 1: Basic subscribe
echo "2. Testing basic subscribe..."
sub_id=$(subscribe_to_events "verifier" "watcher" "phase_complete" '{"min_phase": 5}')
if [ -n "$sub_id" ] && [[ "$sub_id" == sub_* ]]; then
    echo "✓ Created subscription: $sub_id"
else
    echo "✗ Failed to create subscription"
    exit 1
fi
echo

# Test 2: Multiple subscriptions
echo "3. Testing multiple subscriptions..."
subscribe_to_events "logger" "architect" "error.*" '{}' > /dev/null
subscribe_to_events "coordinator" "route_setter" "spawn_request" '{"specialist_type": "database"}' > /dev/null
subscribe_to_events "executor" "builder" "task_*" '{}' > /dev/null
sub_count=$(jq -r '.subscriptions | length' "$EVENTS_FILE")
echo "✓ Created 3 additional subscriptions (total: $sub_count)"
echo

# Test 3: Verify subscription structure
echo "4. Verifying subscription structure..."
sub_json=$(jq -r '.subscriptions[-1]' "$EVENTS_FILE")
sub_has_id=$(echo "$sub_json" | jq -r '.id' | grep -c "sub_")
sub_has_pattern=$(echo "$sub_json" | jq -r '.topic_pattern' | grep -c "task_")
sub_has_filter=$(echo "$sub_json" | jq -r '.filter_criteria' | grep -c "{}")
if [ "$sub_has_id" -gt 0 ] && [ "$sub_has_pattern" -gt 0 ]; then
    echo "✓ Subscription structure valid"
else
    echo "✗ Subscription structure invalid"
    exit 1
fi
echo

# Test 4: Verify topic subscriber_count
echo "5. Verifying topic subscriber_count..."
task_subscriber_count=$(jq -r '.topics["task_*"].subscriber_count' "$EVENTS_FILE")
if [ "$task_subscriber_count" -gt 0 ]; then
    echo "✓ Topic subscriber_count updated (task_*: $task_subscriber_count)"
else
    echo "✗ Topic subscriber_count not updated"
    exit 1
fi
echo

# Test 5: Verify metrics
echo "6. Verifying metrics..."
total_subscriptions=$(jq -r '.metrics.total_subscriptions' "$EVENTS_FILE")
if [ "$total_subscriptions" -ge 4 ]; then
    echo "✓ Metrics updated (total_subscriptions: $total_subscriptions)"
else
    echo "✗ Metrics not updated correctly"
    exit 1
fi
echo

# Test 6: Wildcard topic patterns
echo "7. Testing wildcard topic patterns..."
subscribe_to_events "error_collector" "architect" "error.*" '{}' > /dev/null
error_star_exists=$(jq -r '.topics["error.*"]' "$EVENTS_FILE")
if [ "$error_star_exists" != "null" ]; then
    echo "✓ Wildcard topic pattern supported"
else
    echo "✗ Wildcard topic pattern not supported"
    exit 1
fi
echo

# Test 7: Filter criteria
echo "8. Testing filter criteria..."
subscribe_to_events "db_specialist" "builder" "spawn_request" '{"specialist_type": "database"}' > /dev/null
filter_valid=$(jq -r '.subscriptions[-1].filter_criteria.specialist_type' "$EVENTS_FILE")
if [ "$filter_valid" == "database" ]; then
    echo "✓ Filter criteria stored correctly"
else
    echo "✗ Filter criteria not stored"
    exit 1
fi
echo

# Test 8: List subscriptions
echo "9. Testing list_subscriptions..."
all_subs=$(list_subscriptions | wc -l)
filtered_subs=$(list_subscriptions "verifier" | wc -l)
echo "✓ All subscriptions: $all_subs, Filtered (verifier): $filtered_subs"
echo

# Test 9: Unsubscribe
echo "10. Testing unsubscribe..."
initial_count=$(jq -r '.subscriptions | length' "$EVENTS_FILE")
unsubscribe_from_events "$sub_id" > /dev/null
final_count=$(jq -r '.subscriptions | length' "$EVENTS_FILE")
if [ "$final_count" -lt "$initial_count" ]; then
    echo "✓ Unsubscribe successful (count: $initial_count → $final_count)"
else
    echo "✗ Unsubscribe failed"
    exit 1
fi
echo

# Test 10: Error handling - missing required arguments
echo "11. Testing error handling (missing arguments)..."
if subscribe_to_events "" "watcher" "test" '{}' 2>/dev/null; then
    echo "✗ Should have failed with missing subscriber_id"
    exit 1
else
    echo "✓ Correctly rejected missing subscriber_id"
fi
echo

echo "=== All Subscribe Tests Passed ==="
```

Make executable: chmod +x .aether/utils/test-event-subscribe.sh

Test script covers:
- Basic subscribe operation
- Multiple subscriptions with different patterns
- Subscription structure validation (ID, topic_pattern, filter_criteria)
- Topic subscriber_count verification
- Metrics verification (total_subscriptions)
- Wildcard topic patterns (error.* matches all error events)
- Filter criteria storage (JSON object with custom filters)
- List subscriptions (all and filtered by subscriber_id)
- Unsubscribe operation
- Error handling (rejects missing required arguments)
  </action>
  <verify>
# Run test script
.aether/utils/test-event-subscribe.sh

# Expected output: All tests pass with ✓ checkmarks
# Verify subscriptions.json has subscriptions
jq -r '.subscriptions | length' .aether/data/events.json
# Should show multiple subscriptions from tests
  </verify>
  <done>
test-event-subscribe.sh created with comprehensive test coverage. All tests pass: basic subscribe, multiple subscriptions, subscription structure, topic subscriber_count, metrics, wildcard patterns, filter criteria, list subscriptions, unsubscribe, error handling. Test script demonstrates subscribe operation works correctly with file locking, atomic writes, wildcard patterns, and filter criteria.
  </done>
</task>

</tasks>

<verification>
# Overall verification criteria

1. Subscribe operation works:
   - subscribe_to_events() function accepts subscriber_id, caste, topic_pattern, filter_criteria
   - Returns unique subscription_id on success
   - Writes subscription to subscriptions array in events.json

2. Subscription structure valid:
   - Each subscription has: id, subscriber_id, subscriber_caste, topic_pattern, filter_criteria, created_at, last_event_delivered, delivery_count
   - Unique IDs generated (sub_<timestamp>_<random>)
   - Timestamps in ISO 8601 UTC format

3. Topic management:
   - Topic subscriber_count incremented when subscription created
   - Auto-creates topic if not exists
   - Decrements subscriber_count when unsubscribing

4. Metrics updated:
   - total_subscriptions incremented
   - last_updated timestamp set

5. Wildcard support:
   - Topic patterns support wildcards (e.g., "error.*", "phase.*", "task_*")
   - Wildcards stored as-is (filtering applied during delivery)

6. Filter criteria:
   - Accepts JSON object for custom filtering
   - Stored in subscription for use during event delivery

7. Safety patterns:
   - File locking prevents concurrent corruption
   - Atomic writes prevent partial corruption
   - Input validation (required arguments, JSON validation)
</verification>

<success_criteria>
1. subscribe_to_events() function exists and is exported
2. Running subscribe_to_events("verifier", "watcher", "phase_complete", '{"min_phase": 5}') returns subscription_id
3. Subscription appears in events.json subscriptions array with all required fields
4. Topic subscriber_count incremented for subscribed topic
5. Metrics show total_subscriptions > 0
6. Wildcard patterns (error.*, task_*) supported
7. Filter criteria stored in subscription
8. unsubscribe_from_events() removes subscription and decrements subscriber_count
9. list_subscriptions() returns all or filtered subscriptions
10. Test script (test-event-subscribe.sh) passes all tests
</success_criteria>

<output>
After completion, create `.planning/phases/09-stigmergic-events/09-03-SUMMARY.md` with:
- subscribe_to_events() function signature and usage
- Subscription schema documentation (id, subscriber_id, topic_pattern, filter_criteria, delivery tracking)
- Wildcard pattern support (error.* matches all error events)
- Filter criteria usage examples
- Safety patterns used (file locking, atomic writes, input validation)
- Test results demonstrating subscription management
</output>
