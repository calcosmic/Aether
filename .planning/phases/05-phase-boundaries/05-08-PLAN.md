---
phase: 05-phase-boundaries
plan: 08
type: execute
wave: 4
depends_on: ["05-07", "05-06"]
files_modified:
  - .aether/utils/state-machine.sh
  - .aether/data/COLONY_STATE.json
  - .aether/data/pheromones.json
autonomous: true

must_haves:
  truths:
    - "Next phase adapts based on previous phase learnings"
    - "High-confidence patterns (0.7+) from previous phase influence next phase"
    - "FOCUS pheromones emitted for high-value areas from previous phase"
    - "REDIRECT pheromones emitted for constraints from previous phase"
    - "Success patterns from previous phase carried forward"
  artifacts:
    - path: ".aether/utils/state-machine.sh"
      provides: "adapt_next_phase_from_memory() function"
      exports: ["adapt_next_phase_from_memory"]
      contains: "adapt_next_phase_from_memory()"
    - path: ".aether/data/COLONY_STATE.json"
      provides: "phase roadmap with adaptation field"
      contains: "phases.roadmap[].adaptation"
  key_links:
    - from: "adapt_next_phase_from_memory()"
      to: ".aether/data/memory.json"
      via: "Reads previous phase patterns from long-term memory"
      pattern: "long_term_memory.*select.*confidence > 0.7"
    - from: "adapt_next_phase_from_memory()"
      to: ".aether/data/pheromones.json"
      via: "Emits FOCUS/REDIRECT pheromones based on patterns"
      pattern: "emit_focus_pheromone.*emit_redirect_pheromone"
    - from: "adapt_next_phase_from_memory()"
      to: ".aether/data/COLONY_STATE.json"
      via: "Stores adaptation in phase roadmap"
      pattern: "phases.roadmap[].adaptation"
---

<objective>
Implement next phase adaptation from previous phase memory using high-confidence patterns.

Purpose: Before planning next phase, colony reads previous phase's compressed memory and high-value patterns, then adapts next phase approach by emitting appropriate FOCUS and REDIRECT pheromones.

Output: adapt_next_phase_from_memory() function that reads memory, extracts patterns, emits pheromones, stores adaptation in colony state
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-phase-boundaries/05-RESEARCH.md
@.planning/phases/05-phase-boundaries/05-07-SUMMARY.md
@.aether/utils/state-machine.sh
@.aether/utils/memory-search.sh
@.aether/data/COLONY_STATE.json
@.aether/data/memory.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add adapt_next_phase_from_memory() to state-machine.sh</name>
  <files>.aether/utils/state-machine.sh</files>
  <action>
Add adapt_next_phase_from_memory() function to state-machine.sh:

**Function signature:**
```bash
adapt_next_phase_from_memory() {
    local current_phase="${1:-$(jq -r '.colony_status.current_phase' "$COLONY_STATE")}"
    # ... implementation
}
```

**Implementation:**

1. **Calculate next phase:**
   ```bash
   local next_phase=$((current_phase + 1))
   ```

2. **Read previous phase memory from short-term:**
   ```bash
   local memory_file=".aether/data/memory.json"

   # Check if memory file exists
   if [ ! -f "$memory_file" ]; then
       echo "Memory file not found. Skipping adaptation."
       return 0
   fi

   # Read previous phase compressed memory
   local phase_memory=$(jq -r "
       .short_term_memory[] |
       select(.metadata.phase == $current_phase) |
       .compressed_content
   " "$memory_file")
   ```

3. **Read high-confidence patterns from long-term:**
   ```bash
   local patterns=$(jq -r "
       .long_term_memory[] |
       select(.metadata.confidence > 0.7) |
       select(.metadata.phase == $current_phase)
   " "$memory_file")
   ```

4. **Extract pattern types:**
   ```bash
   # Focus preferences (areas that worked well)
   local focus_areas=$(echo "$patterns" | jq -r 'select(.type == "focus_preference") | .content')

   # Constraints (areas to avoid)
   local constraints=$(echo "$patterns" | jq -r 'select(.type == "constraint") | .content')

   # Success patterns (what worked)
   local success_patterns=$(echo "$patterns" | jq -r 'select(.type == "success_pattern") | .content')

   # Failure patterns (what didn't work)
   local failure_patterns=$(echo "$patterns" | jq -r 'select(.type == "failure_pattern") | .content')
   ```

5. **Adapt next phase by emitting pheromones:**

   **Emit FOCUS pheromones for high-value areas:**
   ```bash
   if [ -n "$focus_areas" ]; then
       echo "$focus_areas" | while read -r area; do
           if [ -n "$area" ]; then
               # Use emit_focus_pheromone if available (from Phase 3)
               if type emit_focus_pheromone >/dev/null 2>&1; then
                   emit_focus_pheromone "$area" 0.8
                   echo "  ‚Üí FOCUS: $area (strength: 0.8)"
               fi
           fi
       done
   fi
   ```

   **Emit REDIRECT pheromones for constraints:**
   ```bash
   if [ -n "$constraints" ]; then
       echo "$constraints" | while read -r pattern; do
           if [ -n "$pattern" ]; then
               if type emit_redirect_pheromone >/dev/null 2>&1; then
                   emit_redirect_pheromone "$pattern" 0.9
                   echo "  ‚Üí REDIRECT: $pattern (strength: 0.9)"
               fi
           fi
       done
   fi
   ```

6. **Store adaptation in colony state:**
   ```bash
   jq --arg next "$next_phase" \
      --argjson focus "$(echo "$focus_areas" | jq -R -s -c 'split("\n") | map(select(length > 0))')" \
      --argjson constraints "$(echo "$constraints" | jq -R -s -c 'split("\n") | map(select(length > 0))')" \
      --argjson successes "$(echo "$success_patterns" | jq -R -s -c 'split("\n") | map(select(length > 0))')" \
      --argjson failures "$(echo "$failure_patterns" | jq -R -s -c 'split("\n") | map(select(length > 0))')" \
      '
      .phases.roadmap[$next | tonumber - 1].adaptation = {
        "inherited_focus": $focus,
        "inherited_constraints": $constraints,
        "success_patterns": $successes,
        "failure_patterns": $failures,
        "adapted_from": ($next | tonumber - 1 | tostring),
        "adapted_at": "$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
      }
      ' "$COLONY_STATE" > /tmp/state.tmp

   atomic_write_from_file "$COLONY_STATE" /tmp/state.tmp
   rm -f /tmp/state.tmp
   ```

7. **Echo adaptation summary:**
   ```bash
   echo "Next phase $next_phase adapted from previous phase $current_phase"
   echo "  Focus areas: $(echo "$focus_areas" | jq -R -s 'split("\n") | map(select(length > 0)) | length')"
   echo "  Constraints: $(echo "$constraints" | jq -R -s 'split("\n") | map(select(length > 0)) | length')"
   echo "  Success patterns: $(echo "$success_patterns" | jq -R -s 'split("\n") | map(select(length > 0)) | length')"
   ```

**Important:**
- Source memory-search.sh if exists (from Phase 4)
- Use emit_focus_pheromone and emit_redirect_pheromone if available (from Phase 3)
- Only adapt if patterns exist with confidence > 0.7
- Store adaptation in next phase's roadmap entry
- Export function: export -f adapt_next_phase_from_memory

**Error handling:** If memory system not yet available (Phase 1-3), skip adaptation gracefully:
```bash
if [ ! -f "$memory_file" ]; then
    echo "Memory system not yet available. Skipping adaptation."
    return 0
fi
```
  </action>
  <verify>
```bash
# Source dependencies
source .aether/utils/atomic-write.sh
source .aether/utils/state-machine.sh

# Test 1: Function exists
type adapt_next_phase_from_memory >/dev/null 2>&1 || { echo "Function not found"; exit 1; }

# Test 2: Run adaptation (may skip if no memory)
adapt_next_phase_from_memory "4" || { echo "adapt_next_phase_from_memory failed"; exit 1; }

# Test 3: Verify adaptation field created (if memory exists)
if [ -f ".aether/data/memory.json" ]; then
    adaptation=$(jq -r '.phases.roadmap[4].adaptation' .aether/data/COLONY_STATE.json)
    [ "$adaptation" != "null" ] || { echo "Adaptation not created"; exit 1; }

    # Verify adaptation fields
    echo "$adaptation" | jq -e '.inherited_focus' >/dev/null || { echo "Missing inherited_focus"; exit 1; }
    echo "$adaptation" | jq -e '.inherited_constraints' >/dev/null || { echo "Missing inherited_constraints"; exit 1; }
    echo "$adaptation" | jq -e '.success_patterns' >/dev/null || { echo "Missing success_patterns"; exit 1; }
fi

echo "All adapt_next_phase_from_memory tests passed"
```
  </verify>
  <done>
adapt_next_phase_from_memory() reads previous phase patterns, emits FOCUS/REDIRECT pheromones, stores adaptation in colony state
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate adaptation into Queen check-in workflow</name>
  <files>.aether/utils/state-machine.sh</files>
<action>
Update await_queen_decision() in state-machine.sh to trigger adaptation:

**After setting queen_checkin status, add:**

```bash
# Display check-in message
echo ""
echo "üêú COLONY CHECK-IN: Phase $phase complete"
echo "   Review with: /ant:phase $phase"
echo "   Options: /ant:continue, /ant:adjust, /ant:retry"
echo ""

# Adapt next phase from memory
echo "Adapting next phase from memory..."
adapt_next_phase_from_memory "$phase"
echo ""
```

**Location:** In await_queen_decision() function, after displaying check-in message, before returning.

**Behavior:**
- When phase boundary reached and Queen check-in occurs
- Colony automatically adapts next phase from previous phase memory
- FOCUS and REDIRECT pheromones emitted based on high-confidence patterns
- Adaptation stored in next phase's roadmap entry
- Queen sees adaptation summary in check-in message

**Note:** This ensures adaptation happens automatically at phase boundaries, maintaining emergence philosophy. Queen can still adjust pheromones via /ant:adjust if desired.
  </action>
  <verify>
```bash
# Source dependencies
source .aether/utils/atomic-write.sh
source .aether/utils/state-machine.sh

# Test 1: Trigger Queen check-in (which should trigger adaptation)
# Note: This is hard to test without full phase execution
# For now, verify function exists and is callable

# Test 2: Verify adaptation can be called manually
adapt_next_phase_from_memory "4" || { echo "Manual adaptation failed"; exit 1; }

# Test 3: Check adaptation stored (if memory exists)
if [ -f ".aether/data/memory.json" ]; then
    adaptation=$(jq -r '.phases.roadmap[4].adaptation' .aether/data/COLONY_STATE.json)
    if [ "$adaptation" != "null" ]; then
        adapted_at=$(echo "$adaptation" | jq -r '.adapted_at')
        [ -n "$adapted_at" ] || { echo "adapted_at not set"; exit 1; }
    fi
fi

echo "All adaptation integration tests passed"
```
  </verify>
  <done>
await_queen_decision() calls adapt_next_phase_from_memory(), adaptation happens at phase boundaries, Queen sees adaptation summary
  </done>
</task>

</tasks>

<verification>
1. adapt_next_phase_from_memory() function exists and is exported
2. Function reads previous phase memory from memory.json
3. High-confidence patterns (0.7+) extracted from long-term memory
4. FOCUS pheromones emitted for focus_preferences
5. REDIRECT pheromones emitted for constraints
6. Adaptation stored in COLONY_STATE.json phases.roadmap[].adaptation
7. Adaptation includes inherited_focus, inherited_constraints, success_patterns, failure_patterns
8. await_queen_decision() triggers adaptation automatically
9. Adaptation happens at phase boundaries (after phase complete, before next phase)
10. Queen can still adjust pheromones via /ant:adjust (manual override)
</verification>

<success_criteria>
1. adapt_next_phase_from_memory() reads memory and extracts patterns
2. Next phase planning influenced by previous phase learnings
3. FOCUS/REDIRECT pheromones emitted based on patterns
4. Adaptation stored in colony state for reference
5. Automatic adaptation at phase boundaries
6. Queen retains ability to manually adjust
7. Learning loop established (colony improves over time)
8. Memory system integration verified
</success_criteria>

<output>
After completion, create `.planning/phases/05-phase-boundaries/05-08-SUMMARY.md` with:
- adapt_next_phase_from_memory() implementation verified
- Pattern extraction and pheromone emission tested
- Adaptation storage in colony state documented
- Files modified
</output>
