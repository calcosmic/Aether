---
phase: 05-phase-boundaries
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .aether/utils/state-machine.sh
  - .aether/data/COLONY_STATE.json
autonomous: true

must_haves:
  truths:
    - "State transitions triggered by pheromone signals"
    - "Transition function updates colony state atomically"
    - "File lock acquired before state transition (prevents concurrent transitions)"
    - "Pheromone trigger recorded in state metadata"
  artifacts:
    - path: ".aether/utils/state-machine.sh"
      provides: "transition_state() function with pheromone triggers"
      exports: ["transition_state"]
      contains: "transition_state()"
    - path: ".aether/data/COLONY_STATE.json"
      provides: "State updated via jq with history tracking"
      contains: "colony_status.state"
  key_links:
    - from: "transition_state()"
      to: ".aether/data/COLONY_STATE.json"
      via: "jq updates state and state_machine.history"
      pattern: "jq --arg new.*.colony_status.state = \$new"
    - from: "transition_state()"
      to: "file-lock.sh"
      via: "acquire_lock before transition, release_lock after"
      pattern: "acquire_lock.*release_lock"
---

<objective>
Implement pheromone-triggered state transition logic with file locking and atomic writes.

Purpose: Enable colony to transition between states (IDLE→INIT→PLANNING→EXECUTING→VERIFYING→COMPLETED/FAILED) in response to pheromone signals, with thread-safety and corruption prevention.

Output: transition_state() function in state-machine.sh that updates colony state atomically with validation and locking
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-phase-boundaries/05-RESEARCH.md
@.aether/data/COLONY_STATE.json
@.aether/utils/state-machine.sh
@.aether/utils/atomic-write.sh
@.aether/utils/file-lock.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement transition_state() function in state-machine.sh</name>
  <files>.aether/utils/state-machine.sh</files>
  <action>
Add transition_state() function to state-machine.sh with the following implementation:

**Function signature:**
```bash
transition_state() {
    local new_state="$1"
    local trigger_pheromone="${2:-manual}"
    # ... implementation
}
```

**Implementation steps:**

1. **Acquire file lock** (prevents concurrent transitions)
   - Use acquire_lock "$COLONY_STATE"
   - If lock fails, echo error and return 1
   - Trap cleanup to ensure release_lock on exit

2. **Read current state**
   - Use existing get_current_state() function
   - Store in local variable current_state

3. **Validate transition** using is_valid_transition()
   - If invalid: echo "Invalid transition: $current_state -> $new_state"
   - Release lock and return 1

4. **Generate transition metadata**
   - timestamp: `date -u +"%Y-%m-%dT%H:%M:%SZ"`
   - checkpoint: "checkpoint_$(get_next_checkpoint_number).json" (placeholder for 05-03)

5. **Update COLONY_STATE.json** via jq with atomic write:
   ```bash
   jq --arg current "$current_state" \
      --arg new "$new_state" \
      --arg trigger "$trigger_pheromone" \
      --arg timestamp "$timestamp" \
      --arg checkpoint "$checkpoint" \
      '
      .colony_status.state = $new |
      .state_machine.last_transition = $timestamp |
      .state_machine.transitions_count += 1 |
      .state_machine.state_history += [{
        "from": $current,
        "to": $new,
        "trigger": $trigger,
        "timestamp": $timestamp,
        "checkpoint": $checkpoint
      }]
      ' "$COLONY_STATE" > /tmp/state_transition.tmp
   ```

6. **Atomic write** using atomic_write_from_file
   - Target: "$COLONY_STATE"
   - Source: /tmp/state_transition.tmp
   - Cleanup temp file on success/failure

7. **Release lock** and return 0

8. **Echo confirmation message:**
   ```bash
   echo "State transition: $current_state -> $new_state"
   echo "Trigger: $trigger_pheromone"
   echo "Timestamp: $timestamp"
   ```

**Important:**
- Set COLONY_STATE=".aether/data/COLONY_STATE.json" at top of file
- Export function with export -f transition_state
- Use get_next_checkpoint_number() helper (will be implemented in 05-03, for now return 0)

**Helper function to add:**
```bash
get_next_checkpoint_number() {
    jq -r '.checkpoints.checkpoint_count // 0' "$COLONY_STATE"
}
```
  </action>
  <verify>
```bash
# Source dependencies
source .aether/utils/file-lock.sh
source .aether/utils/atomic-write.sh
source .aether/utils/state-machine.sh

# Test 1: Valid transition with pheromone trigger
transition_state "INIT" "INIT_pheromone" || { echo "Transition failed"; exit 1; }
state=$(get_current_state)
[ "$state" = "INIT" ] || { echo "Expected INIT, got $state"; exit 1; }

# Test 2: Invalid transition rejected
if transition_state "FAILED" "manual"; then
    echo "INIT->FAILED should be invalid"
    exit 1
fi

# Test 3: State history updated
history_count=$(jq -r '.state_machine.transitions_count' .aether/data/COLONY_STATE.json)
[ "$history_count" -ge 1 ] || { echo "History count should be >=1"; exit 1; }

# Test 4: Transition metadata recorded
last_trigger=$(jq -r '.state_machine.state_history[-1].trigger' .aether/data/COLONY_STATE.json)
[ "$last_trigger" = "INIT_pheromone" ] || { echo "Trigger not recorded"; exit 1; }

# Reset to IDLE for other tests
transition_state "IDLE" "test_reset"

echo "All transition_state tests passed"
```
  </verify>
  <done>
transition_state() function successfully transitions states, updates history atomically, rejects invalid transitions, records pheromone triggers
  </done>
</task>

</tasks>

<verification>
1. transition_state "IDLE" "INIT" succeeds with pheromone trigger
2. Invalid transition (INIT→FAILED) is rejected with error message
3. COLONY_STATE.json state field updated to new state
4. state_machine.last_transition timestamp recorded
5. state_machine.transitions_count incremented
6. state_machine.state_history array has new entry with from/to/trigger/timestamp/checkpoint
7. File lock prevents concurrent transitions (manual check - two shells)
8. JSON remains valid after transition
</verification>

<success_criteria>
1. transition_state() function exists and is exported
2. Acquires lock before transition, releases after
3. Validates transitions using is_valid_transition()
4. Updates COLONY_STATE.json atomically
5. Records transition metadata in state_history
6. Works with pheromone triggers (INIT_pheromone, phase_complete_pheromone, etc.)
</success_criteria>

<output>
After completion, create `.planning/phases/05-phase-boundaries/05-02-SUMMARY.md` with:
- transition_state() implementation details
- Test results showing valid/invalid transitions
- State history recording verified
- Files modified
</output>
