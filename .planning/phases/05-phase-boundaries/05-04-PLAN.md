---
phase: 05-phase-boundaries
plan: 04
type: execute
wave: 2
depends_on: ["05-03"]
files_modified:
  - .aether/utils/checkpoint.sh
  - .aether/utils/state-machine.sh
autonomous: true

must_haves:
  truths:
    - "Pre-transition checkpoint saved before state change"
    - "Post-transition checkpoint saved after state change"
    - "Colony can recover from checkpoint after crash"
    - "Checkpoint restoration updates all colony state files atomically"
  artifacts:
    - path: ".aether/utils/state-machine.sh"
      provides: "transition_state() with pre/post checkpoint calls"
      contains: "save_checkpoint.*pre_.*save_checkpoint.*post_"
    - path: ".aether/utils/checkpoint.sh"
      provides: "load_checkpoint() function for recovery"
      exports: ["load_checkpoint"]
  key_links:
    - from: "transition_state()"
      to: "save_checkpoint()"
      via: "Pre-transition: save_checkpoint pre_X_to_Y"
      pattern: "save_checkpoint \"pre_\${current_state}_to_\${new_state}\""
    - from: "transition_state()"
      to: "save_checkpoint()"
      via: "Post-transition: save_checkpoint post_X_to_Y"
      pattern: "save_checkpoint \"post_\${current_state}_to_\${new_state}\""
    - from: "load_checkpoint()"
      to: ".aether/data/COLONY_STATE.json"
      via: "Restore colony_state field from checkpoint"
      pattern: "jq '.colony_state'.*atomic_write_from_file"
---

<objective>
Integrate pre/post-transition checkpoints into state transitions and implement recovery mechanism.

Purpose: Ensure colony can recover from crashes by saving checkpoints before and after every state transition. Recovery function restores colony to last known good state.

Output: Updated transition_state() with checkpoint calls, load_checkpoint() function for recovery, /ant:recover command
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-phase-boundaries/05-RESEARCH.md
@.planning/phases/05-phase-boundaries/05-02-SUMMARY.md
@.planning/phases/05-phase-boundaries/05-03-SUMMARY.md
@.aether/utils/state-machine.sh
@.aether/utils/checkpoint.sh
@.aether/data/COLONY_STATE.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add load_checkpoint() function to checkpoint.sh</name>
  <files>.aether/utils/checkpoint.sh</files>
  <action>
Add load_checkpoint() function to checkpoint.sh:

**Function signature:**
```bash
load_checkpoint() {
    local checkpoint_id="${1:-latest}"
    # ... implementation
}
```

**Implementation:**

1. **Determine checkpoint file path:**
   - If checkpoint_id is "latest" (default):
     - Read checkpoint file path from CHECKPOINT_FILE
     - Path should be like "checkpoint_001.json"
     - Prepend CHECKPOINT_DIR to get full path
   - Otherwise:
     - Construct path: "${CHECKPOINT_DIR}/checkpoint_${checkpoint_id}.json"

2. **Verify checkpoint exists:**
   ```bash
   if [ ! -f "$checkpoint_file" ]; then
       echo "Checkpoint not found: $checkpoint_file"
       return 1
   fi
   ```

3. **Verify checkpoint integrity** with python3:
   ```bash
   if ! python3 -c "import json; json.load(open('$checkpoint_file'))" 2>/dev/null; then
       echo "Checkpoint corrupted: $checkpoint_file"
       return 1
   fi
   ```

4. **Restore COLONY_STATE.json:**
   ```bash
   echo "Restoring COLONY_STATE.json..."
   jq '.colony_state' "$checkpoint_file" | \
       atomic_write_from_file "$COLONY_STATE" /dev/stdin
   ```

5. **Restore pheromones.json:**
   ```bash
   jq '.pheromones' "$checkpoint_file" | \
       atomic_write_from_file "$PHEROMONES_FILE" /dev/stdin
   ```

6. **Restore worker_ants.json:**
   ```bash
   jq '.worker_ants' "$checkpoint_file" | \
       atomic_write_from_file "$WORKER_ANTS_FILE" /dev/stdin
   ```

7. **Restore memory.json:**
   ```bash
   jq '.memory' "$checkpoint_file" | \
       atomic_write_from_file "$MEMORY_FILE" /dev/stdin
   ```

8. **Display recovery summary:**
   ```bash
   local restored_state=$(jq -r '.colony_status.state' "$COLONY_STATE")
   local restored_phase=$(jq -r '.colony_status.current_phase' "$COLONY_STATE")

   echo "Colony restored from checkpoint: $checkpoint_file"
   echo "Restored state: $restored_state"
   echo "Restored phase: $restored_phase"
   echo ""
   echo "Next steps:"
   echo "  - Review state: /ant:status"
   echo "  - Continue phase: /ant:execute $restored_phase"
   ```

9. **Return 0 on success**

**Export function:** export -f load_checkpoint
  </action>
  <verify>
```bash
# Source dependencies
source .aether/utils/atomic-write.sh
source .aether/utils/checkpoint.sh

# Test 1: Create a checkpoint first (if not exists)
if [ ! -f ".aether/data/checkpoint.json" ]; then
    save_checkpoint "test_for_recovery" || { echo "Setup failed"; exit 1; }
fi

# Test 2: Save current state for comparison
original_state=$(jq -r '.colony_status.state' .aether/data/COLONY_STATE.json)

# Test 3: Modify state (simulate corruption)
jq '.colony_status.state = "CORRUPT"' .aether/data/COLONY_STATE.json > /tmp/corrupt.tmp
cp /tmp/corrupt.tmp .aether/data/COLONY_STATE.json
corrupt_state=$(jq -r '.colony_status.state' .aether/data/COLONY_STATE.json)
[ "$corrupt_state" = "CORRUPT" ] || { echo "State not corrupted"; exit 1; }

# Test 4: Load checkpoint and restore
load_checkpoint "latest" || { echo "load_checkpoint failed"; exit 1; }

# Test 5: Verify state restored
restored_state=$(jq -r '.colony_status.state' .aether/data/COLONY_STATE.json)
[ "$restored_state" = "$original_state" ] || { echo "State not restored: expected $original_state, got $restored_state"; exit 1; }

echo "All load_checkpoint tests passed"
```
  </verify>
  <done>
load_checkpoint() successfully restores colony state from checkpoint file, verifies integrity, updates all colony JSON files atomically
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate pre/post checkpoints into transition_state()</name>
  <files>.aether/utils/state-machine.sh</files>
  <action>
Update transition_state() function in state-machine.sh to call save_checkpoint():

**Add at top of file:**
```bash
source .aether/utils/checkpoint.sh
```

**In transition_state() function, add checkpoint calls:**

1. **After lock acquisition, before state update:**
   ```bash
   # Pre-transition checkpoint
   echo "Saving pre-transition checkpoint..."
   save_checkpoint "pre_${current_state}_to_${new_state}"
   ```

2. **After atomic write, before lock release:**
   ```bash
   # Post-transition checkpoint
   echo "Saving post-transition checkpoint..."
   save_checkpoint "post_${current_state}_to_${new_state}"
   ```

**Important:** Keep checkpoint calls within the locked section to ensure consistency. If checkpoint fails, the entire transition should fail.

**Error handling:** If either save_checkpoint fails, release lock and return 1:
```bash
if ! save_checkpoint "pre_${current_state}_to_${new_state}"; then
    echo "Pre-transition checkpoint failed"
    release_lock
    return 1
fi
```

**Verify checkpoint files exist after transition:**
- Two new checkpoint files should be created for each transition
- Labels: "pre_X_to_Y" and "post_X_to_Y"
- Both contain complete colony state
  </action>
  <verify>
```bash
# Source dependencies
source .aether/utils/file-lock.sh
source .aether/utils/atomic-write.sh
source .aether/utils/state-machine.sh

# Get initial checkpoint count
initial_count=$(jq -r '.checkpoints.checkpoint_count' .aether/data/COLONY_STATE.json)

# Test 1: Perform transition with checkpoints
transition_state "INIT" "test_pheromone" || { echo "Transition failed"; exit 1; }

# Test 2: Verify 2 checkpoints created (pre + post)
final_count=$(jq -r '.checkpoints.checkpoint_count' .aether/data/COLONY_STATE.json)
expected=$((initial_count + 2))
[ "$final_count" -eq "$expected" ] || { echo "Expected $expected checkpoints, got $final_count"; exit 1; }

# Test 3: Verify pre-checkpoint exists
pre_checkpoint="${CHECKPOINT_DIR:-.aether/data/checkpoints}/checkpoint_$(($initial_count + 1)).json"
[ -f "$pre_checkpoint" ] || { echo "Pre-checkpoint not found"; exit 1; }
pre_label=$(jq -r '.label' "$pre_checkpoint")
[[ "$pre_label" == pre_IDLE_to_INIT* ]] || { echo "Pre-checkpoint label wrong: $pre_label"; exit 1; }

# Test 4: Verify post-checkpoint exists
post_checkpoint="${CHECKPOINT_DIR:-.aether/data/checkpoints}/checkpoint_$(($initial_count + 2)).json"
[ -f "$post_checkpoint" ] || { echo "Post-checkpoint not found"; exit 1; }
post_label=$(jq -r '.label' "$post_checkpoint")
[[ "$post_label" == post_IDLE_to_INIT* ]] || { echo "Post-checkpoint label wrong: $post_label"; exit 1; }

# Test 5: Verify state changed
state=$(get_current_state)
[ "$state" = "INIT" ] || { echo "State not changed: $state"; exit 1; }

# Reset for other tests
transition_state "IDLE" "test_reset"

echo "All pre/post checkpoint tests passed"
```
  </verify>
  <done>
transition_state() saves pre and post checkpoints, checkpoint files exist with correct labels, state transitions work with checkpointing
  </done>
</task>

</tasks>

<verification>
1. load_checkpoint() restores colony from "latest" checkpoint
2. load_checkpoint() restores colony from specific checkpoint ID
3. Restored state matches checkpoint state
4. Corrupted checkpoint detection works (python3 validation)
5. transition_state() creates 2 checkpoints per transition (pre + post)
6. Checkpoint labels are "pre_X_to_Y" and "post_X_to_Y"
7. Both pre and post checkpoints contain complete colony state
8. Checkpoint failure causes transition failure (rollback behavior)
</verification>

<success_criteria>
1. load_checkpoint() function exists and is exported
2. Restores all 4 colony state files (COLONY_STATE, pheromones, worker_ants, memory)
3. Validates checkpoint integrity before restoration
4. transition_state() calls save_checkpoint() twice (pre and post)
5. Checkpoint failures are handled properly
6. Recovery workflow end-to-end verified
</success_criteria>

<output>
After completion, create `.planning/phases/05-phase-boundaries/05-04-SUMMARY.md` with:
- load_checkpoint() implementation verified
- Pre/post checkpoint integration tested
- Recovery workflow documented
- Files modified
</output>
