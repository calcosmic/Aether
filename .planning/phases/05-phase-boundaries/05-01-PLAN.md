---
phase: 05-phase-boundaries
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .aether/data/COLONY_STATE.json
  - .aether/utils/state-machine.sh
autonomous: true

must_haves:
  truths:
    - "Colony has explicit states (IDLE, INIT, PLANNING, EXECUTING, VERIFYING, COMPLETED, FAILED)"
    - "State is stored in COLONY_STATE.json and can be read via jq"
    - "Valid state transitions are defined and enforced"
    - "State machine utility (state-machine.sh) is sourced and functions exported"
  artifacts:
    - path: ".aether/utils/state-machine.sh"
      provides: "State transition logic with validation"
      exports: ["is_valid_transition", "get_current_state", "get_valid_states"]
      min_lines: 80
    - path: ".aether/data/COLONY_STATE.json"
      provides: "State machine schema with valid_states array"
      contains: "state_machine.valid_states"
  key_links:
    - from: ".aether/utils/state-machine.sh"
      to: ".aether/data/COLONY_STATE.json"
      via: "jq reads current_state and valid_states"
      pattern: "jq -r '.colony_status.state|.state_machine.valid_states'"
---

<objective>
Define state machine schema and implement state transition logic with validation.

Purpose: Establish the foundation for colony state management - explicit states, valid transitions, and transition validation function.

Output: state-machine.sh utility with transition validation, updated COLONY_STATE.json with state_machine foundation
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-phase-boundaries/05-RESEARCH.md
@.aether/data/COLONY_STATE.json
@.aether/utils/atomic-write.sh
@.aether/utils/file-lock.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state-machine.sh utility with transition validation</name>
  <files>.aether/utils/state-machine.sh</files>
  <action>
Create state-machine.sh with the following functions:

1. **get_current_state()**: Read current state from COLONY_STATE.json
   - Use jq: `jq -r '.colony_status.state'`
   - Returns state string or "IDLE" if not set

2. **get_valid_states()**: List all valid states
   - Use jq to read state_machine.valid_states array
   - Returns newline-separated list

3. **is_valid_state()**: Check if a state is valid
   - Args: state_name
   - Returns 0 if valid, 1 if not

4. **is_valid_transition()**: Validate state transitions
   - Args: from_state, to_state
   - Define valid transition matrix (associative array):
     - IDLE → INIT
     - INIT → PLANNING
     - PLANNING → EXECUTING
     - EXECUTING → VERIFYING
     - VERIFYING → COMPLETED
     - VERIFYING → EXECUTING (retry on failure)
     - EXECUTING → FAILED
     - FAILED → PLANNING (recovery)
     - COMPLETED → IDLE
   - Returns 0 if valid, 1 if not

5. **validate_transition()**: Wrapper with error messages
   - Args: from_state, to_state
   - Prints "Invalid transition: X -> Y" if invalid
   - Returns exit code for scripting

**Important:** Source atomic-write.sh and file-lock.sh at top of file. Export all functions with `export -f`.

**File header:**
```bash
#!/bin/bash
# Aether State Machine Utility
# Implements state machine logic for colony orchestration
#
# Usage:
#   source .aether/utils/state-machine.sh
#   is_valid_transition "IDLE" "INIT" && echo "Valid"
```
  </action>
  <verify>
```bash
# Test 1: Source file without errors
source .aether/utils/state-machine.sh || exit 1

# Test 2: Get current state
state=$(get_current_state)
[ "$state" = "IDLE" ] || { echo "Expected IDLE, got $state"; exit 1; }

# Test 3: Validate good transition
is_valid_transition "IDLE" "INIT" || { echo "IDLE->INIT should be valid"; exit 1; }

# Test 4: Reject bad transition
is_valid_transition "COMPLETED" "EXECUTING" && { echo "COMPLETED->EXECUTING should be invalid"; exit 1; }

# Test 5: Get valid states count
count=$(get_valid_states | wc -l)
[ "$count" -eq 7 ] || { echo "Expected 7 valid states, got $count"; exit 1; }

echo "All state machine tests passed"
```
  </verify>
  <done>
State machine utility exists, exports 5 functions, all validation tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Enhance COLONY_STATE.json with state history foundation</name>
  <files>.aether/data/COLONY_STATE.json</files>
  <action>
Update COLONY_STATE.json state_machine section to include:

1. **state_history** array (currently empty, will be populated in 05-06):
   - Structure: `{from, to, trigger, timestamp, checkpoint}`
   - Initialized as empty array: []

2. **Verify existing fields** present:
   - valid_states: ["IDLE", "INIT", "PLANNING", "EXECUTING", "VERIFYING", "COMPLETED", "FAILED"]
   - last_transition: null
   - transitions_count: 0

**Use atomic-write.sh pattern:**
1. Read current COLONY_STATE.json
2. Use jq to update state_machine section (ensure state_history exists)
3. Write via atomic_write_from_file

**jq update:**
```bash
jq '
  .state_machine.state_history = (.state_machine.state_history // [])
' COLONY_STATE.json > /tmp/colony_state.tmp
atomic_write_from_file ".aether/data/COLONY_STATE.json" /tmp/colony_state.tmp
rm -f /tmp/colony_state.tmp
```

**Note:** colony_status.state already contains "IDLE", state_machine.valid_states already exists. This task ensures state_history array exists for later use.
  </action>
  <verify>
```bash
# Verify state_history array exists
history=$(jq -r '.state_machine.state_history' .aether/data/COLONY_STATE.json)
[ "$history" = "[]" ] || { echo "state_history should be empty array"; exit 1; }

# Verify valid_states has 7 states
count=$(jq -r '.state_machine.valid_states | length' .aether/data/COLONY_STATE.json)
[ "$count" -eq 7 ] || { echo "Expected 7 valid states, got $count"; exit 1; }

# Verify JSON is valid
python3 -c "import json; json.load(open('.aether/data/COLONY_STATE.json'))" || { echo "Invalid JSON"; exit 1; }

echo "COLONY_STATE.json state_machine section verified"
```
  </verify>
  <done>
COLONY_STATE.json has state_history array, valid_states (7 states), last_transition, transitions_count
  </done>
</task>

</tasks>

<verification>
1. Source state-machine.sh without errors
2. get_current_state returns "IDLE"
3. is_valid_transition validates all 9 valid transitions
4. is_valid_transition rejects invalid transitions (COMPLETED→EXECUTING, INIT→FAILED)
5. get_valid_states returns all 7 states
6. COLONY_STATE.json has state_history array
7. All JSON is valid (python3 json.load)
</verification>

<success_criteria>
1. State machine utility exists at .aether/utils/state-machine.sh
2. 5 functions exported: get_current_state, get_valid_states, is_valid_state, is_valid_transition, validate_transition
3. Valid transition matrix covers all 9 valid transitions from roadmap
4. Invalid transitions are rejected
5. COLONY_STATE.json has state_history array ready for tracking
</success_criteria>

<output>
After completion, create `.planning/phases/05-phase-boundaries/05-01-SUMMARY.md` with:
- Functions created (state-machine.sh)
- Valid transition matrix documented
- Verification results
- Files modified
</output>
