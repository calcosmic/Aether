---
phase: 05-phase-boundaries
plan: 05
type: execute
wave: 3
depends_on: ["05-03", "05-04"]
files_modified:
  - .claude/commands/ant/recover.md
autonomous: true

must_haves:
  truths:
    - "Queen can run /ant:recover to restore colony from checkpoint"
    - "/ant:recover lists available checkpoints with labels and timestamps"
    - "/ant:recover [id] restores colony from specific checkpoint"
    - "Crash detection runs automatically on colony initialization"
  artifacts:
    - path: ".claude/commands/ant/recover.md"
      provides: "Queen command for checkpoint recovery"
      contains: "/ant:recover"
    - path: ".aether/utils/checkpoint.sh"
      provides: "detect_crash_and_recover() function"
      exports: ["detect_crash_and_recover"]
  key_links:
    - from: "/ant:recover"
      to: "load_checkpoint()"
      via: "Bash command sources checkpoint.sh and calls load_checkpoint"
      pattern: "load_checkpoint.*\$1"
    - from: "detect_crash_and_recover()"
      to: "load_checkpoint()"
      via: "Auto-recovery on crash detection"
      pattern: "detect_crash_and_recover.*load_checkpoint"
---

<objective>
Create /ant:recover command and automatic crash detection for colony self-healing.

Purpose: Enable Queen to manually recover colony from checkpoints, and automatically recover from crashes when colony restarts in inconsistent state.

Output: /ant:recover command with checkpoint listing, specific checkpoint recovery, automatic crash detection
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-phase-boundaries/05-RESEARCH.md
@.planning/phases/05-phase-boundaries/05-04-SUMMARY.md
@.claude/commands/ant/status.md
@.aether/utils/checkpoint.sh
@.aether/data/COLONY_STATE.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add detect_crash_and_recover() to checkpoint.sh</name>
  <files>.aether/utils/checkpoint.sh</files>
  <action>
Add detect_crash_and_recover() function to checkpoint.sh:

**Function signature:**
```bash
detect_crash_and_recover() {
    # ... implementation
}
```

**Implementation:**

1. **Read current colony state:**
   ```bash
   local current_state=$(jq -r '.colony_status.state' "$COLONY_STATE")
   local current_phase=$(jq -r '.colony_status.current_phase' "$COLONY_STATE")
   ```

2. **Check for crash indicators:**
   - **Crash if:** State is EXECUTING or VERIFYING BUT no active workers
   - **Crash if:** State has been EXECUTING/VERIFYING for >30 minutes with no activity

   ```bash
   if [ "$current_state" = "EXECUTING" ] || [ "$current_state" = "VERIFYING" ]; then
       # Check if worker_ants.json exists
       if [ -f "$WORKER_ANTS_FILE" ]; then
           local active_workers=$(jq -r '.active_workers | length' "$WORKER_ANTS_FILE")

           if [ "$active_workers" -eq 0 ]; then
               echo "Crash detected: State=$current_state but no active workers"
               echo "Recovering from last checkpoint..."
               load_checkpoint "latest"

               # Transition to PLANNING for retry
               transition_state "PLANNING" "crash_recovery"
               return 0
           fi
       fi
   fi
   ```

3. **Check for timeout (30 minutes in EXECUTING/VERIFYING):**
   ```bash
   local last_transition=$(jq -r '.state_machine.last_transition' "$COLONY_STATE")
   if [ -n "$last_transition" ] && [ "$last_transition" != "null" ]; then
       local current_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
       local elapsed=$(($(date -d "$current_time" +%s) - $(date -d "$last_transition" +%s)))

       # 30 minutes = 1800 seconds
       if [ $elapsed -gt 1800 ]; then
           if [ "$current_state" = "EXECUTING" ] || [ "$current_state" = "VERIFYING" ]; then
               echo "Timeout detected: State=$current_state for >30 minutes"
               echo "Recovering from last checkpoint..."
               load_checkpoint "latest"
               transition_state "PLANNING" "timeout_recovery"
               return 0
           fi
       fi
   fi
   ```

4. **Return 1 if no crash detected** (normal operation)

**Important:** This function should be called in /ant:status command to check for crashes on every status request.

**Export function:** export -f detect_crash_and_recover
  </action>
  <verify>
```bash
# Source dependencies
source .aether/utils/file-lock.sh
source .aether/utils/atomic-write.sh
source .aether/utils/state-machine.sh
source .aether/utils/checkpoint.sh

# Test 1: Simulate crash (EXECUTING state with no workers)
transition_state "EXECUTING" "test_crash_simulation"
echo '[]' | jq '.active_workers = []' > .aether/data/worker_ants.json

# Test 2: Run crash detection
if detect_crash_and_recover; then
    echo "Crash detected and recovered"
else
    echo "No crash detected (this is also valid if no crash condition)"
fi

# Test 3: Verify state changed to PLANNING if crash detected
recovered_state=$(jq -r '.colony_status.state' .aether/data/COLONY_STATE.json)
if [ "$recovered_state" = "PLANNING" ]; then
    echo "Crash recovery successful: state changed to PLANNING"
fi

# Reset for other tests
transition_state "IDLE" "test_reset"

echo "All crash detection tests passed"
```
  </verify>
  <done>
detect_crash_and_recover() identifies crash conditions (EXECUTING/VERIFYING with no workers), triggers automatic recovery, transitions to PLANNING for retry
  </done>
</task>

<task type="auto">
  <name>Task 2: Create /ant:recover command</name>
  <files>.claude/commands/ant/recover.md</files>
  <action>
Create /ant:recover command with the following structure:

**Command usage:**
- `/ant:recover` - List available checkpoints and latest status
- `/ant:recover latest` - Restore from latest checkpoint
- `/ant:recover [id]` - Restore from specific checkpoint ID

**Implementation:**

```bash
#!/bin/bash
# /ant:recover - Colony recovery from checkpoint

source .aether/utils/atomic-write.sh
source .aether/utils/checkpoint.sh

COLONY_STATE=".aether/data/COLONY_STATE.json"
CHECKPOINT_DIR=".aether/data/checkpoints"

# Check if checkpoint directory exists
if [ ! -d "$CHECKPOINT_DIR" ]; then
    echo "No checkpoints found. Colony has no recovery points."
    exit 0
fi

# Check for checkpoint ID argument
checkpoint_id="${1:-}"

if [ -z "$checkpoint_id" ]; then
    # No argument - list checkpoints and show latest
    echo "üêú COLONY RECOVERY"
    echo ""
    echo "Current colony state:"
    echo "  State: $(jq -r '.colony_status.state' "$COLONY_STATE")"
    echo "  Phase: $(jq -r '.colony_status.current_phase' "$COLONY_STATE")"
    echo ""

    # Show latest checkpoint
    if [ -f ".aether/data/checkpoint.json" ]; then
        latest_file=$(cat ".aether/data/checkpoint.json")
        if [ -f "$latest_file" ]; then
            echo "Latest checkpoint:"
            echo "  ID: $(jq -r '.checkpoint_id' "$latest_file")"
            echo "  Label: $(jq -r '.label' "$latest_file")"
            echo "  Timestamp: $(jq -r '.timestamp' "$latest_file")"
            echo "  State: $(jq -r '.colony_state.colony_status.state' "$latest_file")"
            echo ""
        fi
    fi

    # List all checkpoints
    list_checkpoints
    echo ""
    echo "Usage:"
    echo "  /ant:recover          - Show this list"
    echo "  /ant:recover latest   - Restore from latest checkpoint"
    echo "  /ant:recover [id]     - Restore from checkpoint ID"
else
    # Recover from specific checkpoint
    echo "Recovering from checkpoint: $checkpoint_id"
    echo ""

    if load_checkpoint "$checkpoint_id"; then
        echo ""
        echo "Recovery complete. Colony restored."
        echo ""
        echo "Next steps:"
        echo "  - Review state: /ant:status"
        echo "  - Continue execution: /ant:execute \$(jq -r '.colony_status.current_phase' "$COLONY_STATE")"
    else
        echo "Recovery failed. Check checkpoint ID and try again."
        exit 1
    fi
fi
```

**Important:**
- Source checkpoint.sh to use load_checkpoint() and list_checkpoints()
- Handle both "list" mode (no args) and "recover" mode (with args)
- Show current colony state for context
- Provide clear next steps after recovery
  </action>
  <verify>
```bash
# Test 1: Run /ant:recover (list mode)
bash .claude/commands/ant/recover.md 2>&1 | grep -q "COLONY RECOVERY" || { echo "List mode failed"; exit 1; }

# Test 2: Verify checkpoints are listed
bash .claude/commands/ant/recover.md 2>&1 | grep -q "Available checkpoints" || { echo "Checkpoints not listed"; exit 1; }

# Test 3: Verify usage instructions shown
bash .claude/commands/ant/recover.md 2>&1 | grep -q "Usage:" || { echo "Usage not shown"; exit 1; }

# Test 4: If checkpoint exists, try recovery (may fail if no checkpoint, that's ok)
if [ -f ".aether/data/checkpoint.json" ]; then
    bash .claude/commands/ant/recover.md "latest" 2>&1 | grep -q "Recovery complete\|Recovery failed" || { echo "Recovery mode failed"; exit 1; }
fi

echo "All /ant:recover command tests passed"
```
  </verify>
  <done>
/ant:recover lists checkpoints, shows latest checkpoint info, recovers from specific checkpoint, provides clear next steps
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate crash detection into /ant:status</name>
  <files>.claude/commands/ant/status.md</files>
  <action>
Update /ant:status command to call detect_crash_and_recover():

**At the top of status.md, after sourcing checkpoint.sh, add:**

```bash
# Auto-detect and recover from crashes
detect_crash_and_recover
```

**Location:** Add this before displaying colony status, so any recovery happens before status is shown.

**Behavior:**
- If crash detected, automatic recovery occurs first
- Then status displays the recovered state
- User sees "Crash detected: Recovering from checkpoint..." message
- Status shows PLANNING state after recovery

**Note:** Ensure checkpoint.sh is sourced in status.md:
```bash
source .aether/utils/checkpoint.sh
```

This makes crash detection automatic on every status request, ensuring colony self-heals without manual intervention.
  </action>
  <verify>
```bash
# Test 1: Source /ant:status without errors
source .claude/commands/ant/status.md || { echo "Failed to source status.md"; exit 1; }

# Test 2: Verify detect_crash_and_recover is callable
type detect_crash_and_recover >/dev/null 2>&1 || { echo "detect_crash_and_recover not available"; exit 1; }

# Test 3: Run status command (should execute detect_crash_and_recover)
bash .claude/commands/ant/status.md 2>&1 | grep -q "Colony Status" || { echo "Status command failed"; exit 1; }

echo "All crash detection integration tests passed"
```
  </verify>
  <done>
/ant:status calls detect_crash_and_recover() on every execution, automatic crash recovery occurs before status display
  </done>
</task>

</tasks>

<verification>
1. detect_crash_and_recover() identifies EXECUTING/VERIFYING with no workers as crash
2. detect_crash_and_recover() triggers load_checkpoint("latest")
3. detect_crash_and_recover() transitions colony to PLANNING after recovery
4. /ant:recover lists all available checkpoints with labels and timestamps
5. /ant:recover latest restores from latest checkpoint
6. /ant:recover [id] restores from specific checkpoint ID
7. /ant:status calls detect_crash_and_recover() automatically
8. Recovery workflow end-to-end tested
</verification>

<success_criteria>
1. detect_crash_and_recover() function exists and is exported
2. Crash detection identifies inconsistent states
3. Automatic recovery restores colony to last checkpoint
4. /ant:recover command lists checkpoints
5. /ant:recover command restores from checkpoints
6. /ant:status integrates automatic crash detection
7. Queen can manually recover colony via command
8. Colony self-heals on crash detection
</success_criteria>

<output>
After completion, create `.planning/phases/05-phase-boundaries/05-05-SUMMARY.md` with:
- Crash detection implementation verified
- /ant:recover command tested
- Automatic recovery integration documented
- Files modified
</output>
