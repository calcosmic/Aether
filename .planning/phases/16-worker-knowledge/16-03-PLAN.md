---
phase: 16-worker-knowledge
plan: 03
type: execute
wave: 3
depends_on: ["16-02"]
files_modified:
  - .aether/workers/watcher-ant.md
  - .aether/workers/builder-ant.md
  - .aether/workers/scout-ant.md
  - .aether/workers/architect-ant.md
  - .aether/workers/colonizer-ant.md
  - .aether/workers/route-setter-ant.md
autonomous: true

must_haves:
  truths:
    - "Every worker spec reads events.json at startup and describes how to filter and react to recent events"
    - "Every worker spec reads memory.json at startup for recent decisions and phase learnings"
    - "Every worker spec includes a complete spawning scenario with a full Task tool prompt example"
    - "Spawning scenario shows recursive spec propagation (spawned ant gets full spec, pheromones, and spawning guide)"
  artifacts:
    - path: ".aether/workers/builder-ant.md"
      provides: "Event awareness, memory reading, spawning scenario"
      contains: "## Event Awareness"
    - path: ".aether/workers/scout-ant.md"
      provides: "Event awareness, memory reading, spawning scenario"
      contains: "## Event Awareness"
    - path: ".aether/workers/architect-ant.md"
      provides: "Event awareness, memory reading, spawning scenario"
      contains: "## Event Awareness"
    - path: ".aether/workers/colonizer-ant.md"
      provides: "Event awareness, memory reading, spawning scenario"
      contains: "## Event Awareness"
    - path: ".aether/workers/route-setter-ant.md"
      provides: "Event awareness, memory reading, spawning scenario"
      contains: "## Event Awareness"
    - path: ".aether/workers/watcher-ant.md"
      provides: "Event awareness, memory reading, spawning scenario"
      contains: "## Event Awareness"
  key_links:
    - from: "all worker specs"
      to: ".aether/data/events.json"
      via: "Read tool at startup"
      pattern: "events\\.json"
    - from: "all worker specs"
      to: ".aether/data/memory.json"
      via: "Read tool at startup"
      pattern: "memory\\.json"
    - from: "all worker specs"
      to: "Task tool spawning"
      via: "complete prompt example with spec propagation"
      pattern: "WORKER SPEC.*ACTIVE PHEROMONES.*TASK"
---

<objective>
Add event awareness (reading events.json and memory.json at startup) and complete spawning scenario examples (with full Task tool prompts) to all 6 worker specs.

Purpose: Workers currently have a generic spawning boilerplate and no knowledge of events or memory state. This plan adds the startup awareness protocol (read events, read memory, filter by relevance) and replaces the generic spawning boilerplate with a concrete, caste-specific spawning scenario that demonstrates recursive spec propagation via a realistic Task tool prompt example.

Output: All 6 worker specs reach their target ~200 lines with event awareness, memory reading, and spawning scenarios.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.aether/workers/watcher-ant.md
@.aether/workers/builder-ant.md
@.aether/workers/scout-ant.md
@.aether/workers/architect-ant.md
@.aether/workers/colonizer-ant.md
@.aether/workers/route-setter-ant.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add event awareness and memory reading to all 6 worker specs</name>
  <files>.aether/workers/watcher-ant.md, .aether/workers/builder-ant.md, .aether/workers/scout-ant.md, .aether/workers/architect-ant.md, .aether/workers/colonizer-ant.md, .aether/workers/route-setter-ant.md</files>
  <action>
For each of the 6 worker specs, add a new "## Event Awareness" section and a new "## Memory Reading" section. Insert these AFTER the Feedback Interpretation section and BEFORE the existing Workflow section (or before Output Format if Workflow comes earlier -- check each file's structure and place it logically after all pheromone/feedback sections and before the output/workflow sections).

### "## Event Awareness" section content (same structure, caste-specific filtering):

```
## Event Awareness

At startup, read `.aether/data/events.json` to understand recent colony activity.

**How to read:**
1. Use the Read tool to load `.aether/data/events.json`
2. Filter events to the last 30 minutes (compare timestamps to current time)
3. If a phase is active, also include all events since phase start

**Event schema:** Each event has `{id, type, source, content, timestamp}`

**Event types and relevance for {CASTE_NAME}:**
```

Then add a caste-specific event relevance table:

**Builder:**
| Event Type | Relevance | Action |
|------------|-----------|--------|
| phase_started | HIGH | Check phase goal and your assigned tasks |
| error_logged | HIGH | Check if error is in your work area — may need fixing |
| pheromone_set | MEDIUM | Re-read pheromones for updated signals |
| decision_logged | MEDIUM | Check if decision constrains your implementation |
| phase_completed | LOW | Note for context, no action needed |
| learning_extracted | LOW | Note patterns for future reference |

**Scout:**
| Event Type | Relevance | Action |
|------------|-----------|--------|
| phase_started | HIGH | New domain to research — check phase goal |
| decision_logged | HIGH | Understand decisions to avoid redundant research |
| error_logged | MEDIUM | Error may indicate research gap — investigate root cause |
| pheromone_set | MEDIUM | Signals may redirect research focus |
| learning_extracted | HIGH | Build on existing learnings, don't repeat research |
| phase_completed | LOW | Note for context |

**Colonizer:**
| Event Type | Relevance | Action |
|------------|-----------|--------|
| phase_started | HIGH | New territory to map — full exploration needed |
| error_logged | MEDIUM | Error location may indicate unmapped area |
| pheromone_set | LOW | Colonizer is minimally affected by signals (low sensitivity) |
| decision_logged | MEDIUM | Decisions may affect what areas to explore |
| learning_extracted | MEDIUM | Learnings may reveal areas not yet explored |
| phase_completed | LOW | Note for context |

**Watcher:**
| Event Type | Relevance | Action |
|------------|-----------|--------|
| error_logged | HIGH | Errors need validation — check if they indicate systemic issue |
| phase_started | MEDIUM | New phase means new validation scope |
| pheromone_set | HIGH | Pheromone signals may activate specialist modes |
| decision_logged | MEDIUM | Decisions set constraints to validate against |
| learning_extracted | HIGH | Learnings may reveal quality patterns to check |
| phase_completed | LOW | Note for context |

**Architect:**
| Event Type | Relevance | Action |
|------------|-----------|--------|
| learning_extracted | HIGH | Core input for pattern synthesis |
| decision_logged | HIGH | Decisions are primary knowledge to organize |
| error_logged | MEDIUM | Errors reveal failure patterns to document |
| phase_completed | MEDIUM | Phase completion triggers knowledge consolidation |
| pheromone_set | LOW | Architect is minimally affected by signals |
| phase_started | LOW | Note for context |

**Route-setter:**
| Event Type | Relevance | Action |
|------------|-----------|--------|
| phase_started | HIGH | Plan next phases based on current phase |
| phase_completed | HIGH | Evaluate completed phase to inform future planning |
| error_logged | HIGH | Errors may require plan adjustment |
| decision_logged | HIGH | Decisions constrain future planning |
| pheromone_set | MEDIUM | Signals indicate areas needing plan changes |
| learning_extracted | MEDIUM | Learnings inform planning heuristics |

### "## Memory Reading" section content:

```
## Memory Reading

At startup, read `.aether/data/memory.json` to access colony knowledge.

**How to read:**
1. Use the Read tool to load `.aether/data/memory.json`
2. Check `decisions` array for recent decisions relevant to your task
3. Check `phase_learnings` array for learnings from the current and recent phases

**Memory schema:**
- `decisions`: Array of `{decision, rationale, phase, timestamp}` — capped at 30
- `phase_learnings`: Array of `{phase, learning, confidence, timestamp}` — capped at 20

**What to look for as a {CASTE_NAME}:**
```

Then add caste-specific memory guidance (2-4 bullets):

**Builder:** Look for: decisions about tech choices, architecture patterns, and "avoid X" constraints. Check phase_learnings for what worked and what failed in similar tasks.

**Scout:** Look for: decisions about information sources, research approaches. Check phase_learnings for which research strategies produced useful results.

**Colonizer:** Look for: decisions about project structure, directory conventions. Check phase_learnings for areas already explored and patterns already identified.

**Watcher:** Look for: decisions about quality standards, testing approaches. Check phase_learnings for recurring quality issues and validation patterns that caught problems.

**Architect:** Look for: all decisions (primary synthesis input). Check phase_learnings for patterns with high confidence that should be propagated.

**Route-setter:** Look for: decisions about planning granularity, phase structure, caste assignments. Check phase_learnings for planning approaches that worked and dependency issues encountered.
  </action>
  <verify>
1. Grep for "## Event Awareness" across all 6 worker specs -- must return 6 matches
2. Grep for "## Memory Reading" across all 6 worker specs -- must return 6 matches
3. Grep for "events.json" across all 6 worker specs -- must return 6+ matches
4. Grep for "memory.json" across all 6 worker specs -- must return 6+ matches
5. Each file should have a caste-specific event relevance table
6. Each file should have a caste-specific memory guidance section
7. All other sections (Pheromone Math, Combination Effects, Feedback Interpretation, Specialist Modes for watcher, spawning) remain intact
  </verify>
  <done>
All 6 worker specs contain: (1) an Event Awareness section explaining how to read events.json, filter by time, and a relevance table mapping event types to actions, (2) a Memory Reading section explaining how to read memory.json and what to look for as that specific caste.
  </done>
</task>

<task type="auto">
  <name>Task 2: Replace generic spawning boilerplate with caste-specific spawning scenarios</name>
  <files>.aether/workers/watcher-ant.md, .aether/workers/builder-ant.md, .aether/workers/scout-ant.md, .aether/workers/architect-ant.md, .aether/workers/colonizer-ant.md, .aether/workers/route-setter-ant.md</files>
  <action>
For each of the 6 worker specs, REPLACE the existing "## You Can Spawn Other Ants" section with an expanded version that keeps the caste list and mechanics but ADDS a concrete spawning scenario with a full Task tool prompt example.

The existing spawning section structure (caste list, spawn instructions, spawn limits) stays. Add a new subsection BEFORE the spawn limits:

### Spawning Scenario

Each caste gets a unique, realistic scenario showing WHEN and WHY they would spawn, plus a complete Task tool prompt demonstrating recursive spec propagation.

**Builder spawning scenario:**
```
### Spawning Scenario

Situation: You're implementing a REST API endpoint but encounter an unfamiliar
authentication library. You need research before you can proceed.

Decision process:
1. Check effective signal: FOCUS(0.9) * strength(0.8) = 0.72 -> PRIORITIZE
2. This is a focused implementation task — you must complete it
3. The auth library gap is a research problem — spawn a scout
4. You have 4 spawns remaining (max 5)

Spawn prompt example:
```
Use the Task tool with subagent_type="general-purpose" and this prompt:

--- WORKER SPEC ---
{Read and paste the FULL contents of .aether/workers/scout-ant.md here}

--- ACTIVE PHEROMONES ---
{Copy the ACTIVE PHEROMONES block from your context here}

--- TASK ---
Research the authentication library used in this project.

Colony goal: Implement POST /api/auth/login endpoint
Constraints:
- Find the auth library in package.json or imports
- Document: initialization, token generation, verification
- Check for common gotchas (async/sync, error handling)
- Return findings as structured Scout Ant Report

Phase context: We are building the auth endpoint. I need to understand
the auth library API before I can implement the token flow.
```

The spawned scout receives its full spec (with sensitivity tables,
pheromone math, combination effects, feedback interpretation, event
awareness, AND this spawning guide) — enabling it to spawn further
ants if needed (e.g., spawning a colonizer to map the auth module).
```

**Watcher spawning scenario:**
Situation: Reviewing a complex data pipeline and find potential performance issues that need profiling. Spawn a builder to run benchmarks.

**Scout spawning scenario:**
Situation: Researching a new API integration and discover the project's current architecture needs mapping before you can recommend an integration approach. Spawn a colonizer to map the relevant modules.

**Architect spawning scenario:**
Situation: Synthesizing project patterns and need current test results to validate a quality pattern hypothesis. Spawn a watcher to run the test suite and report results.

**Colonizer spawning scenario:**
Situation: Exploring a new codebase area and find complex business logic that needs documentation before other ants can work with it. Spawn an architect to synthesize and document the patterns.

**Route-setter spawning scenario:**
Situation: Planning a new feature phase and need to understand the current codebase structure before assigning tasks. Spawn a colonizer to map the relevant directory structure.

For EACH scenario, include:
1. The situation description (1-2 sentences)
2. Decision process (check effective signal, identify gap, choose caste, check spawn budget)
3. A complete Task tool prompt example showing:
   - `--- WORKER SPEC ---` with instruction to paste full spec contents
   - `--- ACTIVE PHEROMONES ---` with instruction to copy pheromone block
   - `--- TASK ---` with a realistic task description, colony goal, constraints, and phase context
4. A note about recursive propagation: the spawned ant gets the full spec enabling further spawning

IMPORTANT: The spawning scenario replaces nothing — it is ADDED to the existing spawning section content. Keep the caste list, spawn instructions ("To spawn:"), and spawn limits. Insert the scenario between the spawn instructions and spawn limits.
  </action>
  <verify>
1. Grep for "### Spawning Scenario" across all 6 worker specs -- must return 6 matches
2. Grep for "WORKER SPEC" across all 6 worker specs -- must appear in spawning scenario examples
3. Grep for "ACTIVE PHEROMONES" across all 6 worker specs -- must appear in spawning scenario examples
4. Grep for "--- TASK ---" across all 6 worker specs -- must appear in spawning scenario examples
5. Grep for "Spawn limits" across all 6 worker specs -- must still be present (not deleted)
6. Each spawning scenario should reference a different caste being spawned
7. Each scenario should include a decision process with effective signal calculation
8. Verify watcher-ant.md is 200+ lines (target ~220 with specialist modes)
9. Verify other specs are 190+ lines (target ~200)
  </verify>
  <done>
All 6 worker specs contain a complete spawning scenario with: (1) a realistic situation description, (2) a decision process checking effective signal strength and spawn budget, (3) a full Task tool prompt example showing recursive spec propagation with --- WORKER SPEC ---, --- ACTIVE PHEROMONES ---, and --- TASK --- sections, (4) explanation that spawned ants receive the full spec enabling recursive spawning. All original spawning section content (caste list, spawn instructions, spawn limits) remains intact.
  </done>
</task>

</tasks>

<verification>
- All 6 worker specs contain "## Event Awareness" with events.json reading instructions
- All 6 worker specs contain "## Memory Reading" with memory.json reading instructions
- All 6 worker specs contain "### Spawning Scenario" with a complete Task tool prompt example
- Event awareness includes caste-specific relevance tables
- Memory reading includes caste-specific guidance
- Spawning scenarios show recursive spec propagation
- Spawning scenarios include decision process with pheromone math
- watcher-ant.md is ~220+ lines (specialist modes + all new sections)
- Other 5 specs are ~200+ lines each
- All sections from plans 16-01 and 16-02 remain intact
</verification>

<success_criteria>
- SPEC-04: Every worker spec reads events.json at startup and describes how to filter and react
- SPEC-05: Every worker spec includes a complete spawning scenario with Task tool prompt example
- MEM-04: Workers read memory.json entries at startup
- EVT-03: Workers read events.json at startup
- All 6 specs reach target ~200 lines (watcher ~220)
</success_criteria>

<output>
After completion, create `.planning/phases/16-worker-knowledge/16-03-SUMMARY.md`
</output>
