---
phase: 03-error-handling-recovery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/lib/errors.js
  - bin/lib/logger.js
  - bin/cli.js
autonomous: true

must_haves:
  truths:
    - "All errors in cli.js output structured JSON with code, message, details, recovery"
    - "AetherError class hierarchy exists for different error types"
    - "Uncaught exceptions and unhandled rejections are caught and formatted"
    - "Errors are logged to activity.log with consistent format"
    - "Exit codes follow sysexits.h conventions for different error types"
  artifacts:
    - path: "bin/lib/errors.js"
      provides: "AetherError class and error hierarchy"
      exports: ["AetherError", "HubError", "RepoError", "GitError", "ValidationError", "FileSystemError"]
    - path: "bin/lib/logger.js"
      provides: "Structured logging to activity.log"
      exports: ["logError", "logActivity", "logWarning"]
    - path: "bin/cli.js"
      provides: "Integrated error handling in CLI"
      contains: ["process.on('uncaughtException')", "process.on('unhandledRejection')", "wrapCommand"]
  key_links:
    - from: "bin/cli.js"
      to: "bin/lib/errors.js"
      via: "require('./lib/errors')"
      pattern: "require\(['\"]\\./lib/errors['\"]\)"
    - from: "bin/cli.js"
      to: "bin/lib/logger.js"
      via: "require('./lib/logger')"
      pattern: "require\(['\"]\\./lib/logger['\"]\)"
    - from: "bin/lib/errors.js"
      to: "bin/lib/logger.js"
      via: "logError() calls"
      pattern: "logError"
---

<objective>
Implement centralized error handling infrastructure for Node.js CLI with structured JSON output, consistent error codes, and activity.log integration.

Purpose: Replace ad-hoc error handling in cli.js with a centralized system that provides machine-parseable errors, user-friendly recovery suggestions, and proper audit logging.
Output: bin/lib/errors.js, bin/lib/logger.js, and updated bin/cli.js with integrated error handling
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-error-handling-recovery/03-RESEARCH.md
@bin/cli.js
@.aether/data/activity.log
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create error class hierarchy in bin/lib/errors.js</name>
  <files>bin/lib/errors.js</files>
  <action>
Create bin/lib/ directory if it doesn't exist, then create bin/lib/errors.js with:

1. Base AetherError class extending Error with:
   - constructor(code, message, details = {}, recovery = null)
   - Properties: name, code, details, recovery, timestamp
   - toJSON() method returning structured error object
   - toString() method for console output

2. ErrorCodes enum object with categories:
   - System errors (E_HUB_NOT_FOUND, E_REPO_NOT_INITIALIZED, E_FILE_SYSTEM, E_GIT_ERROR)
   - Validation errors (E_INVALID_STATE, E_MANIFEST_INVALID, E_JSON_PARSE)
   - Runtime errors (E_UPDATE_FAILED, E_LOCK_TIMEOUT, E_ATOMIC_WRITE_FAILED)
   - Unexpected errors (E_UNEXPECTED, E_UNCAUGHT_EXCEPTION, E_UNHANDLED_REJECTION)

3. Specific error subclasses extending AetherError:
   - HubError: for hub-related errors (auto-sets code E_HUB_NOT_FOUND, recovery suggestion)
   - RepoError: for repository initialization errors (auto-sets code E_REPO_NOT_INITIALIZED)
   - GitError: for git operation errors (auto-sets code E_GIT_ERROR)
   - ValidationError: for state validation errors (auto-sets code E_INVALID_STATE)
   - FileSystemError: for file operation errors (auto-sets code E_FILE_SYSTEM)

4. getExitCode(code) function mapping error codes to sysexits.h exit codes:
   - E_HUB_NOT_FOUND -> 69 (EX_UNAVAILABLE)
   - E_REPO_NOT_INITIALIZED -> 78 (EX_CONFIG)
   - E_INVALID_STATE, E_MANIFEST_INVALID -> 65 (EX_DATAERR)
   - E_FILE_SYSTEM, E_ATOMIC_WRITE_FAILED -> 74 (EX_IOERR)
   - E_GIT_ERROR -> 70 (EX_SOFTWARE)
   - All others -> 1 (generic error)

5. Export all classes and functions using CommonJS (module.exports).

Follow the pattern from RESEARCH.md Pattern 1 and Code Examples section. Ensure proper JSON serialization with no circular references.
  </action>
  <verify>node -e "const e = require('./bin/lib/errors.js'); console.log(JSON.stringify(new e.AetherError('E_TEST', 'test').toJSON(), null, 2));"</verify>
  <done>AetherError class can be instantiated and serialized to JSON with all required fields (code, message, details, recovery, timestamp)</done>
</task>

<task type="auto">
  <name>Task 2: Create structured logging module in bin/lib/logger.js</name>
  <files>bin/lib/logger.js</files>
  <action>
Create bin/lib/logger.js with structured logging utilities:

1. Import required modules: fs, path

2. Define constants:
   - ACTIVITY_LOG path: path.join(process.env.HOME || process.env.USERPROFILE, '.aether', 'data', 'activity.log')
   - Log level emojis: ERROR = '❌', WARN = '⚠️', INFO = 'ℹ️', SUCCESS = '✓'

3. logError(error) function:
   - Accept AetherError instance or plain Error
   - Format: [HH:MM:SS] ❌ ERROR $code: $message
   - Extract timestamp from error or use current time
   - Sanitize message (remove newlines, limit length)
   - Append to activity.log using fs.appendFileSync
   - Wrap in try/catch - silently fail if logging fails (don't cascade errors)
   - Return boolean indicating success/failure of logging

4. logActivity(action, caste, description) function:
   - Format: [HH:MM:SS] $emoji $action $caste: $description
   - Use existing emoji logic from cli.js (getCasteEmoji or similar)
   - Append to activity.log
   - Silent fail on error

5. logWarning(code, message) function:
   - Format: [HH:MM:SS] ⚠️ WARN $code: $message
   - For non-fatal warnings that should be logged
   - Silent fail on error

6. formatTimestamp() helper:
   - Return HH:MM:SS from current time or provided ISO string

7. sanitizeForLog(str) helper:
   - Remove newlines, trim whitespace, limit to 200 chars
   - Escape any control characters

8. Export all functions using CommonJS.

Ensure the module can be used independently of errors.js (no circular dependency).
  </action>
  <verify>node -e "const l = require('./bin/lib/logger.js'); l.logWarning('W_TEST', 'test warning'); console.log('logger loaded');" && tail -1 /Users/callumcowie/.aether/data/activity.log | grep "WARN W_TEST"</verify>
  <done>Logger module can write warnings to activity.log with correct format [HH:MM:SS] ⚠️ WARN code: message</done>
</task>

<task type="auto">
  <name>Task 3: Integrate error handling into bin/cli.js</name>
  <files>bin/cli.js</files>
  <action>
Update bin/cli.js to use centralized error handling:

1. At the top of the file (after imports), add:
   - Import error classes: const { AetherError, HubError, RepoError, GitError, ValidationError, FileSystemError, getExitCode } = require('./lib/errors');
   - Import logger: const { logError, logActivity } = require('./lib/logger');

2. Add global error handlers BEFORE any other code:
   - process.on('uncaughtException', (error) => { ... })
     - Create AetherError from unexpected error
     - Log to activity.log
     - Output structured JSON to stderr
     - Exit with code 1
   - process.on('unhandledRejection', (reason, promise) => { ... })
     - Similar handling for unhandled promise rejections
     - Include promise info in details if possible

3. Create wrapCommand(commandFn, options = {}) helper function:
   - Returns async function that wraps command execution
   - Try/catch around await commandFn(...args)
   - On AetherError: logError, output JSON, exit with getExitCode
   - On plain Error: wrap in AetherError with E_UNEXPECTED, then same handling
   - Options: { logActivity: true } to control logging

4. Update existing error handling patterns:
   - Find existing console.error + process.exit patterns
   - Replace with throw new SpecificError() where appropriate
   - Keep behavior identical but use structured errors
   - Examples to update:
     - Lines 11-15: HOME not set error -> throw new AetherError('E_CONFIG', ...)
     - Any file system errors -> throw new FileSystemError(...)
     - Git operation failures -> throw new GitError(...)

5. At the end of the file where commands are executed:
   - Wrap the main command execution in try/catch or use wrapCommand
   - Ensure all exit paths go through centralized handler

6. Add feature flags class for graceful degradation (prep for ERROR-03):
   - Simple FeatureFlags class with enable/disable/check methods
   - Track degraded features for status reporting

Do NOT change command behavior or logic - only error handling. All existing functionality must remain identical.
  </action>
  <verify>node bin/cli.js help 2>&1 | head -5 && node -e "process.exit(0)" || echo "CLI loads without errors"</verify>
  <done>cli.js loads without errors, global error handlers are registered, and wrapCommand function is available</done>
</task>

</tasks>

<verification>
- [ ] bin/lib/errors.js exists with all error classes and exports
- [ ] bin/lib/logger.js exists with logError, logActivity, logWarning functions
- [ ] node -e "const e = require('./bin/lib/errors.js'); const err = new e.HubError('test'); console.log(JSON.stringify(err.toJSON()))" outputs valid JSON
- [ ] node bin/cli.js help executes without errors
- [ ] Activity.log shows test entries with correct format
- [ ] All ERROR-01 requirements satisfied
</verification>

<success_criteria>
- AetherError class hierarchy exists with HubError, RepoError, GitError, ValidationError, FileSystemError
- All errors output structured JSON with code, message, details, recovery, timestamp
- Global uncaughtException and unhandledRejection handlers are registered
- Errors are logged to activity.log with format [HH:MM:SS] ❌ ERROR code: message
- Exit codes follow sysexits.h conventions (64-78 range)
- wrapCommand helper available for consistent command error handling
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling-recovery/03-01-SUMMARY.md`
</output>
