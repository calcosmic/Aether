---
phase: 03-error-handling-recovery
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .aether/utils/error-handler.sh
  - .aether/aether-utils.sh
autonomous: true

must_haves:
  truths:
    - "Bash scripts output structured JSON errors with code, message, details, recovery"
    - "json_err function in aether-utils.sh accepts code, message, details, recovery parameters"
    - "trap ERR handler catches unexpected bash failures with context (line, command)"
    - "Feature flags enable graceful degradation when optional features fail"
    - "Degradation is logged to activity.log with warning level"
    - "Operations continue when non-critical features are disabled"
  artifacts:
    - path: ".aether/utils/error-handler.sh"
      provides: "Shared bash error handling functions"
      exports: ["json_err", "json_warn", "E_* error codes"]
    - path: ".aether/aether-utils.sh"
      provides: "Enhanced error handling in main utilities"
      contains: ["trap ERR", "source utils/error-handler.sh", "feature flag checks"]
  key_links:
    - from: ".aether/aether-utils.sh"
      to: ".aether/utils/error-handler.sh"
      via: "source command"
      pattern: "source.*utils/error-handler.sh"
    - from: "json_err function"
      to: "activity.log"
      via: "echo append"
      pattern: ">>.*activity.log"
    - from: "trap ERR"
      to: "error_handler function"
      via: "trap command"
      pattern: "trap.*error_handler.*ERR"
---

<objective>
Enhance bash error handling in aether-utils.sh with structured JSON errors, trap ERR handler, and implement graceful degradation for optional features.

Purpose: Ensure bash utilities provide the same structured error format as Node.js CLI, catch unexpected failures, and continue operating when non-critical features fail.
Output: .aether/utils/error-handler.sh module and updated .aether/aether-utils.sh with enhanced error handling
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-error-handling-recovery/03-RESEARCH.md
@.aether/aether-utils.sh
@.aether/data/activity.log
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared bash error handler module</name>
  <files>.aether/utils/error-handler.sh</files>
  <action>
Create .aether/utils/error-handler.sh with structured bash error handling:

1. Error code constants (matching Node.js error codes):
   - E_UNKNOWN="E_UNKNOWN"
   - E_HUB_NOT_FOUND="E_HUB_NOT_FOUND"
   - E_REPO_NOT_INITIALIZED="E_REPO_NOT_INITIALIZED"
   - E_FILE_NOT_FOUND="E_FILE_NOT_FOUND"
   - E_JSON_INVALID="E_JSON_INVALID"
   - E_LOCK_FAILED="E_LOCK_FAILED"
   - E_GIT_ERROR="E_GIT_ERROR"
   - E_VALIDATION_FAILED="E_VALIDATION_FAILED"
   - E_FEATURE_UNAVAILABLE="E_FEATURE_UNAVAILABLE"

2. Recovery suggestion functions (internal, prefixed with _):
   - _recovery_hub_not_found() { echo '"Run: aether install"'; }
   - _recovery_repo_not_init() { echo '"Run /ant:init in this repo first"'; }
   - _recovery_file_not_found() { echo '"Check file path and permissions"'; }
   - _recovery_json_invalid() { echo '"Validate JSON syntax"'; }
   - _recovery_lock_failed() { echo '"Wait for other operations to complete"'; }
   - _recovery_git_error() { echo '"Check git status and resolve conflicts"'; }
   - _recovery_default() { echo 'null'; }

3. Enhanced json_err() function:
   - Signature: json_err [code] [message] [details] [recovery]
   - All parameters optional with sensible defaults
   - Get recovery suggestion based on error code (case statement)
   - Escape message for JSON (sed 's/"/\\"/g' | tr '\n' ' ')
   - Get current timestamp in ISO format: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
   - Output structured JSON to stderr:
     {"ok":false,"error":{"code":"...","message":"...","details":...,"recovery":...,"timestamp":"..."}}
   - Log to activity.log (best effort - use 2>/dev/null || true):
     echo "[$timestamp] ❌ ERROR $code: $escaped_message" >> "$DATA_DIR/activity.log"
   - Exit with code 1

4. json_warn() function for non-fatal warnings:
   - Signature: json_warn [code] [message]
   - Output: {"ok":true,"warning":{"code":"...","message":"...","timestamp":"..."}}
   - Log to activity.log: "[$timestamp] ⚠️ WARN $code: $message"
   - Does NOT exit - returns for caller to continue

5. error_handler() function for trap ERR:
   - Captures: line number ($1), command ($2), exit code ($3)
   - Build structured error with code E_BASH_ERROR
   - Include details: {line, command, exit_code}
   - Output JSON to stderr
   - Log to activity.log
   - Exit with code 1

6. Feature flag functions for graceful degradation:
   - _FEATURES associative array to track enabled/disabled features
   - feature_enable(name) - mark feature as available
   - feature_disable(name, reason) - mark as degraded with reason
   - feature_enabled(name) - check if feature is available (returns 0/1)
   - feature_log_degradation(name, reason) - log warning about disabled feature

7. Export all functions and variables:
   - export -f json_err json_warn error_handler
   - export -f feature_enable feature_disable feature_enabled feature_log_degradation
   - export all E_* error code variables

Follow the pattern from RESEARCH.md Pattern 2 and Code Examples section. Ensure compatibility with bash 3.2+ (no associative arrays if targeting older bash - use simple variables).
  </action>
  <verify>bash -n .aether/utils/error-handler.sh && echo "Syntax OK"</verify>
  <done>error-handler.sh has valid bash syntax and can be sourced without errors</done>
</task>

<task type="auto">
  <name>Task 2: Integrate error handler into aether-utils.sh</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Update .aether/aether-utils.sh to use enhanced error handling:

1. After existing utility sourcing (around line 21), add:
   - Source the new error handler: [[ -f "$SCRIPT_DIR/utils/error-handler.sh" ]] && source "$SCRIPT_DIR/utils/error-handler.sh"
   - This should come after file-lock.sh and atomic-write.sh sourcing

2. Replace existing json_err function (lines 40-41) with:
   - If error-handler.sh was sourced, use the enhanced version
   - Fallback to simple version if source failed (for backward compatibility)
   - Check if function is already defined: if ! type json_err &>/dev/null; then ...

3. Add trap ERR setup after set -euo pipefail (around line 10-11):
   - Check if error_handler function exists (from sourced file)
   - If yes: trap 'error_handler ${LINENO} "$BASH_COMMAND" $?' ERR
   - Add comment explaining this provides structured error output for unexpected failures
   - Note: This works alongside set -e but provides better context

4. Update existing error calls to use enhanced format:
   - Find all existing json_err calls in the file
   - Update to use new signature: json_err "$E_CODE" "message" '{"detail":"value"}'
   - Examples to update:
     - Line 76: json_err "COLONY_STATE.json not found" -> json_err "$E_FILE_NOT_FOUND" "COLONY_STATE.json not found" '{"file":"COLONY_STATE.json"}'
     - Line 95: json_err "constraints.json not found" -> similar pattern
     - Any other json_err calls in the file

5. Add graceful degradation for optional features:
   - Activity logging: wrap in feature check, degrade gracefully if DATA_DIR not writable
   - Git operations: check if git is available, disable git integration if not
   - Lock operations: degrade to warnings if lock system fails
   - For each optional feature:
     - Check prerequisites at startup
     - Call feature_disable if prerequisites fail
     - Wrap feature usage in feature_enabled checks
     - Log degradation with json_warn

6. Ensure backward compatibility:
   - Scripts that source aether-utils.sh should still work
   - Existing json_err calls with single argument should still work (enhanced function handles this)
   - All existing subcommands continue to function

Do NOT change command logic or behavior - only error handling and degradation. Test that existing subcommands still work.
  </action>
  <verify>bash .aether/aether-utils.sh help | head -1 | grep -q "ok":true && echo "Help command works"</verify>
  <done>aether-utils.sh help command returns valid JSON with ok:true, no syntax errors</done>
</task>

<task type="auto">
  <name>Task 3: Add graceful degradation implementation</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Implement graceful degradation for optional features in aether-utils.sh:

1. At initialization (after sourcing), add feature detection:
   - Check if DATA_DIR is writable: [[ -w "$DATA_DIR" ]] || feature_disable "activity_log" "DATA_DIR not writable"
   - Check if git is available: command -v git &>/dev/null || feature_disable "git_integration" "git not installed"
   - Check if jq is available: command -v jq &>/dev/null || feature_disable "json_processing" "jq not installed"
   - Check lock system: [[ -f "$SCRIPT_DIR/utils/file-lock.sh" ]] || feature_disable "file_locking" "lock utilities not available"

2. Update activity-log subcommands for graceful degradation:
   - activity-log-init: if ! feature_enabled "activity_log"; then json_warn "W_DEGRADED" "Activity logging disabled: $(_feature_reason activity_log)"; return 0; fi
   - activity-log: same pattern - return empty result or warning instead of error
   - activity-log-read: same pattern

3. Update git-dependent operations:
   - Any subcommand using git (if exists): check feature_enabled "git_integration"
   - If disabled, return warning and skip git operations
   - Continue with file operations regardless

4. Update lock-dependent operations:
   - flag-add, flag-resolve, etc: degrade gracefully if locking unavailable
   - Log warning but continue operation (risk accepted)

5. Add degraded status to output:
   - In help or version output, include degraded features list
   - This helps users understand what functionality is limited

6. Test degradation scenarios:
   - The implementation should handle missing dependencies gracefully
   - Operations continue even when optional features fail
   - Warnings are logged to activity.log when features are disabled

Ensure the degradation is transparent - users see warnings but operations continue.
  </action>
  <verify>bash -c 'source .aether/aether-utils.sh 2>/dev/null; type json_err &>/dev/null && echo "json_err available after source"'</verify>
  <done>json_err function is available after sourcing aether-utils.sh, and feature flag functions work</done>
</task>

</tasks>

<verification>
- [ ] .aether/utils/error-handler.sh exists with all error functions
- [ ] bash -n .aether/utils/error-handler.sh passes syntax check
- [ ] bash .aether/aether-utils.sh help returns valid JSON
- [ ] json_err "E_TEST" "test message" outputs structured JSON with code, message, recovery, timestamp
- [ ] trap ERR is set up in aether-utils.sh
- [ ] Feature flag functions work (feature_enable, feature_disable, feature_enabled)
- [ ] Activity.log shows test error entries with correct format
- [ ] All ERROR-02 and ERROR-03 requirements satisfied
</verification>

<success_criteria>
- Bash error handler outputs structured JSON matching Node.js format
- Error codes are consistent between Node.js and Bash (E_HUB_NOT_FOUND, etc.)
- trap ERR catches unexpected failures with line number and command context
- json_err accepts code, message, details, recovery parameters
- json_warn provides non-fatal warning output
- Feature flags enable/disable optional features gracefully
- Operations continue when non-critical features are unavailable
- Degradation is logged to activity.log with warning level
</success_criteria>

<output>
After completion, create `.planning/phases/03-error-handling-recovery/03-02-SUMMARY.md`
</output>
