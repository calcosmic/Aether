---
phase: 23-enforcement
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .aether/aether-utils.sh
autonomous: true

must_haves:
  truths:
    - "Running `bash .aether/aether-utils.sh spawn-check 1` returns pass/fail JSON with active_workers and depth fields"
    - "Running `bash .aether/aether-utils.sh spawn-check 3` returns pass:false with reason depth_limit"
    - "Running `bash .aether/aether-utils.sh pheromone-validate 'short'` returns pass:false with reason too_short"
    - "Running `bash .aether/aether-utils.sh pheromone-validate 'This is a valid pheromone content string'` returns pass:true"
    - "Running `bash .aether/aether-utils.sh help` lists 13 commands including spawn-check and pheromone-validate"
  artifacts:
    - path: ".aether/aether-utils.sh"
      provides: "spawn-check and pheromone-validate subcommands"
      contains: "spawn-check"
  key_links:
    - from: ".aether/aether-utils.sh spawn-check"
      to: ".aether/data/COLONY_STATE.json"
      via: "jq query on workers object"
      pattern: "COLONY_STATE\\.json"
---

<objective>
Add spawn-check and pheromone-validate subcommands to aether-utils.sh.

Purpose: These are the enforcement primitives that Plan 02 will wire into worker specs and continue.md. spawn-check reads COLONY_STATE.json to enforce worker count (<5 active) and spawn depth (<3) limits. pheromone-validate checks content is non-empty and >= 20 chars.

Output: aether-utils.sh with 13 subcommands (up from 11), both returning structured pass/fail JSON following existing json_ok/json_err patterns.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/23-enforcement/23-RESEARCH.md
@.aether/aether-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add spawn-check and pheromone-validate subcommands</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Read `.aether/aether-utils.sh`. Make three edits:

**Edit 1 -- Add pheromone-validate case block:**
Insert after the `pheromone-cleanup` case block (after line 75, before `validate-state`). This keeps pheromone-related subcommands grouped together.

```bash
  pheromone-validate)
    content="${1:-}"
    len=${#content}
    if [[ -z "$content" ]]; then
      json_ok '{"pass":false,"reason":"empty","length":0,"min_length":20}'
    elif [[ $len -lt 20 ]]; then
      json_ok "{\"pass\":false,\"reason\":\"too_short\",\"length\":$len,\"min_length\":20}"
    else
      json_ok "{\"pass\":true,\"length\":$len,\"min_length\":20}"
    fi
    ;;
```

Uses shell string length (`${#content}`) rather than jq to avoid quoting issues with arbitrary pheromone content. The content is a single shell argument -- the caller must quote it.

**Edit 2 -- Add spawn-check case block:**
Insert after the `error-summary` case block (after line 196, before the `*)` default case).

```bash
  spawn-check)
    depth="${1:-1}"
    [[ -f "$DATA_DIR/COLONY_STATE.json" ]] || json_err "COLONY_STATE.json not found"
    json_ok "$(jq --arg d "$depth" '
      (.workers | to_entries | map(select(.value != "idle")) | length) as $active |
      ($d | tonumber) as $depth |
      {
        pass: ($active < 5 and $depth < 3),
        active_workers: $active,
        max_workers: 5,
        current_depth: $depth,
        max_depth: 3
      } | if .pass == false then
        . + {reason: (if $active >= 5 then "worker_limit" elif $depth >= 3 then "depth_limit" else "unknown" end)}
      else . end
    ' "$DATA_DIR/COLONY_STATE.json")"
    ;;
```

Semantics: `current_depth` is the CALLER's depth. Pass requires `active_workers < 5` (spawning one more would make it 5, the max) AND `current_depth < 3` (depth 1 spawns child at 2, depth 2 spawns child at 3, depth 3 cannot spawn). Default depth is 1 if not provided.

**Edit 3 -- Update help text:**
Update line 38 to list 13 commands. The commands array should be:
`["help","version","pheromone-decay","pheromone-effective","pheromone-batch","pheromone-cleanup","pheromone-validate","validate-state","spawn-check","memory-compress","error-add","error-pattern-check","error-summary"]`

Note the grouping: pheromone-validate goes after pheromone-cleanup (pheromone group), spawn-check goes after validate-state (validation group).
  </action>
  <verify>
Run all of these commands and confirm expected output:

```bash
# Help lists 13 commands
bash .aether/aether-utils.sh help | jq '.commands | length'
# Expected: 13

# spawn-check with depth 1 (pass expected -- colony likely idle)
bash .aether/aether-utils.sh spawn-check 1
# Expected: {"ok":true,"result":{"pass":true,"active_workers":0,...}}

# spawn-check with depth 3 (fail expected -- depth limit)
bash .aether/aether-utils.sh spawn-check 3
# Expected: {"ok":true,"result":{"pass":false,"reason":"depth_limit",...}}

# spawn-check with no arg (defaults to depth 1)
bash .aether/aether-utils.sh spawn-check
# Expected: pass:true (assuming few active workers)

# pheromone-validate with empty content (fail expected)
bash .aether/aether-utils.sh pheromone-validate ""
# Expected: {"ok":true,"result":{"pass":false,"reason":"empty",...}}

# pheromone-validate with short content (fail expected)
bash .aether/aether-utils.sh pheromone-validate "too short"
# Expected: {"ok":true,"result":{"pass":false,"reason":"too_short","length":9,...}}

# pheromone-validate with valid content (pass expected)
bash .aether/aether-utils.sh pheromone-validate "This is a valid pheromone content string for testing"
# Expected: {"ok":true,"result":{"pass":true,"length":52,...}}

# pheromone-validate with no argument (empty = fail)
bash .aether/aether-utils.sh pheromone-validate
# Expected: {"ok":true,"result":{"pass":false,"reason":"empty",...}}
```
  </verify>
  <done>
- `bash .aether/aether-utils.sh help` lists 13 commands including spawn-check and pheromone-validate
- `spawn-check 1` returns pass:true JSON with active_workers, max_workers, current_depth, max_depth fields
- `spawn-check 3` returns pass:false JSON with reason "depth_limit"
- `pheromone-validate ""` returns pass:false with reason "empty"
- `pheromone-validate "short"` returns pass:false with reason "too_short" and correct length
- `pheromone-validate "twenty chars or more!!"` returns pass:true with correct length
- aether-utils.sh stays under 250 lines total (was 201, adding ~25)
  </done>
</task>

</tasks>

<verification>
Run the full help command and confirm 13 subcommands listed. Run `wc -l .aether/aether-utils.sh` and confirm under 250 lines. Run `bash .aether/aether-utils.sh spawn-check 1` and `bash .aether/aether-utils.sh pheromone-validate "valid content string here"` to confirm both return well-formed JSON with `ok:true`.
</verification>

<success_criteria>
- aether-utils.sh has 13 subcommands (was 11)
- spawn-check returns structured pass/fail JSON reading from COLONY_STATE.json
- pheromone-validate returns structured pass/fail JSON based on content length
- Both follow existing json_ok/json_err patterns
- Help text updated to include both new subcommands
</success_criteria>

<output>
After completion, create `.planning/phases/23-enforcement/23-01-SUMMARY.md`
</output>
