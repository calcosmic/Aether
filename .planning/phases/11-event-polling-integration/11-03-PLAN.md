---
phase: 11-event-polling-integration
plan: 03
type: execute
wave: 2
depends_on: [11-01, 11-02]
files_modified:
  - .aether/utils/test-event-polling-integration.sh
  - .aether/data/events.json
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Worker Ants can poll for events using get_events_for_subscriber()"
    - "Worker Ants receive only events matching their subscription criteria"
    - "Worker Ants mark events as delivered to prevent reprocessing"
    - "Different castes receive different events based on caste-specific subscriptions"
    - "Event polling integration test suite passes all assertions"
  artifacts:
    - path: ".aether/utils/test-event-polling-integration.sh"
      provides: "Event polling integration test suite"
      min_lines: 150
    - path: ".aether/data/events.json"
      provides: "Event bus state after polling tests"
      contains: "subscriptions"
  key_links:
    - from: ".aether/utils/test-event-polling-integration.sh"
      to: ".aether/utils/event-bus.sh"
      via: "source .aether/utils/event-bus.sh"
      pattern: "source.*event-bus\\.sh"
    - from: ".aether/utils/test-event-polling-integration.sh"
      to: "Worker Ant prompts"
      via: "Simulated Worker Ant execution"
      pattern: "get_events_for_subscriber"
---

<objective>
Create and run integration test suite for event polling, verifying that Worker Ants can poll for events, receive caste-specific events, and mark events as delivered.

Purpose: Validate the event polling integration works end-to-end with caste-specific subscriptions, topic filtering, and delivery tracking to prevent reprocessing.

Output: Integration test suite (test-event-polling-integration.sh) that verifies event polling behavior for all 10 Worker Ant castes.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-event-polling-integration/11-RESEARCH.md
@.aether/utils/event-bus.sh
@.aether/utils/test-event-filtering.sh
@.aether/utils/test-event-async.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Event Polling Integration Test Suite</name>
  <files>.aether/utils/test-event-polling-integration.sh</files>
  <action>
Create a comprehensive integration test suite at `.aether/utils/test-event-polling-integration.sh` that verifies:

**Test Structure:**
```bash
#!/bin/bash
# Event Polling Integration Test Suite
# Tests event polling behavior for all Worker Ant castes
#
# Tests:
# - Worker Ants can poll for events using get_events_for_subscriber()
# - Worker Ants receive only events matching their subscription criteria
# - Worker Ants mark events as delivered to prevent reprocessing
# - Different castes receive different events based on caste-specific subscriptions
# - Event polling works at execution boundaries (start, after writes, after commands)

set -e

# Source event bus
source .aether/utils/event-bus.sh

# Test counters
TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0

# Test helper functions
test_assert() {
    local test_name="$1"
    local condition="$2"
    TESTS_RUN=$((TESTS_RUN + 1))

    if eval "$condition"; then
        echo "✓ PASS: $test_name"
        TESTS_PASSED=$((TESTS_PASSED + 1))
        return 0
    else
        echo "✗ FAIL: $test_name"
        TESTS_FAILED=$((TESTS_FAILED + 1))
        return 1
    fi
}

# Setup: Initialize event bus
setup() {
    echo "=== Setup: Initializing event bus ==="
    # Backup existing events.json if present
    if [ -f .aether/data/events.json ]; then
        cp .aether/data/events.json .aether/data/events.json.backup
    fi
    initialize_event_bus
    echo ""
}

# Teardown: Restore backup
teardown() {
    echo "=== Teardown: Restoring event bus state ==="
    if [ -f .aether/data/events.json.backup ]; then
        mv .aether/data/events.json.backup .aether/data/events.json
    fi
    echo ""
}

# Test 1: Colonizer Ant can subscribe and poll for events
test_colonizer_event_polling() {
    echo "=== Test 1: Colonizer Ant Event Polling ==="

    local caste="colonizer"
    local subscriber_id="test_colonizer_1"

    # Subscribe to colonizer-specific topics
    subscribe_to_events "$subscriber_id" "$caste" "phase_complete" '{}'
    subscribe_to_events "$subscriber_id" "$caste" "spawn_request" '{}'
    subscribe_to_events "$subscriber_id" "$caste" "error" '{}'

    # Publish test events
    publish_event "phase_complete" "test_phase" '{"phase": "11"}' "test_publisher" "colonizer"
    publish_event "spawn_request" "test_spawn" '{"specialist": "scout"}' "test_publisher" "colonizer"
    publish_event "error" "test_error" '{"message": "test error"}' "test_publisher" "builder"

    # Poll for events
    events=$(get_events_for_subscriber "$subscriber_id" "$caste")
    event_count=$(echo "$events" | jq 'length')

    test_assert "Colonizer receives phase_complete events" '[ "$event_count" -ge 2 ]'
    test_assert "Colonizer receives spawn_request events" 'echo "$events" | jq -r "[.[] | select(.topic == \"spawn_request\")] | length" | grep -q 1'

    # Mark events as delivered
    mark_events_delivered "$subscriber_id" "$caste" "$events"

    # Poll again - should receive empty array (events already delivered)
    events_after=$(get_events_for_subscriber "$subscriber_id" "$caste")
    test_assert "Colonizer does not reprocess delivered events" '[ "$events_after" == "[]" ]'

    echo ""
}

# Test 2: Builder Ant event filtering
test_builder_event_filtering() {
    echo "=== Test 2: Builder Ant Event Filtering ==="

    local caste="builder"
    local subscriber_id="test_builder_1"

    # Subscribe to builder-specific topics
    subscribe_to_events "$subscriber_id" "$caste" "task_started" '{}'
    subscribe_to_events "$subscriber_id" "$caste" "task_completed" '{}'
    subscribe_to_events "$subscriber_id" "$caste" "error" '{}'

    # Publish test events
    publish_event "task_started" "test_task" '{"task": "Build auth module"}' "test_publisher" "queen"
    publish_event "task_completed" "test_task" '{"task": "Build auth module"}' "test_publisher" "builder"
    publish_event "phase_complete" "test_phase" '{"phase": "11"}' "test_publisher" "colonizer"

    # Poll for events
    events=$(get_events_for_subscriber "$subscriber_id" "$caste")
    task_started_count=$(echo "$events" | jq -r '[.[] | select(.topic == "task_started")] | length')
    phase_complete_count=$(echo "$events" | jq -r '[.[] | select(.topic == "phase_complete")] | length')

    test_assert "Builder receives task_started events" '[ "$task_started_count" -eq 1 ]'
    test_assert "Builder does not receive phase_complete events (not subscribed)" '[ "$phase_complete_count" -eq 0 ]'

    echo ""
}

# Test 3: Watcher Ant task event monitoring
test_watcher_task_monitoring() {
    echo "=== Test 3: Watcher Ant Task Monitoring ==="

    local caste="watcher"
    local subscriber_id="test_watcher_1"

    # Subscribe to watcher-specific topics
    subscribe_to_events "$subscriber_id" "$caste" "task_completed" '{}'
    subscribe_to_events "$subscriber_id" "$caste" "task_failed" '{}'
    subscribe_to_events "$subscriber_id" "$caste" "error" '{}'

    # Publish test events
    publish_event "task_completed" "test_task" '{"task": "Build auth module"}' "test_publisher" "builder"
    publish_event "task_failed" "test_task" '{"task": "Build payment module", "error": "timeout"}' "test_publisher" "builder"
    publish_event "error" "test_error" '{"message": "test error"}' "test_publisher" "builder"

    # Poll for events
    events=$(get_events_for_subscriber "$subscriber_id" "$caste")
    event_count=$(echo "$events" | jq 'length')
    failed_count=$(echo "$events" | jq -r '[.[] | select(.topic == "task_failed")] | length')

    test_assert "Watcher receives task_completed events" '[ "$event_count" -ge 2 ]'
    test_assert "Watcher receives task_failed events" '[ "$failed_count" -eq 1 ]'

    echo ""
}

# Test 4: Security Watcher specialist filtering
test_security_watcher_filtering() {
    echo "=== Test 4: Security Watcher Specialist Filtering ==="

    local caste="security-watcher"
    local subscriber_id="test_security_watcher_1"

    # Subscribe with filter criteria
    subscribe_to_events "$subscriber_id" "$caste" "error" '{"category": "security"}'
    subscribe_to_events "$subscriber_id" "$caste" "task_completed" '{}'
    subscribe_to_events "$subscriber_id" "$caste" "task_failed" '{}'

    # Publish test events
    publish_event "error" "test_error" '{"category": "security", "message": "SQL injection"}' "test_publisher" "builder"
    publish_event "error" "test_error" '{"category": "performance", "message": "Slow query"}' "test_publisher" "builder"
    publish_event "task_completed" "test_task" '{"task": "Fix auth bug"}' "test_publisher" "builder"

    # Poll for events
    events=$(get_events_for_subscriber "$subscriber_id" "$caste")
    security_error_count=$(echo "$events" | jq -r '[.[] | select(.topic == "error" and .data.category == "security")] | length')
    performance_error_count=$(echo "$events" | jq -r '[.[] | select(.topic == "error" and .data.category == "performance")] | length')

    test_assert "Security Watcher receives security-related errors" '[ "$security_error_count" -eq 1 ]'
    test_assert "Security Watcher does not receive performance errors (filtered)" '[ "$performance_error_count" -eq 0 ]'

    echo ""
}

# Test 5: Event delivery tracking prevents reprocessing
test_delivery_tracking() {
    echo "=== Test 5: Event Delivery Tracking ==="

    local caste="architect"
    local subscriber_id="test_architect_1"

    # Subscribe to topics
    subscribe_to_events "$subscriber_id" "$caste" "phase_complete" '{}'
    subscribe_to_events "$subscriber_id" "$caste" "task_completed" '{}'

    # Publish event
    publish_event "phase_complete" "test_phase" '{"phase": "11"}' "test_publisher" "queen"

    # First poll
    events_first=$(get_events_for_subscriber "$subscriber_id" "$caste")
    first_count=$(echo "$events_first" | jq 'length')

    # Mark as delivered
    mark_events_delivered "$subscriber_id" "$caste" "$events_first"

    # Second poll
    events_second=$(get_events_for_subscriber "$subscriber_id" "$caste")
    second_count=$(echo "$events_second" | jq 'length')

    test_assert "First poll returns events" '[ "$first_count" -gt 0 ]'
    test_assert "Second poll returns empty array (already delivered)" '[ "$second_count" -eq 0 ]'

    echo ""
}

# Test 6: Multiple castes receive different events
test_caste_specific_subscriptions() {
    echo "=== Test 6: Caste-Specific Subscriptions ==="

    # Publish diverse events
    publish_event "phase_complete" "test_phase" '{"phase": "11"}' "test_publisher" "queen"
    publish_event "spawn_request" "test_spawn" '{"specialist": "scout"}' "test_publisher" "colonizer"
    publish_event "task_started" "test_task" '{"task": "Build auth"}' "test_publisher" "queen"
    publish_event "error" "test_error" '{"message": "test error"}' "test_publisher" "builder"

    # Colonizer subscribes to phase_complete and spawn_request
    subscribe_to_events "test_colonizer_2" "colonizer" "phase_complete" '{}'
    subscribe_to_events "test_colonizer_2" "colonizer" "spawn_request" '{}'

    # Builder subscribes to task_started and error
    subscribe_to_events "test_builder_2" "builder" "task_started" '{}'
    subscribe_to_events "test_builder_2" "builder" "error" '{}'

    # Poll for events
    colonizer_events=$(get_events_for_subscriber "test_colonizer_2" "colonizer")
    builder_events=$(get_events_for_subscriber "test_builder_2" "builder")

    colonizer_count=$(echo "$colonizer_events" | jq 'length')
    builder_count=$(echo "$builder_events" | jq 'length')

    test_assert "Colonizer receives phase_complete and spawn_request" '[ "$colonizer_count" -ge 2 ]'
    test_assert "Builder receives task_started and error" '[ "$builder_count" -ge 2 ]'

    echo ""
}

# Run all tests
main() {
    echo "╔════════════════════════════════════════════════════════════╗"
    echo "║   Event Polling Integration Test Suite                      ║"
    echo "║   Testing event polling for all Worker Ant castes           ║"
    echo "╚════════════════════════════════════════════════════════════╝"
    echo ""

    setup

    test_colonizer_event_polling
    test_builder_event_filtering
    test_watcher_task_monitoring
    test_security_watcher_filtering
    test_delivery_tracking
    test_caste_specific_subscriptions

    teardown

    echo "╔════════════════════════════════════════════════════════════╗"
    echo "║   Test Results                                              ║"
    echo "╚════════════════════════════════════════════════════════════╝"
    echo "Tests run: $TESTS_RUN"
    echo "Tests passed: $TESTS_PASSED"
    echo "Tests failed: $TESTS_FAILED"
    echo ""

    if [ $TESTS_FAILED -eq 0 ]; then
        echo "✓ All tests passed!"
        return 0
    else
        echo "✗ Some tests failed"
        return 1
    fi
}

# Run tests if executed directly
if [ "${BASH_SOURCE[0]}" == "${0}" ]; then
    main "$@"
fi
```

**Key assertions to verify:**
1. Colonizer Ant receives phase_complete and spawn_request events
2. Builder Ant receives task events but not phase_complete (not subscribed)
3. Watcher Ant receives task_completed and task_failed events
4. Security Watcher filters events by category (security only)
5. Delivery tracking prevents reprocessing (second poll returns empty)
6. Different castes receive different events based on subscriptions

Make the test executable:
```bash
chmod +x .aether/utils/test-event-polling-integration.sh
```
  </action>
  <verify>
# Verify test file exists and is executable
test -f .aether/utils/test-event-polling-integration.sh && echo "✓ Test file exists" || echo "✗ Test file missing"
test -x .aether/utils/test-event-polling-integration.sh && echo "✓ Test file is executable" || echo "✗ Test file not executable"

# Run the test suite
bash .aether/utils/test-event-polling-integration.sh
  </verify>
  <done>
Integration test suite created and passing:
- Test file exists at .aether/utils/test-event-polling-integration.sh
- Test file is executable
- All 6 tests pass (colonizer polling, builder filtering, watcher monitoring, security filtering, delivery tracking, caste-specific subscriptions)
- Total assertions: 18+ (3+ per test)
  </done>
</task>

</tasks>

<verification>
1. Test file .aether/utils/test-event-polling-integration.sh exists and is executable
2. Test suite includes at least 6 test cases covering all Worker Ant caste types
3. All tests pass with 0 failures
4. Tests verify event polling, filtering, and delivery tracking
5. Test output shows summary of tests run/passed/failed
</verification>

<success_criteria>
1. ls -la .aether/utils/test-event-polling-integration.sh shows executable file
2. bash .aether/utils/test-event-polling-integration.sh returns exit code 0
3. Test output shows "All tests passed!" or similar success message
4. grep "test_assert" .aether/utils/test-event-polling-integration.sh returns at least 18 matches
5. events.json contains test subscriptions after test run
</success_criteria>

<output>
After completion, create `.planning/phases/11-event-polling-integration/11-03-SUMMARY.md`
</output>
