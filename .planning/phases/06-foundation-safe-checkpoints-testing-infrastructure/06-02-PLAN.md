---
phase: 06-foundation-safe-checkpoints-testing-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - bin/cli.js
  - .aether/checkpoints/.gitkeep
autonomous: true

must_haves:
  truths:
    - User can run `aether checkpoint create` to create a safe checkpoint
    - Checkpoint only captures allowlisted files (never user data)
    - Checkpoint metadata includes SHA-256 hashes for integrity
    - User can list checkpoints with `aether checkpoint list`
    - User can restore a checkpoint with `aether checkpoint restore <id>`
  artifacts:
    - path: "bin/cli.js"
      provides: "checkpoint command implementation"
      contains: ["checkpoint", "createCheckpoint", "listCheckpoints", "restoreCheckpoint"]
    - path: ".aether/checkpoints/"
      provides: "Checkpoint metadata storage directory"
  key_links:
    - from: "checkpoint command"
      to: "SYSTEM_FILES allowlist"
      via: "getAllowlistedFiles() function"
    - from: "checkpoint metadata"
      to: "hashFileSync()"
      via: "SHA-256 hash generation"
---

<objective>
Implement safe checkpoint system in CLI that only captures Aether-managed files using explicit allowlist, with metadata including file hashes.

Purpose: Prevent data loss by ensuring checkpoints never capture user data (TO-DOs.md, .aether/data/, etc.) while providing rollback capability for Aether system files.
Output: New `aether checkpoint` command with create, list, restore, and verify subcommands.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/phases/06-foundation-safe-checkpoints-testing-infrastructure/06-RESEARCH.md
@/Users/callumcowie/repos/Aether/bin/cli.js
</context>

<tasks>

<task type="auto">
  <name>Create checkpoint utility functions</name>
  <files>bin/cli.js</files>
  <action>
    Add the following checkpoint-related functions to bin/cli.js (before the command definitions, after the existing utility functions):

    1. `getAllowlistedFiles(repoPath)` - Returns array of files from SYSTEM_FILES that exist in repo:
       - Iterate over SYSTEM_FILES array
       - Check if each file exists in repoPath/.aether/
       - Return array of existing file paths relative to .aether/

    2. `isUserData(filePath)` - Returns true if file is user data that should never be checkpointed:
       - Check against forbidden patterns: data/, dreams/, oracle/, TO-DOs.md
       - Return true if any pattern matches

    3. `generateCheckpointMetadata(repoPath, message)` - Creates checkpoint metadata object:
       - Generate unique checkpoint ID: `chk_YYYYMMDD_HHMMSS`
       - Get allowlisted files
       - For each file, compute SHA-256 hash using hashFileSync
       - Return object with: checkpoint_id, created_at, message, files (hash map), excluded list

    4. `saveCheckpointMetadata(metadata)` - Saves metadata to .aether/checkpoints/:
       - Ensure .aether/checkpoints/ directory exists
       - Write JSON file: .aether/checkpoints/{checkpoint_id}.json

    5. `loadCheckpointMetadata(checkpointId)` - Loads checkpoint metadata by ID:
       - Read from .aether/checkpoints/{checkpoint_id}.json
       - Return parsed metadata or null if not found

    Follow the patterns from existing functions like generateManifest and hashFileSync.
    Use writeJsonSync for saving metadata.
  </action>
  <verify>grep -n "getAllowlistedFiles\|isUserData\|generateCheckpointMetadata" bin/cli.js | head -10</verify>
  <done>All 5 checkpoint utility functions added to bin/cli.js</done>
</task>

<task type="auto">
  <name>Create checkpoint directory and implement checkpoint command</name>
  <files>.aether/checkpoints/.gitkeep, bin/cli.js</files>
  <action>
    1. Create .aether/checkpoints/ directory with .gitkeep file to ensure it exists in repo

    2. Add the `checkpoint` command to bin/cli.js CLI (after the `uninstall` command):

       ```javascript
       program
         .command('checkpoint')
         .description('Manage Aether checkpoints (safe snapshots of system files)')
         .addCommand(
           program.createCommand('create')
             .description('Create a new checkpoint of Aether system files')
             .argument('[message]', 'optional message describing the checkpoint')
             .action(wrapCommand(async (message) => {
               // Implementation:
               // 1. Check if in git repo (use existing isGitRepo pattern)
               // 2. Get allowlisted files
               // 3. Verify no user data in allowlist (safety check)
               // 4. Generate checkpoint metadata with hashes
               // 5. Create git stash with allowlisted files
               // 6. Save metadata to .aether/checkpoints/
               // 7. Output success with checkpoint ID
             }))
         )
         .addCommand(
           program.createCommand('list')
             .description('List all checkpoints')
             .action(wrapCommand(async () => {
               // Implementation:
               // 1. Read .aether/checkpoints/ directory
               // 2. Load each metadata file
               // 3. Display formatted list with ID, date, message, file count
             }))
         )
         .addCommand(
           program.createCommand('restore')
             .description('Restore Aether files from a checkpoint')
             .argument('<checkpoint-id>', 'checkpoint ID to restore from')
             .action(wrapCommand(async (checkpointId) => {
               // Implementation:
               // 1. Load checkpoint metadata
               // 2. Verify metadata integrity (hashes match current files if they exist)
               // 3. Use git stash to restore files
               // 4. Output success with restored file count
             }))
         )
         .addCommand(
           program.createCommand('verify')
             .description('Verify checkpoint integrity')
             .argument('<checkpoint-id>', 'checkpoint ID to verify')
             .action(wrapCommand(async (checkpointId) => {
               // Implementation:
               // 1. Load checkpoint metadata
               // 2. Re-compute hashes for all files in metadata
               // 3. Compare with stored hashes
               // 4. Report any mismatches
             }))
         );
       ```

    Follow the existing command patterns (install, update, version, uninstall).
    Use wrapCommand for consistent error handling.
    Use c.header(), c.success(), c.warning(), c.error() for colored output.
  </action>
  <verify>grep -n "program.command('checkpoint')" bin/cli.js</verify>
  <done>checkpoint command with create/list/restore/verify subcommands added to CLI</done>
</task>

</tasks>

<verification>
- [ ] .aether/checkpoints/ directory exists with .gitkeep
- [ ] `aether checkpoint --help` shows available subcommands
- [ ] `aether checkpoint create` creates a checkpoint with metadata
- [ ] Checkpoint metadata includes file hashes
- [ ] User data (data/, dreams/, oracle/) is never included in checkpoints
</verification>

<success_criteria>
- Checkpoint utility functions exist in bin/cli.js
- `aether checkpoint create` creates checkpoints with metadata
- `aether checkpoint list` displays all checkpoints
- `aether checkpoint restore <id>` restores from checkpoint
- `aether checkpoint verify <id>` verifies integrity
- Checkpoints only include allowlisted files (SYSTEM_FILES)
- User data directories are explicitly excluded
</success_criteria>

<output>
After completion, create `.planning/phases/06-foundation-safe-checkpoints-testing-infrastructure/06-02-SUMMARY.md`
</output>
