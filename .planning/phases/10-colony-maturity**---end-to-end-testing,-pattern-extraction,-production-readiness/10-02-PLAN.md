---
phase: 10-colony-maturity
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - .planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/autonomous-spawn.test.sh
  - .planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/memory-compress.test.sh
  - .planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/voting-verify.test.sh
  - .planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/meta-learning.test.sh
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Worker Ants detect capability gaps and spawn specialists autonomously"
    - "Memory compression achieves 2.5x ratio and retains key information"
    - "Voting verification enforces supermajority with Critical veto"
    - "Meta-learning updates confidence and improves recommendations"
    - "Tests validate component integration with colony state"
  artifacts:
    - path: ".planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/autonomous-spawn.test.sh"
      provides: "Autonomous spawning validation"
      exports: ["test_capability_gap_detection", "test_spawn_limit_enforcement"]
    - path: ".planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/memory-compress.test.sh"
      provides: "Memory compression validation"
      exports: ["test_compression_ratio", "test_key_retention"]
    - path: ".planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/voting-verify.test.sh"
      provides: "Voting system validation"
      exports: ["test_supermajority_logic", "test_critical_veto"]
    - path: ".planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/meta-learning.test.sh"
      provides: "Meta-learning validation"
      exports: ["test_confidence_updates", "test_recommendation_improvement"]
  key_links:
    - from: "autonomous-spawn.test.sh"
      to: ".aether/utils/spawn-decision.sh"
      via: "source"
      pattern: "source.*spawn-decision"
    - from: "memory-compress.test.sh"
      to: ".aether/utils/memory-compress.sh"
      via: "source"
      pattern: "source.*memory-compress"
    - from: "voting-verify.test.sh"
      to: ".aether/utils/vote-aggregator.sh"
      via: "source"
      pattern: "source.*vote-aggregator"
    - from: "meta-learning.test.sh"
      to: ".aether/utils/bayesian-confidence.sh"
      via: "source"
      pattern: "source.*bayesian-confidence"
---

<objective>
Component integration tests for autonomous spawning, memory compression, voting verification, and meta-learning

Purpose: Break down the full workflow into component-level tests that validate each major colony subsystem works correctly. These tests verify the "emergence" mechanisms: Workers spawn Workers, memory compresses without context rot, voting validates outputs, meta-learning improves decisions.

Output: Four integration test files that validate component behaviors with colony state interaction
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/10-RESEARCH.md
@.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/10-CONTEXT.md
@.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/10-01-SUMMARY.md
@.aether/utils/spawn-decision.sh
@.aether/utils/memory-compress.sh
@.aether/utils/vote-aggregator.sh
@.aether/utils/bayesian-confidence.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create autonomous spawning integration test</name>
  <files>.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/autonomous-spawn.test.sh</files>
  <action>
Create integration test for Phase 6 autonomous spawning:

**autonomous-spawn.test.sh structure:**
```bash
#!/bin/bash
# TAP test for autonomous Worker Ant spawning

set -e

source ../helpers/colony-setup.sh
source ../helpers/cleanup.sh

echo "1..7"  # Plan 7 assertions

# Test 1: Capability gap detection
echo "ok 1 - Capability gap detected"

# Test 2: Specialist mapping correct
echo "ok 2 - Specialist mapped to capability gap"

# Test 3: Spawn limit enforced (max 10)
echo "ok 3 - Spawn budget enforced"

# Test 4: Depth limit enforced (max 3)
echo "ok 4 - Spawn depth limit enforced"

# Test 5: Circuit breaker triggers (3 failures)
echo "ok 5 - Circuit breaker triggered on failures"

# Test 6: Same-specialist cache prevents duplicates
echo "ok 6 - Duplicate spawn prevented by cache"

# Test 7: Spawn outcome recorded for meta-learning
echo "ok 7 - Spawn outcome recorded"
```

Implementation requirements:
- Source spawn-decision.sh, spawn-tracker.sh, circuit-breaker.sh
- Create test colony state with capability gap
- Simulate spawn decision with detect_capability_gaps
- Verify spawn limit via can_spawn (max 10 per phase)
- Verify depth limit via spawn_history tracking
- Trigger circuit breaker with 3 failed spawns
- Attempt duplicate spawn and verify cache prevents it
- Record spawn outcome and verify meta-learning populated
- Use jq to query COLONY_STATE.json meta_learning section
- Each test in own subshell for isolation
- Trap cleanup EXIT for state reset
  </action>
  <verify>Run `bash tests/integration/autonomous-spawn.test.sh` and verify all 7 TAP assertions pass</verify>
  <done>Autonomous spawning test validates gap detection, limits, circuit breakers, and outcome tracking</done>
</task>

<task type="auto">
  <name>Task 2: Create memory compression integration test</name>
  <files>.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/memory-compress.test.sh</files>
  <action>
Create integration test for Phase 4 triple-layer memory:

**memory-compress.test.sh structure:**
```bash
#!/bin/bash
# TAP test for memory compression

set -e

source ../helpers/colony-setup.sh
source ../helpers/cleanup.sh

echo "1..6"  # Plan 6 assertions

# Test 1: Working memory limit enforced (200k tokens)
echo "ok 1 - Working memory within 200k token limit"

# Test 2: Compression triggers at 80% capacity
echo "ok 2 - Compression triggered at threshold"

# Test 3: Compression ratio meets 2.5x target
echo "ok 3 - Compression ratio >= 2.5x"

# Test 4: Key information retained after compression
echo "ok 4 - Key information retrievable post-compression"

# Test 5: Working memory cleared after compression
echo "ok 5 - Working memory cleared after compression"

# Test 6: LRU eviction enforced (max 10 short-term sessions)
echo "ok 6 - LRU eviction enforced at limit"
```

Implementation requirements:
- Source memory-ops.sh, memory-compress.sh, memory-search.sh
- Fill working memory with test data (use 4 chars/token heuristic)
- Trigger compression at 160k tokens (80% of 200k)
- Calculate compression ratio: original_size / compressed_size
- Verify ratio >= 2.5 (DAST target from Phase 4)
- Add known "key information" (e.g., "database schema: users table")
- After compression, search for "database schema" and verify found
- Verify working_memory array empty after compression
- Create 11 short-term sessions, verify 11th triggers LRU eviction
- Use jq to query memory.json structure
- Test key information retention via search_memory function
  </action>
  <verify>Run `bash tests/integration/memory-compress.test.sh` and verify all 6 TAP assertions pass</verify>
  <done>Memory compression test validates limits, compression ratio, retention, and LRU eviction</done>
</task>

<task type="auto">
  <name>Task 3: Create voting verification integration test</name>
  <files>.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/voting-verify.test.sh</files>
  <action>
Create integration test for Phase 7 colony verification:

**voting-verify.test.sh structure:**
```bash
#!/bin/bash
# TAP test for voting verification

set -e

source ../helpers/colony-setup.sh
source ../helpers/cleanup.sh

echo "1..8"  # Plan 8 assertions

# Test 1: Unanimous approve passes
echo "ok 1 - Unanimous approval passes"

# Test 2: Single reject fails (needs 67% supermajority)
echo "ok 2 - Single reject causes failure"

# Test 3: Critical issue vetoes despite supermajority
echo "ok 3 - Critical veto power enforced"

# Test 4: Issue deduplication merges duplicates
echo "ok 4 - Duplicate issues merged"

# Test 5: Weight calculator updates correctly (correct_reject +0.15)
echo "ok 5 - Weight increased for correct rejection"

# Test 6: Weight calculator decreases (incorrect_approve -0.2)
echo "ok 6 - Weight decreased for incorrect approval"

# Test 7: Vote recorded in COLONY_STATE.json
echo "ok 7 - Vote recorded in verification section"

# Test 8: Supermajority calculation (3/4 = 75% >= 67%)
echo "ok 8 - Supermajority threshold enforced"
```

Implementation requirements:
- Source vote-aggregator.sh, weight-calculator.sh, issue-deduper.sh
- Create test vote files in .aether/verification/votes/
- Test scenarios: 4/4 APPROVE, 3/4 APPROVE, 1/4 APPROVE
- Test Critical veto: 3/4 APPROVE but 1 Critical issue → fail
- Create duplicate issues in separate votes, verify merge
- Update weight via weight-calculator.sh, verify delta applied
- Check COLONY_STATE.json verification.votes array
- Verify supermajority: 3/4 = 75% >= 67% (pass), 2/4 = 50% < 67% (fail)
- Use jq for vote parsing and aggregation verification
- Test asymmetric weight updates: +0.15 correct_reject, -0.2 incorrect_approve
  </action>
  <verify>Run `bash tests/integration/voting-verify.test.sh` and verify all 8 TAP assertions pass</verify>
  <done>Voting verification test validates supermajority, Critical veto, issue deduplication, weight updates</done>
</task>

<task type="auto">
  <name>Task 4: Create meta-learning integration test</name>
  <files>.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/integration/meta-learning.test.sh</files>
  <action>
Create integration test for Phase 8 colony learning:

**meta-learning.test.sh structure:**
```bash
#!/bin/bash
# TAP test for Bayesian meta-learning

set -e

source ../helpers/colony-setup.sh
source ../helpers/cleanup.sh

echo "1..7"  # Plan 7 assertions

# Test 1: Initial confidence is 0.5 (uniform prior Beta(1,1))
echo "ok 1 - Initial confidence is neutral (0.5)"

# Test 2: Success increases confidence (alpha increment)
echo "ok 2 - Confidence increased after success"

# Test 3: Failure decreases confidence (beta increment, asymmetric)
echo "ok 3 - Confidence decreased after failure"

# Test 4: Confidence bounded [0.0, 1.0]
echo "ok 4 - Confidence clamped to valid range"

# Test 5: Sample size weighting prevents overconfidence
echo "ok 5 - Small samples have lower weighted confidence"

# Test 6: Specialist recommendation uses confidence threshold
echo "ok 6 - Recommendation requires confidence >= 0.7"

# Test 7: Meta-learning data persisted to COLONY_STATE.json
echo "ok 7 - Confidence scores persisted"
```

Implementation requirements:
- Source bayesian-confidence.sh, spawn-outcome-tracker.sh, spawn-decision.sh
- Test Beta distribution: α=1, β=1 → confidence = 1/(1+1) = 0.5
- Call update_bayesian_parameters with success (α++)
- Verify confidence increases: new_α/(new_α+β) > old_α/(old_α+β)
- Call with failure (β++), verify confidence decreases (asymmetric)
- Test boundaries: force confidence > 1.0, verify clamped to 1.0
- Test sample size weighting: get_weighted_confidence for α=2,β=1 vs α=20,β=10
  - Both have same raw confidence (2/3 = 0.667), but weighted should differ
- Test recommend_specialist_by_confidence with threshold 0.7
  - Confidence 0.6 → no recommendation ("semantic_fallback")
  - Confidence 0.8 → recommendation returned
- Verify COLONY_STATE.json meta_learning.specialist_confidence updated
- Use bc for floating-point comparison (tolerance 0.000002)
  </action>
  <verify>Run `bash tests/integration/meta-learning.test.sh` and verify all 7 TAP assertions pass</verify>
  <done>Meta-learning test validates Bayesian confidence, asymmetric updates, bounds, sample weighting, recommendations</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Four component integration tests covering autonomous spawning, memory compression, voting verification, and meta-learning</what-built>
  <how-to-verify>
1. Run all component tests via orchestrator:
   `bash tests/test-orchestrator.sh --integration --verbose`

2. Verify autonomous-spawn.test.sh:
   - Capability gap detection works
   - Spawn limits enforced (max 10, depth 3)
   - Circuit breaker triggers after 3 failures
   - Same-specialist cache prevents duplicates
   - Outcomes recorded for meta-learning

3. Verify memory-compress.test.sh:
   - 200k token limit enforced
   - Compression at 80% capacity (160k tokens)
   - Compression ratio >= 2.5x
   - Key information retained (search finds it)
   - Working memory cleared after compression
   - LRU eviction at 10 sessions

4. Verify voting-verify.test.sh:
   - Supermajority enforced (67% threshold)
   - Critical veto blocks approval
   - Duplicate issues merged
   - Weight updates asymmetric (+0.15/-0.2)
   - Votes recorded in state

5. Verify meta-learning.test.sh:
   - Initial confidence 0.5 (Beta(1,1))
   - Success increases, failure decreases
   - Confidence bounded [0.0, 1.0]
   - Sample size weighting prevents overconfidence
   - Recommendation threshold 0.7 enforced
   - Persistence to COLONY_STATE.json

Expected: All 28 tests pass (7 + 6 + 8 + 7)
  </how-to-verify>
  <resume-signal>Type "approved" if all component tests pass, or describe failures</resume-signal>
</task>

</tasks>

<verification>
- autonomous-spawn.test.sh has executable permissions and 7 passing tests
- memory-compress.test.sh has executable permissions and 6 passing tests
- voting-verify.test.sh has executable permissions and 8 passing tests
- meta-learning.test.sh has executable permissions and 7 passing tests
- All tests properly source helper utilities
- Tests use jq for state validation
- Tests cleanup after themselves via trap
</verification>

<success_criteria>
- Component integration tests validate all major colony subsystems
- Autonomous spawning verified with gap detection and safeguards
- Memory compression validated for ratio, retention, and limits
- Voting verification confirmed with supermajority and Critical veto
- Meta-learning validated with Bayesian confidence and recommendations
- Tests provide diagnostic output on failure
</success_criteria>

<output>
After completion, create `.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/10-02-SUMMARY.md`
</output>
