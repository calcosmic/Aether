---
phase: 10-colony-maturity
plan: 03
type: execute
wave: 3
depends_on: ["10-01", "10-02"]
files_modified:
  - .planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/stress/concurrent-access.test.sh
  - .planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/stress/spawn-limits.test.sh
  - .planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/stress/event-scalability.test.sh
autonomous: false
user_setup: []

must_haves:
  truths:
    - "Concurrent state access doesn't corrupt JSON files"
    - "File locking prevents race conditions under load"
    - "Spawn limits enforced even under concurrent spawn attempts"
    - "Circuit breakers trigger reliably under stress"
    - "Event bus handles concurrent pub/sub without errors"
    - "Stress tests identify performance limits gracefully"
  artifacts:
    - path: ".planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/stress/concurrent-access.test.sh"
      provides: "Concurrency stress testing"
      exports: ["test_concurrent_state_writes", "test_file_locking"]
    - path: ".planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/stress/spawn-limits.test.sh"
      provides: "Spawn limit stress testing"
      exports: ["test_concurrent_spawns", "test_circuit_breaker_under_load"]
    - path: ".planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/stress/event-scalability.test.sh"
      provides: "Event bus stress testing"
      exports: ["test_concurrent_events", "test_topic_filtering_under_load"]
  key_links:
    - from: "concurrent-access.test.sh"
      to: ".aether/utils/file-lock.sh"
      via: "acquire_lock, release_lock"
      pattern: "acquire_lock|release_lock"
    - from: "spawn-limits.test.sh"
      to: ".aether/utils/spawn-tracker.sh"
      via: "can_spawn, record_spawn"
      pattern: "can_spawn|record_spawn"
    - from: "event-scalability.test.sh"
      to: ".aether/utils/event-bus.sh"
      via: "publish_event, get_events_for_subscriber"
      pattern: "publish_event|get_events_for_subscriber"
---

<objective>
Stress tests for concurrent access, spawn limits, and event bus scalability

Purpose: Validate colony safeguards work correctly under concurrent load. Single-threaded tests miss race conditions - stress testing with concurrent operations reveals file locking bugs, spawn limit bypasses, circuit breaker failures, and event bus bottlenecks.

Output: Three stress test files that validate system behavior under concurrent load
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/10-RESEARCH.md
@.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/10-CONTEXT.md
@.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/10-01-SUMMARY.md
@.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/10-02-SUMMARY.md
@.aether/utils/file-lock.sh
@.aether/utils/atomic-write.sh
@.aether/utils/spawn-tracker.sh
@.aether/utils/circuit-breaker.sh
@.aether/utils/event-bus.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create concurrent access stress test</name>
  <files>.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/stress/concurrent-access.test.sh</files>
  <action>
Create stress test for concurrent colony state access:

**concurrent-access.test.sh structure:**
```bash
#!/bin/bash
# TAP stress test for concurrent state access

set -e

source ../helpers/colony-setup.sh
source ../helpers/cleanup.sh

echo "1..6"  # Plan 6 assertions

# Test 1: Concurrent state reads don't corrupt
echo "ok 1 - Concurrent reads successful"

# Test 2: Concurrent state writes don't corrupt (file locking)
echo "ok 2 - Concurrent writes serialized correctly"

# Test 3: File locking prevents race conditions
echo "ok 3 - File lock acquired exclusively"

# Test 4: Atomic writes survive crash simulation
echo "ok 4 - Atomic write preserves previous state on crash"

# Test 5: Checkpoint system handles concurrent checkpoints
echo "ok 5 - Concurrent checkpoints don't corrupt"

# Test 6: JSON validation after all concurrent operations
echo "ok 6 - All JSON files valid after stress"
```

Implementation requirements:
- Source file-lock.sh, atomic-write.sh, checkpoint.sh
- Launch 10 background processes simultaneously
- Each process: reads COLONY_STATE.json, updates field, writes back
- Use file locking (acquire_lock/release_lock) for writes
- Verify no corruption: final state has all 10 updates
- Test atomic write: simulate crash (kill $$ mid-write), verify previous state intact
- Create 5 concurrent checkpoints, verify all 5 valid
- Validate all JSON files with python3 -m json.tool
- Use wait to collect all background processes
- Measure time to completion (should serialize, not parallel)
- Compare with unlocked version (should corrupt) to demonstrate locking necessity
  </action>
  <verify>Run `bash tests/stress/concurrent-access.test.sh` and verify all 6 TAP assertions pass with no JSON corruption</verify>
  <done>Concurrent access test validates file locking and atomic writes under load</done>
</task>

<task type="auto">
  <name>Task 2: Create spawn limits stress test</name>
  <files>.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/stress/spawn-limits.test.sh</files>
  <action>
Create stress test for spawn limits and circuit breakers:

**spawn-limits.test.sh structure:**
```bash
#!/bin/bash
# TAP stress test for spawn limits

set -e

source ../helpers/colony-setup.sh
source ../helpers/cleanup.sh

echo "1..7"  # Plan 7 assertions

# Test 1: Spawn budget enforced (max 10) under concurrent attempts
echo "ok 1 - Spawn budget enforced under load"

# Test 2: Depth limit enforced (max 3) with rapid spawns
echo "ok 2 - Depth limit enforced under load"

# Test 3: Circuit breaker triggers after 3 failures
echo "ok 3 - Circuit breaker triggered"

# Test 4: Circuit breaker prevents spawns during cooldown
echo "ok 4 - Circuit breaker blocks spawns during cooldown"

# Test 5: Same-specialist cache prevents duplicate spawns
echo "ok 5 - Duplicate spawns prevented by cache"

# Test 6: Spawn tracking accurate under concurrent operations
echo "ok 6 - All spawns recorded correctly"

# Test 7: No infinite spawn loops under stress
echo "ok 7 - No infinite loops detected"
```

Implementation requirements:
- Source spawn-tracker.sh, circuit-breaker.sh, spawn-decision.sh
- Launch 20 concurrent processes attempting spawns
- Verify only 10 succeed (max_spawns_per_phase)
- Create deep spawn chain (attempt depth 10), verify stops at 3
- Simulate 3 failed spawns, verify circuit_breaker_tripped = true
- Attempt spawn during cooldown, verify rejected
- Attempt identical spawn twice, verify second blocked by cache
- After test, verify spawn_history has exactly 20 entries (10 success, 10 blocked)
- Verify no spawn_depth > 3 in history
- Check for infinite loops (all processes complete within timeout)
- Use timeout command to prevent hangs (30s limit)
- Query COLONY_STATE.json for spawn_history and circuit_breaker state
  </action>
  <verify>Run `bash tests/stress/spawn-limits.test.sh` and verify all 7 TAP assertions pass with no infinite loops</verify>
  <done>Spawn limits test validates budget, depth, circuit breaker, and cache under concurrent load</done>
</task>

<task type="auto">
  <name>Task 3: Create event bus scalability stress test</name>
  <files>.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/tests/stress/event-scalability.test.sh</files>
  <action>
Create stress test for event bus scalability:

**event-scalability.test.sh structure:**
```bash
#!/bin/bash
# TAP stress test for event bus scalability

set -e

source ../helpers/colony-setup.sh
source ../helpers/cleanup.sh

echo "1..7"  # Plan 7 assertions

# Test 1: Concurrent publishes don't corrupt event log
echo "ok 1 - Concurrent publishes successful"

# Test 2: Topic filtering works under load
echo "ok 2 - Topic filtering accurate under load"

# Test 3: Pull-based delivery doesn't block publishers
echo "ok 3 - Publishers return immediately"

# Test 4: Event ring buffer enforced (max 1000)
echo "ok 4 - Ring buffer trims old events"

# Test 5: Metrics tracking accurate under load
echo "ok 5 - Metrics accurate after stress"

# Test 6: Subscription filtering prevents irrelevant events
echo "ok 6 - Filtering prevents spam"

# Test 7: Event throughput scales linearly
echo "ok 7 - Throughput acceptable (no bottlenecks)"
```

Implementation requirements:
- Source event-bus.sh, event-metrics.sh
- Initialize event bus with initialize_event_bus
- Launch 50 concurrent publishers (each publishes 10 events = 500 total)
- Verify all events in event_log (or 1000 if ring buffer trimmed)
- Create 10 subscribers with different topic patterns
- Verify each subscriber receives only matching events
- Measure publish latency (should be < 100ms per publish)
- Verify ring buffer: check event_log length <= 1000
- Verify metrics: total_published = 500, backlog_count accurate
- Test topic pattern wildcards: "task_*" matches "task_started", "task_completed"
- Verify no publisher blocked (measure time, should be near-instant)
- Check event deduplication (same correlation_id not duplicated)
- Use get_events_for_subscriber with since-last-delivered semantics
- Verify mark_events_delivered updates last_event_delivered
  </action>
  <verify>Run `bash tests/stress/event-scalability.test.sh` and verify all 7 TAP assertions pass with acceptable throughput</verify>
  <done>Event scalability test validates concurrent pub/sub, filtering, ring buffer, and metrics</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Three stress test files covering concurrent access, spawn limits, and event bus scalability</what-built>
  <how-to-verify>
1. Run all stress tests via orchestrator:
   `bash tests/test-orchestrator.sh --all --verbose`

2. Verify concurrent-access.test.sh:
   - 10 concurrent reads succeed without corruption
   - 10 concurrent writes serialize correctly (file locking)
   - File lock acquired exclusively (no simultaneous writes)
   - Atomic write survives crash simulation
   - 5 concurrent checkpoints valid
   - All JSON files valid after stress (python3 json.tool)

3. Verify spawn-limits.test.sh:
   - 20 concurrent spawn attempts → only 10 succeed
   - Depth 10 attempt → stops at depth 3
   - Circuit breaker trips after 3 failures
   - Cooldown blocks subsequent spawns
   - Same-specialist cache prevents duplicates
   - spawn_history accurate (all attempts recorded)
   - No infinite loops (all processes complete)

4. Verify event-scalability.test.sh:
   - 50 concurrent publishers × 10 events = 500 published
   - Topic filtering accurate (wildcards work)
   - Publishers return immediately (async)
   - Ring buffer trims to 1000 events max
   - Metrics accurate (total_published, backlog)
   - Filtering prevents spam (subscribers get only matches)
   - Throughput acceptable (< 100ms per publish)

5. Check for any deadlocks or hangs:
   - All tests should complete within 60 seconds
   - No orphan background processes
   - Clean state after cleanup

Expected: All 20 stress tests pass (6 + 7 + 7)
  </how-to-verify>
  <resume-signal>Type "approved" if stress tests pass, or describe failures/deadlocks</resume-signal>
</task>

</tasks>

<verification>
- concurrent-access.test.sh has executable permissions and 6 passing tests
- spawn-limits.test.sh has executable permissions and 7 passing tests
- event-scalability.test.sh has executable permissions and 7 passing tests
- All tests use background processes for concurrent execution
- Tests use wait to collect processes and verify exit codes
- Tests include timeout to prevent hangs
- JSON validation confirms no corruption
- Metrics tracked for performance analysis
</verification>

<success_criteria>
- Stress tests validate system behavior under concurrent load
- File locking prevents race conditions in state access
- Spawn limits enforced even under concurrent attempts
- Circuit breakers trigger reliably under stress
- Event bus handles concurrent operations without corruption
- Performance metrics identify bottlenecks
- No infinite loops or deadlocks detected
</success_criteria>

<output>
After completion, create `.planning/phases/10-colony-maturity**---end-to-end-testing,-pattern-extraction,-production-readiness/10-03-SUMMARY.md`
</output>
