---
phase: 20-utility-modules
plan: 02
type: execute
wave: 2
depends_on: ["20-01"]
files_modified:
  - .aether/aether-utils.sh
autonomous: true

must_haves:
  truths:
    - "Running `aether-utils validate-state colony` checks COLONY_STATE.json for required fields (goal, state, current_phase, workers, spawn_outcomes) with type checking"
    - "Running `aether-utils validate-state pheromones` checks pheromones.json signals array and per-signal required fields"
    - "Running `aether-utils validate-state errors` checks errors.json for errors array, flagged_patterns array, and per-error field structure"
    - "Running `aether-utils validate-state memory` checks memory.json for phase_learnings, decisions, and patterns arrays"
    - "Running `aether-utils validate-state events` checks events.json for events array and per-event required fields"
    - "Running `aether-utils validate-state all` runs all 5 validators and reports aggregate pass/fail with per-file results"
  artifacts:
    - path: ".aether/aether-utils.sh"
      provides: "State validation subcommands (validate-state colony|pheromones|errors|memory|events|all)"
      contains: "validate-state)"
  key_links:
    - from: ".aether/aether-utils.sh"
      to: ".aether/data/COLONY_STATE.json"
      via: "jq schema validation in validate-state colony"
      pattern: "COLONY_STATE\\.json"
    - from: ".aether/aether-utils.sh"
      to: ".aether/data/pheromones.json"
      via: "jq schema validation in validate-state pheromones"
      pattern: "pheromones\\.json"
---

<objective>
Add the validate-state subcommand with 6 sub-subcommands (colony, pheromones, errors, memory, events, all) to aether-utils.sh.

Purpose: Deterministic schema validation catches corruption and missing fields that LLMs would silently overlook. This is the safety net for all state operations.
Output: aether-utils.sh with validate-state case branch and ~60 lines added.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-utility-modules/20-RESEARCH.md
@.aether/aether-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add validate-state subcommand with 6 validators</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Add a `validate-state)` case branch to aether-utils.sh BEFORE the `*)` catch-all. This branch contains a nested case on the first argument (colony|pheromones|errors|memory|events|all).

Also add a shared helper function `check_fields` BEFORE the case dispatch (after the json_ok/json_err helpers) to keep validators compact:

```bash
# Validate fields exist and have expected types in a JSON file
# Usage: check_fields <file> <jq_expression>
check_fields() {
  local file="$1" check="$2"
  [[ -f "$file" ]] || { echo '{"file":"'"$(basename "$file")"'","pass":false,"errors":["file not found"]}'; return; }
  jq -e "$check" "$file" 2>/dev/null || { echo '{"file":"'"$(basename "$file")"'","pass":false,"errors":["invalid JSON"]}'; return; }
}
```

**Schema validation rules (from research -- exact schemas):**

**1. validate-state colony** (VALID-01):
File: `$DATA_DIR/COLONY_STATE.json`
Required fields and types:
- `goal`: string or null
- `state`: string
- `current_phase`: number
- `workers`: object
- `spawn_outcomes`: object

```bash
colony)
  [[ -f "$DATA_DIR/COLONY_STATE.json" ]] || json_err "COLONY_STATE.json not found"
  json_ok "$(jq '
    def chk(f;t): if has(f) then (if (.[f]|type) as $a | t | any(. == $a) then "pass" else "fail: \(f) is \(.[f]|type), expected \(t|join("|"))" end) else "fail: missing \(f)" end;
    {file:"COLONY_STATE.json", checks:[
      chk("goal";["null","string"]),
      chk("state";["string"]),
      chk("current_phase";["number"]),
      chk("workers";["object"]),
      chk("spawn_outcomes";["object"])
    ]} | . + {pass: ([.checks[] | select(startswith("pass"))] | length) == (.checks | length)}
  ' "$DATA_DIR/COLONY_STATE.json")"
  ;;
```

**2. validate-state pheromones** (VALID-02):
File: `$DATA_DIR/pheromones.json`
Required: `signals` (array). Each signal requires: `id` (string), `type` (string), `content` (string), `strength` (number), `created_at` (string).

```bash
pheromones)
  [[ -f "$DATA_DIR/pheromones.json" ]] || json_err "pheromones.json not found"
  json_ok "$(jq '
    def arr(f): if has(f) and (.[f]|type) == "array" then "pass" else "fail: \(f) not array" end;
    def sig: ["id","type","content","strength","created_at"] as $req | [. as $s | $req[] | select($s[.] == null)] |
      if length == 0 then "pass" else "fail: signal missing \(join(","))" end;
    {file:"pheromones.json", checks:[
      arr("signals"),
      (.signals | if length == 0 then "pass" else [.[] | sig] | map(select(. != "pass")) |
        if length == 0 then "pass" else .[0] end end)
    ]} | . + {pass: ([.checks[] | select(. == "pass")] | length) == (.checks | length)}
  ' "$DATA_DIR/pheromones.json")"
  ;;
```

**3. validate-state errors** (VALID-03):
File: `$DATA_DIR/errors.json`
Required top-level: `errors` (array), `flagged_patterns` (array).
Per error: `id`, `category`, `severity`, `description`, `timestamp` (all strings).

```bash
errors)
  [[ -f "$DATA_DIR/errors.json" ]] || json_err "errors.json not found"
  json_ok "$(jq '
    def arr(f): if has(f) and (.[f]|type) == "array" then "pass" else "fail: \(f) not array" end;
    def erchk: ["id","category","severity","description","timestamp"] as $req | [. as $e | $req[] | select($e[.] == null)] |
      if length == 0 then "pass" else "fail: error missing \(join(","))" end;
    {file:"errors.json", checks:[
      arr("errors"), arr("flagged_patterns"),
      (.errors | if length == 0 then "pass" else [.[] | erchk] | map(select(. != "pass")) |
        if length == 0 then "pass" else .[0] end end)
    ]} | . + {pass: ([.checks[] | select(. == "pass")] | length) == (.checks | length)}
  ' "$DATA_DIR/errors.json")"
  ;;
```

**4. validate-state memory** (VALID-04):
File: `$DATA_DIR/memory.json`
Required: `phase_learnings` (array), `decisions` (array), `patterns` (array).

```bash
memory)
  [[ -f "$DATA_DIR/memory.json" ]] || json_err "memory.json not found"
  json_ok "$(jq '
    def arr(f): if has(f) and (.[f]|type) == "array" then "pass" else "fail: \(f) not array" end;
    {file:"memory.json", checks:[arr("phase_learnings"), arr("decisions"), arr("patterns")]}
    | . + {pass: ([.checks[] | select(. == "pass")] | length) == (.checks | length)}
  ' "$DATA_DIR/memory.json")"
  ;;
```

**5. validate-state events** (VALID-05):
File: `$DATA_DIR/events.json`
Required: `events` (array). Each event requires: `id`, `type`, `source`, `content`, `timestamp` (all strings).

```bash
events)
  [[ -f "$DATA_DIR/events.json" ]] || json_err "events.json not found"
  json_ok "$(jq '
    def arr(f): if has(f) and (.[f]|type) == "array" then "pass" else "fail: \(f) not array" end;
    def evchk: ["id","type","source","content","timestamp"] as $req | [. as $e | $req[] | select($e[.] == null)] |
      if length == 0 then "pass" else "fail: event missing \(join(","))" end;
    {file:"events.json", checks:[
      arr("events"),
      (.events | if length == 0 then "pass" else [.[] | evchk] | map(select(. != "pass")) |
        if length == 0 then "pass" else .[0] end end)
    ]} | . + {pass: ([.checks[] | select(. == "pass")] | length) == (.checks | length)}
  ' "$DATA_DIR/events.json")"
  ;;
```

**6. validate-state all** (VALID-06):
Calls all 5 validators by recursively invoking self. Outputs aggregate result.

```bash
all)
  local results=()
  for target in colony pheromones errors memory events; do
    results+=("$(bash "$SCRIPT_DIR/aether-utils.sh" validate-state "$target" 2>/dev/null || echo '{"ok":false}')")
  done
  local combined; combined=$(printf '%s\n' "${results[@]}" | jq -s '[.[] | .result // {file:"unknown",pass:false}]')
  local all_pass; all_pass=$(echo "$combined" | jq 'all(.pass)')
  json_ok "{\"pass\":$all_pass,\"files\":$combined}"
  ;;
```

**Important implementation notes:**
- The `validate-state)` branch does `case "${1:-}" in colony) ... events) ... all) ... *) json_err "Usage: validate-state colony|pheromones|errors|memory|events|all" ;; esac`
- Do NOT add the `check_fields` helper -- the research explored it but the inline jq approach is more compact
- Update help text to include `validate-state`
  </action>
  <verify>
Run validators against existing state files:

```bash
# Run all validators
bash .aether/aether-utils.sh validate-state all

# Individual validators
bash .aether/aether-utils.sh validate-state colony
bash .aether/aether-utils.sh validate-state pheromones
bash .aether/aether-utils.sh validate-state memory
bash .aether/aether-utils.sh validate-state events
bash .aether/aether-utils.sh validate-state errors

# Error handling: missing subcommand
bash .aether/aether-utils.sh validate-state 2>/dev/null; echo "exit: $?"

# Error handling: invalid subcommand
bash .aether/aether-utils.sh validate-state bogus 2>/dev/null; echo "exit: $?"

# Line count check
wc -l .aether/aether-utils.sh
```
  </verify>
  <done>
All 6 validate-state subcommands work correctly. `validate-state all` reports per-file pass/fail with field-level errors for any violations. Each validator checks required fields and types per the canonical schemas from research. Invalid usage returns non-zero with JSON error.
  </done>
</task>

</tasks>

<verification>
1. `bash .aether/aether-utils.sh validate-state colony` outputs pass/fail with field checks
2. `bash .aether/aether-utils.sh validate-state all` reports all 5 files with aggregate pass/fail
3. Each validator catches missing fields (test by piping malformed JSON)
4. Total line count of aether-utils.sh remains reasonable (~150 lines after this plan)
</verification>

<success_criteria>
- VALID-01: validate-state colony checks required fields and types in COLONY_STATE.json
- VALID-02: validate-state pheromones checks signals array and per-signal fields
- VALID-03: validate-state errors checks errors/flagged_patterns arrays and per-error fields
- VALID-04: validate-state memory checks phase_learnings, decisions, patterns arrays
- VALID-05: validate-state events checks events array and per-event fields
- VALID-06: validate-state all runs all 5 and reports aggregate pass/fail
- All validators output JSON, return non-zero on invalid input
</success_criteria>

<output>
After completion, create `.planning/phases/20-utility-modules/20-02-SUMMARY.md`
</output>
