---
phase: 20-utility-modules
plan: 03
type: execute
wave: 3
depends_on: ["20-02"]
files_modified:
  - .aether/aether-utils.sh
autonomous: true

must_haves:
  truths:
    - "Running `aether-utils memory-token-count` outputs JSON with approximate token count of memory.json (word count * 1.3)"
    - "Running `aether-utils memory-compress` removes oldest phase_learnings beyond 20 and oldest decisions beyond 30, then verifies token count"
    - "Running `aether-utils memory-search <keyword>` finds matching entries across all memory.json arrays"
  artifacts:
    - path: ".aether/aether-utils.sh"
      provides: "Memory operation subcommands (memory-token-count, memory-compress, memory-search)"
      contains: "memory-token-count)"
  key_links:
    - from: ".aether/aether-utils.sh"
      to: ".aether/data/memory.json"
      via: "jq read/write for all memory subcommands"
      pattern: "memory\\.json"
---

<objective>
Add 3 memory operation subcommands to aether-utils.sh: memory-token-count, memory-compress, memory-search.

Purpose: Token counting and compression prevent memory.json from growing unbounded. Search enables knowledge retrieval without LLM scanning the full file.
Output: aether-utils.sh with 3 new case branches, ~30 lines added.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-utility-modules/20-RESEARCH.md
@.aether/aether-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 3 memory operation subcommands to aether-utils.sh</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Add 3 new case branches to aether-utils.sh BEFORE the `*)` catch-all. Update help text to list the new commands.

**1. memory-token-count** (MEM-01): Reads memory.json, extracts all string values, joins them, splits on spaces, counts words, multiplies by 1.3.

```bash
memory-token-count)
  [[ -f "$DATA_DIR/memory.json" ]] || json_err "memory.json not found"
  json_ok "$(jq '{tokens: ([.. | strings] | join(" ") | split(" ") | length | . * 1.3 | floor)}' "$DATA_DIR/memory.json")"
  ;;
```

**2. memory-compress** (MEM-02): Enforces retention limits: phase_learnings capped at 20 (keep newest), decisions capped at 30 (keep newest). Accepts optional token threshold arg (default 10000). After trimming arrays, checks if token count still exceeds threshold and removes more oldest entries if needed. Writes back via atomic_write.

```bash
memory-compress)
  [[ -f "$DATA_DIR/memory.json" ]] || json_err "memory.json not found"
  local threshold="${1:-10000}"
  local result; result=$(jq --arg th "$threshold" '
    .phase_learnings |= (if length > 20 then .[-20:] else . end) |
    .decisions |= (if length > 30 then .[-30:] else . end) |
    . as $trimmed |
    ([.. | strings] | join(" ") | split(" ") | length | . * 1.3 | floor) as $tokens |
    if $tokens > ($th|tonumber) then
      .phase_learnings |= (if length > 10 then .[-10:] else . end) |
      .decisions |= (if length > 15 then .[-15:] else . end)
    else . end
  ' "$DATA_DIR/memory.json") || json_err "Failed to process memory.json"
  atomic_write "$DATA_DIR/memory.json" "$result"
  local tokens; tokens=$(echo "$result" | jq '[.. | strings] | join(" ") | split(" ") | length | . * 1.3 | floor')
  json_ok "{\"compressed\":true,\"tokens\":$tokens}"
  ;;
```

**3. memory-search** (MEM-03): Takes 1 required keyword arg. Searches across all 3 arrays (phase_learnings, decisions, patterns) for entries containing the keyword (case-insensitive). Returns matching entries grouped by array name.

```bash
memory-search)
  [[ $# -ge 1 ]] || json_err "Usage: memory-search <keyword>"
  [[ -f "$DATA_DIR/memory.json" ]] || json_err "memory.json not found"
  json_ok "$(jq --arg kw "$1" '
    ($kw | ascii_downcase) as $k |
    {
      phase_learnings: [.phase_learnings[]? | select(tostring | ascii_downcase | contains($k))],
      decisions: [.decisions[]? | select(tostring | ascii_downcase | contains($k))],
      patterns: [.patterns[]? | select(tostring | ascii_downcase | contains($k))]
    }
  ' "$DATA_DIR/memory.json")"
  ;;
```

**Help text:** Add `memory-token-count`, `memory-compress`, `memory-search` to the commands array in the help case.

**Important notes:**
- memory-compress applies hard caps first (20 learnings, 30 decisions), then checks token count
- If token count still exceeds threshold after hard caps, it aggressively halves the caps (10 learnings, 15 decisions)
- The `[.. | strings]` jq recursive descent extracts ALL string values from any nesting depth
- memory-search uses `tostring` to stringify each entry before matching, so it finds keywords in any field
  </action>
  <verify>
```bash
# Token count
bash .aether/aether-utils.sh memory-token-count

# Search for a keyword (use something that exists in memory)
bash .aether/aether-utils.sh memory-search "phase"

# Compress with default threshold
bash .aether/aether-utils.sh memory-compress

# Compress with low threshold to force trimming
bash .aether/aether-utils.sh memory-compress 100

# Error handling
bash .aether/aether-utils.sh memory-search 2>/dev/null; echo "exit: $?"

# Line count
wc -l .aether/aether-utils.sh
```
  </verify>
  <done>
All 3 memory subcommands produce correct JSON output. memory-token-count returns word-based token approximation. memory-compress enforces retention limits and reports final token count. memory-search finds entries matching keyword across all arrays. Total line count stays under 200.
  </done>
</task>

</tasks>

<verification>
1. `bash .aether/aether-utils.sh memory-token-count` outputs `{"ok":true,"result":{"tokens":N}}`
2. `bash .aether/aether-utils.sh memory-compress` trims arrays to retention limits
3. `bash .aether/aether-utils.sh memory-search "phase"` returns grouped matches
4. Missing args return non-zero with JSON error
5. Line count still under budget
</verification>

<success_criteria>
- MEM-01: memory-token-count outputs approximate token count (word count * 1.3)
- MEM-02: memory-compress enforces phase_learnings <= 20, decisions <= 30, and checks token threshold
- MEM-03: memory-search finds entries containing keyword across all arrays (case-insensitive)
- All commands return JSON, non-zero on error
</success_criteria>

<output>
After completion, create `.planning/phases/20-utility-modules/20-03-SUMMARY.md`
</output>
