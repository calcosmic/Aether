---
phase: 20-utility-modules
plan: 04
type: execute
wave: 4
depends_on: ["20-03"]
files_modified:
  - .aether/aether-utils.sh
autonomous: true

must_haves:
  truths:
    - "Running `aether-utils error-add build high \"Test failure in auth module\"` appends a timestamped error with auto-generated ID to errors.json"
    - "Running `aether-utils error-pattern-check` flags categories with 3+ occurrences"
    - "Running `aether-utils error-summary` outputs counts grouped by category and severity"
    - "Running `aether-utils error-dedup` removes duplicate errors (same category + description within 60 seconds)"
  artifacts:
    - path: ".aether/aether-utils.sh"
      provides: "Error tracking subcommands (error-add, error-pattern-check, error-summary, error-dedup)"
      contains: "error-add)"
  key_links:
    - from: ".aether/aether-utils.sh"
      to: ".aether/data/errors.json"
      via: "jq read/write for all error subcommands"
      pattern: "errors\\.json"
    - from: ".aether/aether-utils.sh"
      to: ".aether/utils/atomic-write.sh"
      via: "atomic_write call in error-add and error-dedup"
      pattern: "atomic_write"
---

<objective>
Add 4 error tracking subcommands to aether-utils.sh: error-add, error-pattern-check, error-summary, error-dedup. Also finalize help text with ALL 18 subcommands and verify total line count is under 300.

Purpose: Deterministic error tracking replaces LLM-approximated pattern detection. Auto-generated IDs and timestamps prevent inconsistency. Category pattern flagging surfaces systemic issues reliably.
Output: Complete aether-utils.sh with all 18 subcommands, under 300 lines.
</objective>

<execution_context>
@~/.claude/cosmic-dev-system/workflows/execute-plan.md
@~/.claude/cosmic-dev-system/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-utility-modules/20-RESEARCH.md
@.aether/aether-utils.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add 4 error tracking subcommands to aether-utils.sh</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Add 4 new case branches to aether-utils.sh BEFORE the `*)` catch-all.

**1. error-add** (ERR-01): Takes 3 required args: category, severity, description. Generates auto-ID using `err_<epoch>_<4hex>` pattern. Appends to errors.json. Enforces 50-error retention limit (keeps newest). Does NOT validate category -- accepts any string (per research Pitfall 3, success criteria uses "build" which is not in the 12 known categories).

```bash
error-add)
  [[ $# -ge 3 ]] || json_err "Usage: error-add <category> <severity> <description>"
  [[ -f "$DATA_DIR/errors.json" ]] || json_err "errors.json not found"
  local id; id="err_$(date -u +%s)_$(head -c 2 /dev/urandom | od -An -tx1 | tr -d ' ')"
  local ts; ts=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
  local updated; updated=$(jq --arg id "$id" --arg cat "$1" --arg sev "$2" --arg desc "$3" --arg ts "$ts" '
    .errors += [{id:$id, category:$cat, severity:$sev, description:$desc, root_cause:null, phase:null, task_id:null, timestamp:$ts}] |
    if (.errors|length) > 50 then .errors = .errors[-50:] else . end
  ' "$DATA_DIR/errors.json") || json_err "Failed to update errors.json"
  atomic_write "$DATA_DIR/errors.json" "$updated"
  json_ok "\"$id\""
  ;;
```

**2. error-pattern-check** (ERR-02): Reads errors.json, groups by category, flags categories with 3+ occurrences. Outputs array of flagged patterns with category, count, first_seen, last_seen.

```bash
error-pattern-check)
  [[ -f "$DATA_DIR/errors.json" ]] || json_err "errors.json not found"
  json_ok "$(jq '
    .errors | group_by(.category) | map(select(length >= 3) |
      {category: .[0].category, count: length,
       first_seen: (sort_by(.timestamp) | first.timestamp),
       last_seen: (sort_by(.timestamp) | last.timestamp)})
  ' "$DATA_DIR/errors.json")"
  ;;
```

**3. error-summary** (ERR-03): Reads errors.json, outputs counts grouped by category and by severity.

```bash
error-summary)
  [[ -f "$DATA_DIR/errors.json" ]] || json_err "errors.json not found"
  json_ok "$(jq '{
    total: (.errors | length),
    by_category: (.errors | group_by(.category) | map({key: .[0].category, count: length}) | from_entries),
    by_severity: (.errors | group_by(.severity) | map({key: .[0].severity, count: length}) | from_entries)
  }' "$DATA_DIR/errors.json")"
  ;;
```

**4. error-dedup** (ERR-04): Reads errors.json, removes duplicate errors defined as same category + description within 60 seconds of each other. Keeps the earliest of each duplicate set. Writes back via atomic_write.

```bash
error-dedup)
  [[ -f "$DATA_DIR/errors.json" ]] || json_err "errors.json not found"
  local before; before=$(jq '.errors | length' "$DATA_DIR/errors.json")
  local result; result=$(jq '
    .errors |= (group_by(.category + "|" + .description) | map(
      sort_by(.timestamp) | . as $grp |
      [$grp[0]] + [$grp[range(1;length)] | select(
        (.timestamp | sub("\\.[0-9]+Z$";"Z") | fromdate) -
        ($grp[0].timestamp | sub("\\.[0-9]+Z$";"Z") | fromdate) > 60
      )]
    ) | flatten)
  ' "$DATA_DIR/errors.json") || json_err "Failed to process errors.json"
  atomic_write "$DATA_DIR/errors.json" "$result"
  local after; after=$(echo "$result" | jq '.errors | length')
  json_ok "{\"removed\":$((before - after)),\"remaining\":$after}"
  ;;
```

**Finalize help text:** Update the help case to list ALL 18 subcommands in the commands array:
```json
["help","version","pheromone-decay","pheromone-effective","pheromone-batch","pheromone-cleanup","pheromone-combine","validate-state","memory-token-count","memory-compress","memory-search","error-add","error-pattern-check","error-summary","error-dedup"]
```

**Important notes:**
- error-add accepts ANY string as category (do not validate against the 12 known categories)
- error-add enforces 50-error retention: `if length > 50 then .[-50:]` keeps newest
- error-dedup groups by category+description, sorts by timestamp, keeps earliest, drops others within 60s window
- error-pattern-check threshold is 3+ errors of same category
- After adding all 4 commands, verify total line count is under 300 with `wc -l`
  </action>
  <verify>
```bash
# Add a test error
bash .aether/aether-utils.sh error-add build high "Test failure in auth module"

# Add 2 more of same category for pattern detection
bash .aether/aether-utils.sh error-add build medium "Another build issue"
bash .aether/aether-utils.sh error-add build low "Third build error"

# Pattern check should flag 'build' with count 3
bash .aether/aether-utils.sh error-pattern-check

# Summary should show counts
bash .aether/aether-utils.sh error-summary

# Dedup (may remove 0 if timestamps are >60s apart)
bash .aether/aether-utils.sh error-dedup

# Error handling
bash .aether/aether-utils.sh error-add 2>/dev/null; echo "exit: $?"

# CRITICAL: Total line count must be under 300
wc -l .aether/aether-utils.sh

# Full help shows all commands
bash .aether/aether-utils.sh help
```
  </verify>
  <done>
All 4 error subcommands produce correct JSON. `error-add build high "Test failure"` appends error with auto-ID. `error-pattern-check` flags categories with 3+ errors. `error-summary` groups by category and severity. `error-dedup` removes duplicates within 60s window. Help lists all 18 subcommands. Total line count is under 300.
  </done>
</task>

<task type="auto">
  <name>Task 2: Final verification -- all 18 subcommands and line budget</name>
  <files>.aether/aether-utils.sh</files>
  <action>
Run a comprehensive verification of all 18 subcommands end-to-end. This is a verification-only task -- no code changes unless a subcommand fails.

**Test matrix (all must produce valid JSON and exit 0 on valid input):**

1. `bash .aether/aether-utils.sh help` -- lists all commands
2. `bash .aether/aether-utils.sh version` -- outputs version
3. `bash .aether/aether-utils.sh pheromone-decay 1.0 3600 3600` -- strength ~0.5
4. `bash .aether/aether-utils.sh pheromone-effective 0.9 0.8` -- 0.72
5. `bash .aether/aether-utils.sh pheromone-batch` -- reads pheromones.json
6. `bash .aether/aether-utils.sh pheromone-cleanup` -- removes expired
7. `bash .aether/aether-utils.sh pheromone-combine 0.8 0.3` -- net 0.5
8. `bash .aether/aether-utils.sh validate-state colony`
9. `bash .aether/aether-utils.sh validate-state pheromones`
10. `bash .aether/aether-utils.sh validate-state errors`
11. `bash .aether/aether-utils.sh validate-state memory`
12. `bash .aether/aether-utils.sh validate-state events`
13. `bash .aether/aether-utils.sh validate-state all`
14. `bash .aether/aether-utils.sh memory-token-count`
15. `bash .aether/aether-utils.sh memory-compress`
16. `bash .aether/aether-utils.sh memory-search "phase"`
17. `bash .aether/aether-utils.sh error-add test high "Verification test error"`
18. `bash .aether/aether-utils.sh error-pattern-check`
19. `bash .aether/aether-utils.sh error-summary`
20. `bash .aether/aether-utils.sh error-dedup`

**Error handling tests (all must exit non-zero with JSON error on stderr):**
21. `bash .aether/aether-utils.sh pheromone-decay` (missing args)
22. `bash .aether/aether-utils.sh bogus-command` (unknown command)
23. `bash .aether/aether-utils.sh memory-search` (missing keyword)

**Line budget:**
24. `wc -l .aether/aether-utils.sh` -- must output a number under 300

If any test fails, fix the specific subcommand that failed. Do not refactor working code.
  </action>
  <verify>
All 20 success-path commands exit 0 and produce valid JSON (pipe each through `jq .` to confirm).
All 3 error-path commands exit non-zero.
Line count is under 300.
  </verify>
  <done>
All 18 subcommands verified working. All produce valid JSON on stdout. Error cases return non-zero with JSON on stderr. Total line count under 300. Phase 20 is complete.
  </done>
</task>

</tasks>

<verification>
1. `bash .aether/aether-utils.sh error-add build high "Test failure in auth module"` outputs `{"ok":true,"result":"err_..."}`
2. After adding 3 errors of same category, `error-pattern-check` flags that category
3. `error-summary` shows correct counts by category and severity
4. `error-dedup` removes duplicate errors within 60s window
5. `bash .aether/aether-utils.sh help` lists all 18 subcommands
6. `wc -l .aether/aether-utils.sh` outputs a number less than 300
7. Every subcommand returns valid JSON (parseable by `jq .`)
</verification>

<success_criteria>
- ERR-01: error-add appends timestamped error with auto-ID, enforces 50-error retention
- ERR-02: error-pattern-check flags categories with 3+ occurrences
- ERR-03: error-summary outputs counts by category and severity
- ERR-04: error-dedup removes duplicates (same category+description within 60s)
- All 18 subcommands work end-to-end
- Total aether-utils.sh is under 300 lines
- Phase 20 success criteria 1-5 from roadmap all pass
</success_criteria>

<output>
After completion, create `.planning/phases/20-utility-modules/20-04-SUMMARY.md`
</output>
